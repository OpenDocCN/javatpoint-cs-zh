# 锁定变量

> 原文:[https://www.javatpoint.com/os-lock-variable-mechanism](https://www.javatpoint.com/os-lock-variable-mechanism)

这是最简单的同步机制。这是一个在用户模式下实现的软件机制。这是一个繁忙的等待解决方案，可用于两个以上的进程。

在该机制中，使用锁定变量**锁定**。锁的两个值可以是 0 或 1。锁定值 0 表示临界区是空的，而锁定值 1 表示它被占用。

想要进入临界区的进程首先检查锁变量的值。如果它是 0，那么它将锁的值设置为 1，并进入临界区，否则它等待。

该机制的伪代码如下所示。

```

Entry Section → 
While (lock! = 0); 
Lock = 1;
//Critical Section 
Exit Section →
Lock =0;

```

如果我们看看伪代码，我们发现代码中有三个部分。入口部分、关键部分和出口部分。

最初**锁定变量**的值是 **0** 。需要进入**临界区**的过程，进入入口区并检查 while 循环中提供的条件。

该过程将无限等待直到**锁定**的值为 1(即 while 循环所暗示的)。因为在第一次临界区是空的，所以通过将锁变量设置为 1，过程将进入临界区。

当进程从临界区退出时，在退出区，它将**锁定**的值重新指定为 0。

每个同步机制都是基于四个条件来判断的。

1.  互斥现象
2.  进步
3.  有界等待
4.  轻便

在这四个参数中，互斥和进度必须由任何解决方案提供。让？让我们在上述条件的基础上分析这一机制。

## 互斥现象

在某些情况下，锁变量机制不提供互斥。从操作系统的角度来看伪代码，即程序的汇编代码，可以更好地描述这一点。让我们把代码转换成汇编语言。

1.  *加载锁定，R0*
2.  *CMP R0、#0*
3.  *JNZ Step 1*
4.  *1 号店，锁定*
5.  *0 号店，锁定*

让我们考虑一下，我们有两个进程 P1 和 P2。P1 想要执行其关键部分的过程。P1 进入了入口区。由于锁的值为 0，因此 P1 将其值从 0 更改为 1，并进入临界区。

同时，P1 被中央处理器抢占，P2 被调度。现在临界区没有其他进程，锁变量的值为 0。P2 也想执行其关键部分。它通过将锁定变量设置为 1 进入临界区。

现在，中央处理器将 P1 的状态从等待改为运行。P1 尚未完成其关键部分。P1 已经检查了锁变量的值，并且记得它之前检查时的值是 0。因此，它也进入临界区，而不检查锁变量的更新值。

现在，我们在关键部分有两个过程。根据互斥条件，临界区内不能同时存在多个过程。因此，锁变量机制不能保证互斥。

锁变量机制的问题是，同时，不止一个进程可以看到空标签，并且不止一个进程可以进入临界区。因此，锁变量不提供互斥，这就是为什么它不能被普遍使用的原因。

因为，这种方法在基本步骤上是失败的；因此，没有必要谈论需要满足的其他条件。