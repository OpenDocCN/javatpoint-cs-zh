# 制表与记忆

> 原文:[https://www.javatpoint.com/tabulation-vs-memoization](https://www.javatpoint.com/tabulation-vs-memoization)

实现动态规划有两种方式，或者我们可以说有两种方式存储子问题的解，以便可以重用。

*   **制表**
*   **记忆**

**让我们简单地逐一了解每种方法。**

### 什么是制表？

制表是一种用于实现动态规划算法的技术。它也被称为自下而上的方法。它从解决最底层的子问题开始。对最低级子问题的解决将有助于解决下一级子问题，以此类推。我们迭代地解决所有的子问题，直到解决所有的子问题。这种方法节省了子问题需要解决之前已经解决的子问题的时间。

**我们通过一个例子来理解制表。**

**考虑斐波那契数列的一个例子。**

**假设我们需要计算 F(5)项。**

为了计算 F(5)项，有些子问题出现不止一次。比如 F(3)子问题出现两次，F(4)子问题出现四次。

尽管一次又一次地计算同一个子问题，我们可以一次又一次地存储一个子问题的结果，并且可以在任何需要的时候使用这个结果。

**我们来看看没有存储结果的代码。**

```

FIBONACCI(n)
  if n==0
    return 0
  if n==1
    return 1
  return FIBONACCI(n-1) + FIBONACCI(n-2)

```

在上面的代码中，我们只是简单地计算斐波那契数列，而没有存储结果。F(0)和 F(1)的值分别是 0 和 1。第 n 项的值使用斐波那契(n-1)+斐波那契(n-2)计算。

```

F = [] //new array
FIBONACCI(n)
  if F[n] == null
    if n==0
      F[n] = 0
    else if n==1
      F[n] = 1
    else
      F[n] = FIBONACCI(n-1) + FIBONACCI(n-2)
  return F[n]

```

上面的代码通过存储所有子问题的结果来计算斐波那契数列。我们使用条件 F[n] == null 来确定结果在数组中是否存在。

### 什么是记忆化？

**记忆**是一种用于实现动态规划算法的技术。记忆也称为自顶向下的方法。它从解决最高层次的子问题开始。最初，它解决最高级别的子问题，然后递归地解决下一个子问题。假设有两个子问题，即子问题 A 和子问题 B，当子问题 B 被递归调用时，那么它可以使用子问题 A 的解，这个解已经被使用过了。由于 A 和所有子问题都是记忆的，避免了求解 B 生成的整个递归树，节省了计算时间。

**让我们通过一个斐波那契数列的例子来理解记忆。**

数字是前面两个数字之和的数列。斐波那契数列是 0，1，1，2，3，5，8，13 等。

**计算斐波那契数列的条件如下:**

**如果 n = 0** ，则 F(n) = 0

**1 如果 n = 1**

**F(n-1) + f(n-2) if n > 1**

**递归求解程序**

```

def fib(n)
 if(n==0) or (n==1)
return n
else:
result = fib(n-1) + fib(n-2)
return result

```

求递归解的时间复杂度为 O(2 <sup>n</sup> )。

**记忆程序**

```

def fib(n, memo):
  if memo[n] is not None:
   return memo[n]
 if n==0 or n==1
   return n
else:
result = fib(n-1, memo)  + fib(n-2, memo)
memo[n] = result
return result
def fib_memo(n):
memo = [None] * (n+1)
 return fib(n, memo)

```

以上代码用于记忆。记忆是一种用于存储所有已解决的子问题的技术，因此我们不需要重新计算已经解决的子问题的解决方案，并且它还降低了时间复杂度。

**让我们了解一下制表和记忆的区别。**

**1。制表:**制表是一种递归求解子问题的技术。下面的代码显示了列表的工作方式:

```

int fib(int n)
{
    if(n<=1)
    return n;
  else
return fib(n-2) + fib(n-1)
} 

```

假设我们要计算 f(5)的斐波那契数列。f(5)的斐波那契数列是 0，1，1，2，3，5。总共有 15 个调用用于计算 f(15)。

![Tabulation vs Memoization](../Images/30976ffa834f46776c2d3f798e9c41f7.png)

**记忆化:**记忆化是一种用于非递归求解子问题的技术。

```

int fib(int n)
{
    if(n<=1)
    return n;
    f[0] = 0, f[1] = 1;
    for i=2 to n
    {
       f[i] = f[i-2] + f[i-1]
    }
   return f[n];
} 

```

以上代码时间复杂度为 O(2 <sup>n</sup> )。这个时间复杂度是非线性的。为了降低时间复杂度，我们可以使用记忆技术。这项技术减少了调用的次数，并且降低了时间复杂度。

**2。状态转换**

制表也称为自下而上的方法。它从基本状态 0 开始。一旦基本状态 0 被解决，它就移动到状态 1。状态 1 需要基本状态 0 的解。一旦状态 1 被解决，我们就进入状态 2。状态 2 需要状态 1 的解。这个过程会一直持续到我们到达 n 状态。“n”状态是目的地状态，也称为启动状态。这就是所谓的**状态转换关系**。

![Tabulation vs Memoization](../Images/8ccb1c449f0f7c3002f91d9d6d889dba.png)

记忆也称为自上而下的方法。它从最上面的状态开始，即 n,“n”状态需要解“n-1”状态，但“n-1”状态尚未解。“n-1”状态需要“n-2”状态的解才能求解其状态，但“n-2”状态尚未求解。它将进一步询问，直到达到基本状态。它会递归调用诸如 f(n)，f(n-1)，f(n-2)，...,0, 1.所以，这里我们从最上面的状态开始，递归地到达基本状态。

![Tabulation vs Memoization](../Images/4dc250bbc5a0bcff19bc55ef02391907.png)

**我们通过一个例子来理解这个概念。**

![Tabulation vs Memoization](../Images/880e71602ee31a12ce4c5ba47fa7cfe6.png)

在上图中，“0”是源顶点，而 5 是目标顶点。要到达顶点 5，我们可以从 2 或 3 开始。决定将基于顶点之间的距离。让我们假设顶点(0，2)之间的距离是 1，(0，3)是 2。如果我们考虑顶点 2，那么从顶点 0 到 5 的距离是(1+1) =2。如果我们考虑顶点 3，那么从顶点 0 到 5 的距离是(2+1) = 3。最小距离为 2，因此我们将考虑顶点 2 到达顶点 5。

### 制表和记忆的区别

![Tabulation vs Memoization](../Images/2437faa235ce302326f81cd48293f928.png)

**以下是列表和记忆的区别:**

| 表格 | 记忆化 |
| 在列表中，状态转换很难创建。 | 状态转换关系很容易创建。 |
| 当需要很多条件时，代码就变得困难了。 | 代码并不复杂，也不难创建。 |
| 它很快，因为以前解决的子问题的结果可以直接从表中访问。 | 它很慢，因为需要大量的递归调用和返回语句。 |
| 在列表版本中，所有条目必须逐个填写。 | 在记忆版本中，表中的条目是按需填充的。 |

* * *