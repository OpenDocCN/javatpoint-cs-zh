# SJF 某进程的中央处理器突发时间预测

> 原文：<https://www.javatpoint.com/os-prediction-of-cpu-burst-time-for-a-process-in-sjf>

SJF 算法是最好的调度算法之一，因为它提供了最大的吞吐量和最小的等待时间，但该算法的问题是，无法提前知道 CPU 突发时间。

我们可以估算一个进程的中央处理器爆发时间。有多种技术可以用来假设进程的中央处理器突发时间。我们的假设需要准确，以便最佳地利用算法。

以下技术用于假设进程的中央处理器突发时间。

## 1.静态技术

### 进程大小

我们可以从它的大小预测过程的爆发时间。如果我们有两个进程 **T_OLD** 和 **T_New** ，旧进程的实际爆发时间称为 **20 秒**，进程大小为 **20 KB** 。我们知道 **P_NEW 的大小是 21 KB** 。那么 **P_New** 具有与 **20 秒**相似的突发时间的概率最大。

```

If,     P_OLD → 20 KB 
P_New → 21 KB 
BT(P_OLD) → 20 Secs
Then, 
BT(P_New) → 20 secs

```

因此，在该技术中，我们实际上根据与新进程大小相似的旧进程的突发时间来预测新进程的突发时间。

### 流程类型

我们也可以根据进程的类型来预测它的爆发时间。流程可以是如下定义的各种类型。

*   **操作系统进程**

一个进程可以是一个操作系统进程，像调度程序、编译器、程序管理器和更多的系统进程。它们的爆发时间通常较低，例如 3 至 5 个时间单位。

*   **用户流程**

用户发起的进程称为用户进程。可以有以下三种类型的过程。

*   **互动流程**

交互过程是与用户不时交互的过程，或者其执行完全取决于用户的输入，例如各种游戏就是这样的过程。突发时间需要降低，因为它们不需要大量的中央处理器时间，它们主要取决于用户与进程的交互，因此它们主要是输入输出绑定的进程。

*   **前台流程**

前台进程是用户用来执行其需求的进程，如微软办公软件、编辑器、实用软件等。这些类型的进程具有稍高的突发时间，因为它们是 CPU 和 IO 绑定进程的完美结合。

*   **后台流程**

后台进程支持其他进程的执行。它们在隐藏模式下工作。例如，键记录器是记录用户按下的键和用户在系统上的活动的过程。它们主要是受 CPU 限制的进程，需要更多的 CPU 时间。

## 2.动态技术

### 简单平均

在简单平均中，给出了 n 个过程 P(i)的列表.......P(n)。让 T(i)表示过程 P(i)的突发时间。设τ(n)表示 Pth 过程的预测突发时间。那么根据简单的平均，过程 n+1 的预测突发时间将被计算为，

```

τ(n+1) = (1/n) ∑ T(i)

```

其中，0<=i<=n 和∑ T(i)是迄今为止所有可用进程的实际突发时间总和。

### 指数平均或老化

假设，Tn 是第 n 个进程的实际突发时间，τ(n)是第 n 个进程的预测突发时间，那么下一个进程(n+1)的 CPU 突发时间将被计算为，

```

τ(n+1) = α. Tn + (1-α) . τ(n)

```

其中，α是平滑度。它的值介于 0 和 1 之间。