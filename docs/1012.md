# 什么是伙伴系统？

> 原文:[https://www.javatpoint.com/what-is-buddy-system](https://www.javatpoint.com/what-is-buddy-system)

该区块的两个较小部分大小相等，称为伙伴。伙伴系统是一个过程，在这个过程中，两个单独的伙伴作为一个单元一起工作，这样他们就可以相互监视和帮助。类似地，两个伙伴中的一个将进一步分成更小的部分，直到请求被满足。

***韦氏词典*** 是 1942 年第一次使用好友系统这个短语。根据韦伯斯特的说法，伙伴系统是两个人配对的一种安排(在危险情况下为了相互安全)。

伙伴系统基本上是在一个大的群体中成对或单独一起工作。两个人都必须做这项工作。这项工作可以确保工作安全完成，或者有效地从一个人转移到另一个人。

### 伙伴系统的类型

有以下四种类型的好友系统。

**1。二进制好友系统**

好友系统维护每种大小的空闲块的列表(称为空闲列表)，以便在可用的情况下很容易找到所需大小的块。如果没有请求大小的块可用，分配会在第一个非空列表中搜索至少具有请求大小的块。在这两种情况下，都会从自由列表中删除一个块。

**例如，**假设内存段的大小最初为 256kb，内核请求 25kb 的内存。该片段最初被分成两个好友。假设 A1 和 A2，每个大小为 128kb。其中一个好友进一步分为两个 64kb 好友，B1 和 B2。但是 25kb 的次高幂是 32kb，因此，B1 或 B2 被进一步分成两个 32kb 的好友(C1 和 C2)，最后，这些好友中的一个被用来满足 25kb 的请求。拆分的块只能与其唯一的伙伴块合并，然后由伙伴块对拆分出的较大块进行重组。

![What is Buddy System](../Images/b013d72a61e188b5c89e9d2f61d70cf5.png)

**2。斐波那契伙伴系统**

斐波那契伙伴系统是一个系统，其中块被分成大小是斐波那契数。它满足以下关系:

Z<sub>i</sub> = Z<sub>(i-1)</sub>+Z<sub>(i-2)</sub>

斐波那契伙伴系统的原始过程要么局限于小的、固定数量的块大小，要么是耗时的计算。

**3。加权好友系统**

加权好友系统类似于原始好友系统。在该系统中，大块被反复分割以提供期望的较小块。当块被释放时，如果伙伴可用，它们将与其伙伴组合，否则，它们将被附加到可用空间列表中。二元和加权伙伴系统有以下相似之处。

*   计算一个区块的好友地址并给出该区块地址的简单性。二进制和加权伙伴系统的地址计算是直接的。
*   以及可用空间列表中的块的分配。

**4。三级伙伴系统**

第三代伙伴系统允许 2 k 和 3.2 k 的块大小，而原始的二进制伙伴系统只允许 2k 的块大小。这种扩展是以每块两位的额外成本实现的。该算法的仿真已经用 C 语言实现。

本文从内部碎片的角度分析了三级伙伴系统与其他现有方案(如二进制伙伴系统、斐波那契伙伴系统和加权伙伴系统)的性能。此外，还讨论了上述系统的几个分裂和平均合并数的模拟结果的比较。

### 伙伴系统内存分配技术

伙伴系统内存分配技术是一种算法，它将内存划分为多个分区，以尽可能合适地满足内存请求。该系统使用将内存分成两半的方法来提供最佳匹配。好友内存分配相对容易实现。它支持有限但有效的内存块分割和合并。

### 伙伴内存分配算法

有各种形式的伙伴系统，其中每个块被细分为两个更小的块是最简单和最常见的品种。该系统中的每个内存块都有一个 ***阶*** ，该阶是一个从 0 到指定的 ***上限*** 的整数。n 阶块的大小与 **2 <sup>n</sup>** 成正比，因此块的大小正好是低一阶块的两倍。两个块大小的幂使得地址计算变得简单，因为所有的伙伴都在内存地址边界上对齐，该边界是二的幂。

*   当一个较大的块被分割时，它被分成两个较小的块，每个较小的块成为另一个块的唯一伙伴。拆分的块只能与其唯一的伙伴块合并，然后由伙伴块对拆分出的较大块进行重组。
*   确定最小可能块的大小，即可以分配的最小存储块。如果不存在下限(例如，位大小的分配是可能的)，系统将有大量的内存和计算开销来跟踪内存的哪些部分被分配和未分配。
*   然而，一个相当低的限制可能是所希望的，使得每次分配的平均存储器浪费(关于大小不是最小块的倍数的分配)最小化。
*   通常，下限足够小，以最小化每次分配的平均浪费空间，但足够大，以避免过多的开销。然后将最小的块大小作为 0 阶块的大小，以便所有高阶都表示为该大小的 2 的幂的倍数。
*   然后，程序员必须决定或编写代码来适应剩余的可用内存空间，以获得最高可能的顺序。由于给定计算机系统中的总可用内存可能不是最小块大小的二次方，因此最大块大小可能不会跨越系统的整个内存。

例如，如果系统有 2000 K 的物理内存，并且 0 阶块大小为 4 K，则该阶的上限为 8，因为 8 阶块(256 个 0 阶块，1024 K)是内存中最大的块。因此，不可能在单个块中分配整个物理内存；剩余的 976 K 内存必须分配到更小的块中。

**优势**

好友系统分配有以下优点，例如:

*   与其他更简单的技术相比，伙伴存储系统几乎没有外部碎片。
*   伙伴存储器分配系统使用二叉树来表示已使用或未使用的分割存储器块来实现。
*   分配正确大小的块。
*   伙伴系统分配或释放内存的速度非常快。
*   在伙伴系统中，分配和释放一块内存的成本比最佳或第一适合算法的成本低。
*   很容易合并相邻的孔。
*   另一个主要优势是 ***聚结*** 。它被定义为相邻好友可以多快地组合成更大的片段。这就是所谓的聚结。

**劣势**

它也有一些缺点，例如:

*   它要求所有分配单位都是 2 的幂。
*   它导致内部分裂。

### 伙伴系统内存分配示例

下面是一个程序请求内存的例子。假设在这个系统中，最小可能的块大小为 64kb，顺序的上限为 4，这导致最大可能的可分配块，大小为 2 <sup>4</sup> 乘以 64 K = 1024 K。下图显示了各种内存请求后系统的可能状态。

![What is Buddy System](../Images/9641eff56fd3278886605e767a26c852.png)

这种内存分配可能以下列方式发生。

**第一步:**这是初始情况。

**步骤 2:** 程序 A 请求内存 34 K，顺序 0。

*   没有 0 阶块可用，因此 4 阶块被拆分，创建两个 3 阶块。
*   然而，没有 0 阶块可用，所以第一个 3 阶块被分割，创建两个 2 阶块。
*   然而，没有 0 阶块可用，所以第一个 2 阶块被分割，创建两个 1 阶块。
*   然而，没有 0 阶块可用，因此第一个 1 阶块被分割，创建两个 0 阶块。
*   现在，订单 0 块可用，因此将其分配给 a。

**步骤 3:** 程序 B 请求内存 66 K，顺序 1。订单 1 块可用，因此将其分配给 b。

**步骤 4:** 程序 C 请求内存 35 K，顺序 0。订单 0 块可用，因此将其分配给 c。

**步骤 5:** 程序 D 请求内存 67 K，顺序 1。

*   没有 1 号订单块可用，因此分割 2 号订单块，创建两个 1 号订单块。
*   现在有一个订单 1 块可用，所以它被分配给 d。

**第六步:**程序 B 释放内存，释放一个 1 阶块。

**第七步:**程序 D 释放内存。

*   一个一阶块被释放。
*   由于新释放的块的伙伴块也是空闲的，所以这两个块被合并成一个 2 阶块。

**第八步:**程序 A 释放内存，释放一个 0 阶块。

**第九步:**程序 C 释放内存。

*   释放一个 0 阶块。
*   由于新释放的块的伙伴块也是空闲的，所以这两个块被合并成一个 1 阶块。
*   由于新形成的 1 阶块的伙伴块也是空闲的，所以这两个块被合并成一个 2 阶块。
*   由于新形成的 2 阶块的伙伴块也是空闲的，所以这两个块被合并成一个 3 阶块。
*   由于新形成的 3 阶块的伙伴块也是空闲的，所以这两个块被合并成一个 4 阶块。

正如您在上面的步骤中所看到的，发出内存请求时会发生如下情况:

1.  **如果要分配内存。**
    1.  寻找一个合适大小的内存插槽(最小的 2 <sup>k</sup> 块大于或等于请求内存的大小)。
    2.  如果找到了，就分配给程序。
    3.  如果找不到，它会尝试制作一个合适的内存插槽。系统通过尝试以下方法来实现:
        *   将大于请求内存大小的空闲内存插槽分成两半。
        *   如果达到下限，则分配该内存量。
        *   回去找一个合适大小的内存插槽(**第一步**)。
        *   重复此过程，直到找到合适的内存插槽。
2.  **如果记忆是自由的。**
    1.  释放内存块。
    2.  看看邻近的街区。
    3.  如果它是空闲的，将两者结合起来，回到步骤二，重复这个过程，直到达到上限(所有内存都被释放)或者遇到非空闲的邻居块。

* * *