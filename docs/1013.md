# 为什么用户线程必须映射到内核线程？

> 原文:[https://www . javatpoint . com/为什么必须将用户线程映射到内核线程](https://www.javatpoint.com/why-must-user-threads-be-mapped-to-kernel-thread)

内核线程是能够由处理器调度和执行的实际线程。用户程序也可以制定自己的时间表。然而，这些不是内核线程。每个用户线程实际上不能独立运行，这就是为什么它需要一个内核级线程。

因此，为了让用户级线程取得进展，用户程序必须让它的调度程序获取用户级线程，并在内核级线程上运行它，然后我们有不同的映射来实现这一点。在继续之前，您需要简要了解用户线程、内核线程及其映射。

### 什么是线程？

线程是计算机系统中 CPU 利用率的基本原子单位。我们通常认为一个进程是 CPU 利用率的基本单位，但是一个进程可以进一步划分为多个执行线程。一个进程可以被分成不同的任务或者可以独立执行的单元，这些单元被称为线程。

线程是调度程序可以独立管理的轻量级进程。它使用并行性提高了应用程序的性能。线程共享数据段、代码段文件等信息。，而它包含自己的寄存器、堆栈、计数器等。计算机系统中创建的两种主要线程类型是:

1.  用户线程
2.  内核线程

线程可以在进程本身的地址空间中创建，即在进程内核参与或不参与的情况下创建。

![Why must User Threads be mapped to Kernel Thread](../Images/15fe415513c96330bc59c7cec05a09fa.png)

### 什么是用户线程？

用户线程是用户在用户库的帮助下创建的线程，只对创建过程及其运行时环境可见，内核不知道这些线程的创建。用户线程只是停留在创建进程的地址空间中，并由创建进程运行和管理，无需内核参与。

用户级线程很小，比内核级线程快得多。它们由程序计数器(PC)、堆栈、寄存器和一个小的过程控制块来表示。

**优势**

用户级线程的一些优势如下:

*   用户级线程比内核级线程更容易创建，速度也更快。它们也可以更容易管理。
*   用户级线程可以在任何操作系统上运行。
*   用户级线程中的线程切换不需要内核模式权限。

**缺点**

用户级线程有以下缺点，例如:

*   用户级线程中的多线程应用程序不能利用多处理来发挥它们的优势。
*   如果一个用户级线程执行阻塞操作，整个进程都会被阻塞。

### 什么是内核线程？

另一方面，内核级线程由操作系统直接处理，内核做线程管理。内核管理进程和进程线程的上下文信息。因此，内核级线程比用户级线程慢。

**优势**

内核级线程的一些优势如下:

*   同一进程的多个线程可以在内核级线程中的不同处理器上进行调度。
*   内核例程也可以是多线程的。
*   如果一个内核级线程被阻塞，同一进程的另一个线程可以被内核调度。

**缺点**

内核级线程也有以下缺点，例如:

*   在进程中将控制从一个线程转移到另一个线程时，需要切换到内核模式。
*   与用户级线程相比，内核级线程的创建和管理速度较慢。

### 用户线程如何映射到内核线程

线程库将用户线程映射到内核线程。这种映射方式被称为 ***线程模型*** 。

用户线程到内核线程的映射是使用 ***虚拟处理器*** 完成的。虚拟处理器(VP)是通常隐式的库实体。VP 是内核线程或绑定到库中内核线程的结构。对于用户线程，VP 的行为类似于中央处理器。

有以下可能的线程模型，所有模型都用于将用户级线程映射到内核级线程。

1.  **M:1 模型:**在 M:1 模型中，所有用户线程都映射到一个内核线程。该进程一次只能运行一个用户级线程，因为只有一个内核级线程与该进程关联。库调度程序处理映射，库完全处理所有用户线程编程工具。该模型可用于任何系统，尤其是传统的单线程系统。
    T3】
2.  **1:1 模型:**在 1:1 模型中，每个用户线程映射到一个内核线程。每个用户级线程在单独的内核级线程上执行，或者每个用户线程在一个 VP 上运行。大多数用户线程编程工具直接由内核线程处理。此模型是默认模型。
    T3】
3.  **M: N 模型:**在 M: N 模型中，所有用户线程都映射到一个内核线程池；所有用户线程都在虚拟处理器池中运行。该进程被分配 m 个内核级线程来执行 n 个用户级线程。用户线程可以绑定到特定的 VP，如 1:1 模型。所有未绑定的用户线程共享剩余的 VPs。
    ![Why must User Threads be mapped to Kernel Thread](../Images/02d7d784b2d9a6e973dfdcd39c082a16.png)
    这是最高效最复杂的线程模型。用户线程编程工具在线程库和内核线程之间共享。该模型可以通过将 AIXTHREAD_SCOPE 环境变量设置为 **P** 来设置。
4.  **两级:**两级模型类似于 M: N 模型，但也允许某些用户级线程绑定到单个内核级线程。
    T3】

在 M: N 模型和两级模型中，内核必须有某种方式与用户级线程管理器通信，以保持分配给进程的内核线程的适当数量。这种机制被称为 ***调度器激活*** 。

内核为应用程序提供了一组内核线程(虚拟处理器)，然后应用程序可以完全控制在每个内核线程上运行什么线程。内核控制该集中内核线程的数量，以响应系统中不同进程的竞争需求。

内核使用从内核到用户级线程管理器的 ***upcalls*** 向用户级线程管理器通知重要的内核事件。

**例如**，让我们研究一个如何使用调度器激活的例子。

1.  内核已经将**一个内核线程**分配给了一个具有**三个用户级线程**的进程。
2.  三个用户级线程轮流在单个内核级线程上执行。
    ![Why must User Threads be mapped to Kernel Thread](../Images/5dd994636eaa01eb147c6646787f4910.png)
3.  执行线程进行**阻塞系统调用**。
4.  内核阻塞调用用户级线程和用于执行用户级线程的内核级线程。
5.  **调度器激活:**内核决定为进程分配一个**新内核级线程**。
6.  **Upcall:** 内核**通知**用户级**线程管理器**哪个用户级线程现在被阻塞，新的内核级线程可用。
7.  用户级线程管理器将其他线程移动到新的内核线程，并恢复其中一个就绪线程。
    ![Why must User Threads be mapped to Kernel Thread](../Images/718dae500f098b42ae88497eea3a187b.png)
8.  当一个用户级线程被阻塞时，
9.  其他线程可以轮流在新的内核线程上执行。
    ![Why must User Threads be mapped to Kernel Thread](../Images/17579dd3b41ffa3740a28aa9aaf2d298.png)

### 为什么用户线程必须映射到内核线程？

用户线程需要映射到内核线程，因为是内核调度线程在 CPU 上执行，为此，它必须知道它正在调度的线程。

一个进程创建的所有用户线程都在指定给整个进程的同一个内核级线程上执行。每当轮到指定的进程在中央处理器上执行时，它的内核线程就被调度到中央处理器上。进程内的所有其他用户线程必须一个接一个地映射到指定给创建进程的内核线程上，如果它们必须被执行的话。

因为它们都是由创建过程本身控制的，所以用户线程必须一个接一个地映射到指定的内核线程上，并因此被执行。

* * *