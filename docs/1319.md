# 基于存储器和基于寄存器的寻址模式的区别

> 原文：<https://www.javatpoint.com/memory-based-vs-register-based-addressing-modes>

要了解基于存储器的寻址模式和基于寄存器的寻址模式，我们必须先了解寻址模式。之后，我们将能够容易地理解基于存储器的寻址模式和基于寄存器的寻址模式。寻址模式描述如下:

## 寻址模式:

寻址模式可以描述为操作域，可以用来指定我们想要执行的各种操作。在一些数据的帮助下，操作将被执行。在寻址模式下，存储器或计算机寄存器用于存储数据。根据寻址方式指令，决定程序执行时选择操作数的方式。在实际引用操作数之前，指令的地址字段由寻址模式指定的规则修改或解释。

换句话说，寻址模式可以被描述为用于指定操作数的机制。操作数被定义为给定存储单元的引用或指令的一部分。操作数的值或操作数的地址可以定义为包含在指令代码中的信息。根据 CPU 组织的类型，寻址模式非常依赖。CPU 组织基本上有三种类型，描述如下:

*   **单累加器组织:**累加器寄存器在 CPU 组织中隐式使用，处理一个程序的所有指令。这些指令的结果将存储在累加器中。
*   **堆栈组织:**堆栈是一种存储结构，用于存储信息，使得我们最后存储的项目将是第一个检索的项目。在后进先出法的基础上，栈的组织是依赖的。在大多数中央处理器中，后进先出法被认为是最受欢迎的存取方法。
*   **通用寄存器组织:**通用组织可以描述为我们在 CPU 组织中使用多个通用寄存器来代替单个累加器寄存器的组织。在这种组织中，指令格式仅通过两三个地址字段来表示。

寻址模式主要有两个目的。这些目的也被称为寻址模式的优点，描述如下:

*   寻址模式为用户提供了各种类型的设施，为他们提供了编程的多功能性。这些工具是程序重定位、指向内存的指针、数据索引和循环控制计数器。
*   在指令的寻址字段中，可以借助寻址模式减少位数。

例如，机器需要知道如何获取操作数，以便在操作数的帮助下执行任务。有一个词被称为**有效地址**，用于定义存储在内存中的操作数的地址。我们可以借助很多方法，直接从寄存器中获取或定义这些类型操作数的有效地址。这些类型的方法或方法被称为‘T2’寻址模式。

在**高级语言**中，程序员可以很容易地描述变量和将要对变量执行的操作。这就是为什么在高级语言的帮助下，程序员通常编写代码。后来，**低级指令**被用来产生计算机代码。操作码和操作数包含在低级指令中。操作码选项上的寻址模式不能执行任何操作。寻址模式只关注操作码的地址，它存在于指令中。

## 基于存储器的寻址模式

当数据在内存中时，我们只能借助内存寻址模式来访问数据。有效地址始终是内存地址。在操作码中，保存的信息总是结果或操作数值。这里，微处理器能够借助于实现保存在存储器中的指令序列来实现特定的任务。

在**基于寄存器的寻址模式**下，操作数将保存在寄存器中，CPU(中央处理器)包含在该寄存器中。在登记册的帮助下，我们将获得信息，这些信息将在登记册内处理。在这种模式下，指令将包含存储操作数的寄存器地址。基于寄存器的寻址模式包含不同类型的基址。这就是为什么目标段基址将在基址寄存器的帮助下保存。

基于存储器的寻址模式和基于寄存器的寻址模式之间的区别描述如下:

| 基于存储器的寻址模式 | 基于寄存器的寻址模式 |
| 在这种模式下，将访问静态变量。在基于内存的寻址模式下，操作数的值通常由内存包含。在指令本身的帮助下，将给出操作数的地址。基于存储器的寻址模式具有适当利用存储器地址优势的能力。这种模式下需要单个存储器参考。这种模式被称为**直接寻址模式**。 | 在基于寄存器的寻址模式下，操作数的值通常由寄存器包含。在指令的帮助下，提供了寄存器编号。操作数可以在指令中存在的寄存器号的帮助下获取。这种模式被称为**注册模式**。 |
| 在这种模式下，实现指针。在内存的帮助下，有效地址以这种方式存储。借助指令中指定的内存地址，将提供 EA 的地址。这种模式需要两次引用，第一次用于获取有效地址，第二次用于读取或写入数据。这种模式被称为**间接寻址模式**。 | 操作数的地址包含在寄存器中。指令中给出的寄存器内容将被发送到有效地址。借助这种模式，我们能够充分利用寄存器的优势。该模式被称为**注册间接模式**。 |
| 有效地址可以通过添加指令的地址部分和基本寄存器的内容来获得。总有一种假设，即基址寄存器包含基址，相对于基址的位移由指令的地址字段给出。该模式被称为**寻址模式，基址寄存器**。 | 假设我们包含一个包含大量数据的表。如果我们想一个一个地访问所有的值，在这种情况下，我们需要任何包含一个基址或减少程序计数器的寄存器。在这种情况下，寄存器会减少。这就是为什么这种模式是基于寄存器的寻址模式。该模式被称为**自动减量模式**。 |
| 在这种模式下，将实现数组。以顺序单元的形式，阵列元素将被存储在存储器中。在这种模式下，索引可以被称为数组的元素。通过将索引寄存器的内容添加到指令的地址部分，可以获得有效地址。在索引模式的帮助下，我们可以访问一个在连续的内存位置包含其元素的数组。这种模式需要两个参数来访问数组元素，即基址和索引。这里，基址是第一个元素，它能够存储数组的地址。索引是用来表示数组元素位置的第二个元素。该模式被称为**索引寻址模式**。 | 假设我们包含一个包含大量数据的表。如果我们想一个接一个地访问所有的值，在这种情况下，我们需要任何包含基地址或增加程序计数器的寄存器。在这种情况下，寄存器增加。该模式被称为**自动增量模式**。 |
| 通过将程序计数器的内容添加到指令的地址部分，可以获得有效地址。在这种情况下，这个地址部分通常显示一个负数或正数。该模式被称为**相对寻址模式**。 | 基于寄存器的寻址模式用于访问常数。在指令的帮助下，常量值被初始化到寄存器中。借助指令的地址字段，以这种方式保存数据。这就是为什么在这种模式下，有效地址不需要访问数据。我们可以以源的形式使用这种模式，但永远不能以目的地的形式使用，因为常量中没有存储容量，目的地总是需要存储空间的。这种技术在我们的代码或程序中非常有用。该模式被称为**立即寻址模式**。 |

* * *