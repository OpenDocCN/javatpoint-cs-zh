# 二进制数系统算术加法中的溢出

> 原文:[https://www . javatpoint . com/二进制数算术加溢出系统](https://www.javatpoint.com/overflow-in-arithmetic-addition-in-binary-number-system)

为了解释算术加法的溢出，我们将主要使用 2 的补码系统，这是一种在计算机体系结构中广泛使用的数字系统。

*   如果 2 的补数系统有 N 位，它能够表示从-2 <sup>n-1</sup> 到 2<sup>N-1</sup>1 的数字。
*   如果 2 的补码系统有 4 位，它将表示从(-8 到 7)的数字。
*   如果 2 的补码系统有 5 位，它将表示从(-16 到 15)的数字。

当我们试图添加 2 个 N 位 2 的补码数，并且生成的输出太大，以至于它不适合该 N 位组时，在这种情况下，关于添加将发生溢出。系统或计算机中通常有 N 位固定寄存器。当我们将两个 N 位数字相加时，它将产生最大 N+1 位数字的输出。在进位标志的帮助下，这个额外的位被存储。问题是进位并不总是用来表示溢出。

**例如:**在这个例子中，我们将借助 2 的补码来添加 7 和 1。

**解:**二进制数 7(0001)和 7(0111)的加法描述如下:

```

0001 (1) + 0111 (7) = 1000 (-8)

```

如我们所见，借助 4 位加 7 + 1 等于 8。但是我们不能用 4 位 2 的补数来表示 8，因为数字 8 超出了范围。当我们把两个正数相加时，我们就得到一个负数(-8)。在本例中，0 也是进位。通常，与溢出相关的问题留给程序员，他必须处理这些情况。

### 溢出检测

在显示算术运算结果时，如果位数不足以表示二进制数，就会发生溢出。计算机算术在除法、减法、乘法和减法方面是封闭的；因此，会发生溢出。如果操作数的符号不同。相同)，在这种情况下，不会发生溢出。

发生溢出的情况有两种，描述如下:

1.  当我们试图将两个负数相加，生成的结果是一个正数。
2.  当我们试图将两个正数相加，生成的结果是负数。

**例如:**

| 输入 | 输出 |
| **A <sub>标志</sub>T3】** | **B <sub>标志</sub>T3】** | **进位输入** | **执行** | **SUM <sub>号</sub>T3】** | **溢出** |
| Zero | Zero | Zero | Zero | Zero | Zero |
| Zero | Zero | one | Zero | one | one |
| Zero | one | Zero | Zero | one | Zero |
| Zero | one | one | one | Zero | Zero |
| one | Zero | Zero | Zero | one | Zero |
| one | Zero | one | one | Zero | Zero |
| one | one | Zero | one | Zero | one |
| one | one | one | one | one | Zero |

当两个正数相加，生成的结果是正数，当两个负数相加，生成的结果是负数，那么就不会有溢出，描述如下:

| 输入 | 输出 |
| **A <sub>标志</sub>T3】** | **B <sub>标志</sub>T3】** | **进位输入** | **执行** | **SUM <sub>号</sub>T3】** | **溢出** |
| Zero | Zero | Zero | Zero | Zero | Zero |
| Zero | Zero | one | Zero | one | ？ |
| Zero | one | Zero | Zero | one | Zero |
| Zero | one | one | one | Zero | Zero |
| one | Zero | Zero | Zero | one | Zero |
| one | Zero | one | one | Zero | Zero |
| one | one | Zero | one | Zero | ？ |
| one | one | one | one | one | Zero |

如果我们有 n 位数字表示，那么我们将需要 n + 1 位来检测和补偿溢出。例如:假设我们有 32 位算术，我们可以借助 33 位来检测和补偿溢出。此外，我们可以将进位(借用)放入符号位，以实现这一点。为了更深入地解释，我们将借助数字 7 和 6 的四位长二进制表示来提供一个符号的四种不同组合。

![Overflow in Arithmetic Addition in Binary number System](../Images/b720f4c1f08a4ae52f7a4a0c2bbcebec.png)

我们可以使用 2 位比较器来检测溢出，而不是使用 3 位比较器。我们还可以通过检查两个数字的 MSB 及其结果来检测溢出。为此，我们只需要检查最高有效位的进位输入和进位输出位。假设我们将执行 2 的补码数的 N 位加法，描述如下:

![Overflow in Arithmetic Addition in Binary number System](../Images/f87a02659fe2d3e69b14e4f79664d9ae.png)

当 C 入和 C 出相等时，会发生溢出。借助下面的分析，我们可以解释上面的溢出表达式。

![Overflow in Arithmetic Addition in Binary number System](../Images/2e6319a8c7ed85e4231faef9bb73f417.png)

在第一幅图中，0 表示两个数字的 MSB，表示它们是正的。如果我们得到 1 作为进位，MSB 的结果也将是 1，这意味着结果是负的(溢出)。在这种情况下，进位也将为 0。证明了带入和带出不相等，从而溢出。

在第二张图片中，1 显示了两个数字的 MSB，表示它们是负数。如果我们得到 0 作为进位，MSB 的结果也将是 0，这意味着结果是正的(溢出)。在这种情况下，进位也将是 1。证明了进位输入不等于进位输出，从而溢出。

借助上面的解释，我们可以说溢出可以通过 MSB(最高有效位)处的 C-in 和 C-out 来检测，如下所述:

![Overflow in Arithmetic Addition in Binary number System](../Images/2e0ebac65bf8e67d8eb7a80f235b0ce1.png)

借助上面的异或门，我们可以很容易地检测到溢出。

### 溢出条件

溢出有多种情况，描述如下:

*   算术运算有能力进入**溢出**状态。
*   根据将容纳结果的数据类型的大小，溢出是依赖的。
*   如果结果的数据类型太小或太大，以至于无法适合原始数据类型，在这种情况下，将会发生溢出。
*   当我们试图将两个带符号的 2 的补数相加时，如果两个数都是正数并且生成的输出是负数，或者两个数都是负数并且生成的输出是正数，就会出现溢出的情况。
*   当我们试图将两个无符号数相加时，如果最左边的位包含进位，就会出现溢出的情况。

**无符号数相加示例:**

在这个例子中，我们使用一位量，并检测一位量是否包含溢出。

```

0 + 0 = 1
0 + 1 = 1
1+ 0 = 1
1 + 1 = 10

```

在这个例子中，我们可以看到最后一行包含进位输出。这意味着我们无法借助一位数量来容纳(1 + 1)。如果我们想在{1 + 1}中取得成功，我们需要大数据类型。当我们试图添加多位无符号数时，当且仅当左最高有效位包含进位输出时，才会发生溢出。

**添加带符号数字的示例**

在这个例子中，我们使用一位**有符号量**并检测该一位量是否包含溢出。

**解决方法:**这里用一位表示符号，另一位表示数据。因此，我们需要两位带符号的数据类型，描述如下:

| 二进制的 | 小数 |
| **符号位** | **数据位** |  |
| Zero | Zero | Zero |
| Zero | one | one |
| one | one | -1 |
| one | Zero | -2 |

假设我们有两个符号相反的数字。如果我们将这些数字相加，它们的总和永远不会像这样溢出:

```

1 + (-2) = -1
1 + (-1) = 0

```

但是如果我们有两个相同的符号数，它们的和可以这样溢出:

```

1 + 1 = 2
(-2) + (-2) = -4
(-2) + (-1) = -3

```

因此，输出{2，-4，-3}无法适合两位带符号数据类型。

* * *