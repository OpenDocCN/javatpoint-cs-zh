# 示例分页

> 原文:[https://www.javatpoint.com/os-paging-with-example](https://www.javatpoint.com/os-paging-with-example)

在操作系统中，分页是一种存储机制，用于以页面的形式将进程从辅助存储器检索到主存储器中。

分页背后的主要思想是以页面的形式划分每个进程。主存也会以帧的形式划分。

该过程的一页将被存储在存储器的一个帧中。页面可以存储在内存的不同位置，但优先考虑的总是找到连续的帧或孔。

进程的页面只有在需要时才会被放入主存储器，否则它们会驻留在辅助存储器中。

不同的操作系统定义不同的帧大小。每个帧的大小必须相等。考虑到页面映射到分页中的框架这一事实，页面大小需要与框架大小相同。

![OS Paging](../Images/62f436133d7190ec81cdfe57c009bcb3.png)

### 例子

让我们考虑主内存大小为 16 Kb，帧大小为 1 KB，因此主内存将被分成 16 个帧的集合，每个帧为 1 KB。

系统中有 4 个进程，分别是 4 KB 的 P1、P2、P3 和 P4。每个进程被分成 1 KB 的页面，这样一个页面可以存储在一个帧中。

最初，所有的框架都是空的，因此进程的页面将以连续的方式存储。

框架、页面以及两者之间的映射如下图所示。

![OS Paging Example](../Images/29843c1be72358198616e3d7a7574512.png)

让我们考虑一下，P2 和 P4 在一段时间后进入等待状态。现在，8 个框架变成空的，因此可以在那个空的地方加载其他页面。大小为 8 KB (8 页)的进程 P5 正在就绪队列中等待。

鉴于这一事实，我们在内存中有 8 个不连续的帧可用，分页提供了在不同位置存储进程的灵活性。因此，我们可以代替 P2 和 P4 加载进程 P5 的页面。

![OS Paging Example 2](../Images/dfc1f007a54d1e97b359d0368412478b.png)

## 内存管理单元

内存管理单元的目的是将逻辑地址转换为物理地址。逻辑地址是由中央处理器为每一页生成的地址，而物理地址是存储每一页的帧的实际地址。

当中央处理器使用逻辑地址访问一个页面时，操作系统需要获得物理地址来物理访问该页面。

逻辑地址有两部分。

1.  页码
2.  抵消

操作系统的内存管理单元需要将页码转换为帧数。

**例**

考虑到上面的图片，假设 CPU 需要进程 P3 第 4 页的第 10 个字。由于进程 P1 的第 4 页存储在第 9 帧，因此第 9 帧的第 10 个字将作为物理地址返回。