# 兰波特面包店算法

> 原文:[https://www.javatpoint.com/lamports-bakery-algorithm](https://www.javatpoint.com/lamports-bakery-algorithm)

在本文中，我们将详细了解 Lamport 的烘焙算法。

### 你说的兰波特面包店算法是什么意思？

Lamport 针对 n 进程互斥问题提出了一种烘焙算法，一种软件解决方案。该算法遵循最公平、先到先得的原则，解决了一个关键问题。

### 为什么叫面包店算法？

这种算法被称为面包店算法，因为这种类型的调度在面包店中被采用，在面包店中，令牌号被发布以设置顾客的订单。当顾客进入面包店时，他会得到一个唯一的代币号码。全局计数器显示当前服务的客户数量，所有其他客户都必须等待。一旦面包师完成了对当前顾客的服务，就会显示下一个号码。现在正在为拥有下一个令牌的客户提供服务。

同样，在 Lamport 的烘焙算法中，流程被视为客户。在这种情况下，等待进入其关键部分的每个进程都将获得一个令牌号，具有最低号的进程将进入关键部分。如果两个进程具有相同的令牌号，具有较低进程标识的进程将进入其关键部分。

### 兰波特面包店算法的算法

```

do
{
    entering[i] :=  true; // show interest in critical section
   // get a token number
    number[i] := 1 + max(number[0],  number[1], ..., number[n - 1]);   
    entering [i] :=  false;
    for ( j :=  0 ;  j
```

兰伯特烘焙算法求解临界区问题的过程 Pi 结构。

**解释-**

**该算法使用以下两个布尔变量。**

```

boolean entering[n];
int number[n];

```

所有输入的变量都初始化为 false，n 个整数变量数都初始化为 0。整型变量的值用于形成令牌号。

当一个进程希望进入一个关键部分时，它会选择一个比以前的数字更大的令牌号。

考虑 Pi 希望进入关键部分的过程，它设置

**输入[i]** 为真，让其他进程知道它正在选择一个令牌号。然后，它选择一个大于其他进程持有的令牌号，并写入其令牌号。然后读取后将**进入【我】**设置为假。然后它进入一个循环来评估其他进程的状态。它一直等到其他进程 Pj 选择它的令牌号。

Pi 然后等待，直到具有较小令牌号或相同令牌号但具有较高优先级的所有进程都得到快速服务。

当进程完成其关键部分的执行时，它将其数字变量重置为 0。

**Bakery 算法满足临界截面问题的所有要求。**

*   **互斥:**我们知道，当其临界区没有进程在执行时，允许数量最少的进程进入其临界区。假设两个进程具有相同的令牌号。在这种情况下，选择其中具有较低进程标识的进程，因为每个进程的进程标识是不同的，所以在特定时间，只有一个进程在其关键部分执行。这样就满足了互斥的要求。
*   **进度:**选择令牌后，等待进程会检查是否有任何其他等待进程具有更高的优先级来进入其关键部分。如果没有这样的过程，P 会立即进入它的临界区。从而满足进度要求。
*   **有界等待:**作为等待，当没有其他进程处于其临界区时，该进程将进入其临界区
    *   如果它的令牌号是其他等待进程中最小的。
    *   如果令牌号相同，它在其他等待进程中具有最低的进程标识。

### 兰波特烘焙算法的优势

*   兰波特的烘焙算法没有饥饿。
*   兰波特的烘焙算法遵循先进先出。
*   兰伯特的面包店算法与原子寄存器一起工作。
*   对于 N 过程的一般情况，Lamport 的 Bakery 算法是互斥问题最简单的已知解决方案之一。
*   该算法确保了多线程环境中共享资源的高效使用。

### 兰波特烘焙算法的缺点

*   Lamport 的烘焙算法是不可靠的，因为任何一个过程的失败都会停止进展。它具有很高的消息复杂性，每个进入/退出临界区有 3(N - 1)条消息。

* * *