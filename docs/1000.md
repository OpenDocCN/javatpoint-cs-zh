# ISR 和功能调用之间的区别

> 原文:[https://www.javatpoint.com/isr-vs-function-call](https://www.javatpoint.com/isr-vs-function-call)

在本文中，您将了解 **ISR** 和**函数调用**之间的区别，但是在讨论这些区别之前，您必须简要了解 ISR 和函数调用。

### 什么是 ISR？

中断服务例程(ISR)是硬件响应中断而调用的软件例程。ISR 检查中断，确定如何处理它，执行它，并返回一个逻辑中断值。如果不需要进一步处理，ISR 会用返回值通知内核。ISR 必须非常快速地执行，以避免降低设备的运行速度和所有低优先级 ISR 的运行速度。

尽管中断服务程序可能会将数据从中央处理器寄存器或硬件端口移动到内存缓冲区，但通常情况下，它依赖一个称为中断服务线程(IST)的专用中断线程(或任务)来完成大多数所需的处理。如果需要额外的处理，ISR 会向内核返回一个逻辑中断值。然后，它将物理中断号映射到逻辑中断值。

### 中断处理机制

**以下是以下步骤中中断处理的机制，如:**

*   中断是一种使中央处理器暂停当前程序并执行中断服务的情况。中断服务程序是一种专门编写的程序，用于处理导致中断的情况。
*   中断服务后，中央处理器返回主程序，正好在它离开的下一条指令处。
*   在中断驱动的数据传输中，每当输入/输出设备准备好进行数据传输时，它都会中断中央处理器。在 ISR 中，中央处理器将执行数据传输。
*   这种方法比轮询更好，因为中央处理器不必浪费时间检查输入/输出设备的状态。键盘是中断驱动输入/输出访问的一个很好的例子。
*   键盘应该在按键时中断中央处理器，而不是检查中央处理器。因此，当用户根本不打字时，重复检查键盘不会浪费时间。
*   输入输出设备通过向中央处理器发送 **$\overline{INTR}$** 信号来请求中断。
*   每当 CPU 收到 **$\overline{INTR}$** 信号时，就完成当前指令的执行，然后执行 ISR。当中央处理器准备好时，它通过 **INTA** 线路发送确认信号。
*   ISR 被执行，CPU 返回主程序。
*   执行后，输入/输出设备关闭**$ \跨线{INTR}$** 信号。

![Difference between ISR and Function Call](../Images/6dc49dd31f57d2597aa07b3124edab84.png)

**例如:**在下面的例子中，通过中断驱动的 I/O 进行 I/O 传输。

*   如果一个输入输出设备想要与处理器进行数据传输，必须中断处理器。
*   中断是使处理器执行中断服务例程的条件。
*   在 ISR 中，处理器将与输入/输出设备进行数据传输。

在本例中，中断请求通过按键盘键、

*   键盘不会检查处理器是否按下了某个键，而是在按下某个键时中断处理器。
*   在键盘的 ISR(键盘驱动软件的一部分)中，处理器将从键盘读取数据。

![Difference between ISR and Function Call](../Images/6b8e0fb339d86ef7b9b95f7c26db32c5.png)

### ISR 的优势

以下是 ISR 的以下优势，例如:

*   ISR 异步事件可以在程序执行期间的任何时间发生。
*   中断服务程序将个人计算机、标志和寄存器保存在堆栈上，禁用所有中断，并加载中断服务程序的地址。
*   ISR 不能有可以传递给它的参数。
*   ISR 不能返回值。
*   ISR 启用中断。
*   一般来说，ISR 很小，因为它需要一些其他流程的时间。
*   一些 ISR 有自己的堆栈。

### 什么是函数调用？

函数调用也称为子程序调用。子程序是程序重复需要的一组指令。它是负责执行特定任务的更大计划的一部分。较大的程序可能执行繁重的工作负载，而子例程可能只执行简单的任务，这也与剩余的程序编码无关。

一个函数以这样一种方式被编码，即它可以被多次调用和从不同的地方调用(甚至从其他函数中调用)。当一个函数被调用时，处理器可以转到该函数的代码所在的位置，并逐一执行该函数的指令。完成这些功能后，处理器将返回到它停止的地方，并从下一条指令开始继续执行。

函数是代码重用的好工具。许多现代编程语言支持函数。一组函数被称为一个 ***库*** 。图书馆经常被用作共享和交易软件的手段。在某些情况下，整个程序可能是一系列子程序。

在 8086 处理器的情况下，子程序由 **CALL** 指令调用，控制由 **RET** 指令返回。它减少了程序的大小。

### ISR 和功能调用之间的区别

函数必须被显式调用，并且与其调用方属于同一个上下文和执行线程。硬件 ISR 不是显式调用的，而是由一些外部事件调用的。在将上下文切换到 ISR 之前调用中断时，当前线程的上下文会自动保留。

作为回报，反向上下文切换发生，恢复中断前处理器的状态，以便从中断点继续执行。以下是 ISR 和功能调用之间的一些更多区别。

| 国际放射学会(International Society for Radiology) | 函数调用 |
| 中断通常由内部或外部信号微处理器启动，而不是执行指令。ISR 在堆栈中存储程序的当前状态后执行。
ISR 根据中断的设备或程序员编写的指令执行不同的任务。 | 函数调用是通过执行指令来调用的，这些指令执行特定的任务并减小程序的大小。 |
| 硬件决定了 ISR 的地址。
ISR 地址写入中断向量表内部，每个中断的 ISR 地址是固定的。 | 子程序的地址写在指令里面，指令写在主程序代码里面。 |
| ISR 用于所有通用任务。 | 针对程序特定的任务进行函数调用。 |
| 因此，当当前程序执行期间发生中断时，在当前指令执行之后，处理器执行中断服务。ISR 执行后，处理器必须完全像中断发生前一样恢复程序。
为此，存储 PC 内容、P 寄存器和一些状态条件。微处理器中所有状态位条件的集合称为程序状态字。

*   During the interrupt period, the contents of PC and PSW are pushed onto the stack. The branch address of the specific interrupt is then passed to the PC, and a new PSW is loaded into the status register.
*   The last instruction in ISR is the return of the interrupt instruction. When this instruction is executed, the old PSW and return address will pop up from the stack.

 | 这里，堆栈上只存储一台 PC，以获取主程序中下一条指令的地址。
子程序必须能够访问调用子程序的数据，并将结果返回给该子程序。因此，子程序参数和数据链接完成。
这可以通过

*   Implementation, AC register can be used for single input parameter and single output parameter. In a computer with multiple processor registers, more parameters can be transferred in this way.
*   Another way to transfer data to subroutines is through memory.

 |

* * *