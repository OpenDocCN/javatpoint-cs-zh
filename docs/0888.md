# 生产者-消费者问题

> 原文:[https://www.javatpoint.com/producer-consumer-problem-in-os](https://www.javatpoint.com/producer-consumer-problem-in-os)

生产者-消费者问题是一个经典的多进程同步问题，即我们试图在多个进程之间实现同步。

生产者-消费者问题中有一个生产者，生产者生产一些产品，而消费者消费生产者生产的产品。生产者和消费者共享相同的固定大小的内存缓冲区。

生产者的任务是生产项目，将其放入内存缓冲区，然后再次开始生产项目。而消费者的任务是从内存缓冲区中消费项目。

## 我们来了解一下是什么问题？

以下几点被认为是生产者-消费者关系中出现的问题:

*   只有当缓冲区未满时，生成器才应该生成数据。如果发现缓冲区已满，则不允许生产者将任何数据存储到内存缓冲区中。
*   只有当且仅当内存缓冲区不为空时，数据才能被使用者使用。如果发现缓冲区为空，则不允许使用者使用内存缓冲区中的任何数据。
*   不应允许生产者和消费者同时访问内存缓冲区。

让我们看看上面问题的代码:

## 生产者代码

![Producer-Consumer problem](../Images/85360053be6e1336d6818087569dccb8.png)

## 生产者代码

![Producer-Consumer problem](../Images/19d849bd14612920cf1e992077b61dee.png)

### 让我们理解上面的生产者和消费者代码:

在开始解释代码之前，首先，理解上面代码中使用的几个术语:

1.  “”中的“**用于表示下一个**空缓冲区****
2.  消费者代码中使用的“ **out** 表示第一个**填充的缓冲区**
3.  count 保存缓冲区中元素的计数
4.  count 进一步分为 3 行代码，在生产者代码和消费者代码的块中表示。

如果我们先讨论生产者代码:

- Rp 是一个保存 m[计数]值的寄存器

- Rp 增加(因为元素已添加到缓冲区)

-Rp 的递增值存储回 m[计数]

同样，如果我们接下来讨论消费者代码:

- Rc 是一个保存 m[计数]值的寄存器

- Rc 递减(因为元素已从缓冲区中移除)

-递减的 Rc 值存储回 m[count]。

**缓冲区**

![Producer-Consumer problem](../Images/86651917d75ef6a2e7cbbcc7b046b478.png)
![Producer-Consumer problem](../Images/b749e98cf15d2ae84c385ae749d86923.png)

从图中我们可以看到:缓冲区总共有 8 个空格，其中前 5 个被填充，in = 5(指向下一个空位置)和 out = 0(指向第一个填充位置)。

先说**想要产生元素“F”的生产者**，根据代码它会进入生产者()函数，而(1)会一直为真，itemP = F 会尝试插入缓冲区，在此之前的 while(count = = n)；将被评估为假。

#### 注意:如果结果为真(即无限循环/缓冲区已满)，while 循环后的分号不会让代码继续执行

缓冲区[in] = itemP →缓冲区[5] = F(现在插入 F)

in = (in + 1) mod n → (5 + 1)mod 8→ 6，因此 in = 6；(下一个空缓冲区)

插入 F 后，Buffer 看起来是这样的

其中**出= 0** ，但**入= 6**

![Producer-Consumer problem](../Images/899a4e6b74c2e759579c972ca5f5efbd.png)

**自计数=计数+1；分为三个部分:**

加载 Rp，m[计数] →将把计数值 5 复制到寄存器 Rp。

增加 Rp →将增加 Rp 至 6。

假设在增量之后和第三行执行之前(存储 m[计数]，Rp) **上下文切换**发生，代码跳转到**消费者代码**。。。

**消费者代码:**

现在从想要消费第一个元素“A”的**消费者**开始，根据代码它会进入 consumer()函数，而(1)永远为真，而(count = = 0)；将计算为 False(因为计数仍然是 5，不等于 0。

#### 注意:如果结果为真(即无限循环/缓冲区中没有元素)，while 循环后的分号不会让代码继续执行

项目 C =缓冲区[输出]→项目 C = A(因为输出为 0)

out = (out + 1) mod n → (0 + 1)mod 8→ 1，因此 out = 1(第一个填充位置)

现在已移除

去掉 A 后，缓冲区看起来是这样的

其中**输出= 1** ，而**输入= 6**

![Producer-Consumer problem](../Images/abd10024a90332ce95c160353fb4b03f.png)

因为 count = count-1；分为三个部分:

加载 Rc，m[计数] →将计数值 5 复制到寄存器 Rp。

减少 Rc →将减少 Rc 至 4。

存储 m[计数]，Rc →计数= 4。

**现在计数的当前值是 4**

假设在此之后**上下文切换**回到生产者代码的剩余部分。。。

因为生产者代码的上下文切换发生在增量之后和第三行执行之前(存储 m[计数]，Rp)

所以我们从这里继续，因为 Rp 保持 6 为递增值

因此存储 m[计数]，Rp →计数= 6

**现在 count 的当前值是 6，这是错误的，因为 Buffer 只有 5 个元素，这个条件被称为竞态条件，问题是生产者-消费者问题。**

### 利用信号量解决生产者-消费者问题

由于上下文切换而产生的生产者和消费者的上述问题以及产生不一致的结果可以借助信号量来解决。

为了解决以上比赛状态出现的问题，我们将使用**二进制信号量和计数信号量**

**二进制信号量:**在二进制信号量中，在任意时间点，只有两个进程可以竞争进入其 ***CRITICAL SECTION*** ，除此之外互斥的条件也得以保留。

**计数信号量:**在计数信号量时，两个以上的进程可以在任何时间点竞争进入其 ***临界区*** 除此之外，互斥的条件也被保留。

**信号量:**信号量是 S 中的一个整数变量，除了初始化之外，它只被两个标准的原子操作访问- wait 和 signal，它们的定义如下:

```

1\. wait( S )
{
while( S <= 0) ;
S--;
}

```

```

2\. signal( S )
{
S++;
}

```

从以上对等待的定义可以清楚地看出，如果 S 的值< = 0，那么它将进入一个无限循环(因为分号；while 循环之后)。而信号的作用是增加 s 的值

让我们将代码视为使用信号量(二进制和计数信号量)解决生产者和消费者问题的方案:

### 生产者代码-解决方案

```

void producer( void )
{
  wait ( empty );
  wait(S);
  Produce_item(item P)
  buffer[ in ] = item P;
  in = (in + 1)mod n
  signal(S);
  signal(full);

}

```

### 消费者代码-解决方案

```

void consumer(void)
{
  wait ( empty );
  wait(S);
  itemC = buffer[ out ];
  out = ( out + 1 ) mod n;
  signal(S);
  signal(empty);
}

```

### 让我们理解生产者和消费者代码的上述解决方案:

在开始解释代码之前，首先，理解上面代码中使用的几个术语:

1.  “”中的“**用于表示下一个**空缓冲区****
2.  消费者代码中使用的“ **out** 表示第一个**填充的缓冲区**
3.  “**空**”是计数信号量，记下空缓冲区的数量
4.  “**满**”正在计算信号量，该信号量记录了满缓冲区的数量
5.  “ **S** 是一个二进制信号量 **BUFFER**

**如果看到 Buffer 的现状**

![Producer-Consumer problem](../Images/10e2cc921fb6efb625feaab6e2fabf6d.png)

S = 1(初始化。二元信号量的值

in = 5(下一个空缓冲区)

out = 0(第一个填充的缓冲区)

![Producer-Consumer problem](../Images/7cbd9f735ef320a6eaeae2b9fc2993be.png)

从图中我们可以看到:缓冲区总共有 8 个空格，其中前 5 个被填充，in = 5(指向下一个空位置)和 out = 0(指向第一个填充位置)。

**生产者代码中使用的信号量:**

**6。wait(empty)** 会将计数信号量变量**的值减 1，也就是说，当生产者产生某个元素时，缓冲区中的空间值会自动减 1。如果缓冲区已满，即计数信号量变量“空”的值为 0，则等待(空)；将捕获该进程(根据等待的定义),并且不允许进一步操作。**

**7。等待(S)** 将二进制信号量变量 S 减少到 0，这样就不允许任何其他进程进入它的临界区。

**8。信号**将二进制信号量变量 S 增加到 1，以便现在可以允许愿意进入其关键部分的其他进程。

**9。signal(full)** 将计数信号量变量 full 增加 1，因为在将项目添加到缓冲区时，缓冲区中有一个空间被占用，必须更新变量 full。

**生产者代码中使用的信号量:**

**10.0wait(full)** 会将计数信号量变量 full 的值减少 1，也就是说，当使用者消耗某个元素时，缓冲区中的已满空间的值会自动减少 1。如果缓冲区为空，即计数信号量变量 full 的值为 0，则等待(full)；将捕获该进程(根据等待的定义),并且不允许进一步操作。

**11 时。等待(S)** 将二进制信号量变量 S 减少到 0，这样就不允许任何其他进程进入它的临界区。

**12 时。信号(S)** 将二进制信号量变量 S 增加到 1，以便现在可以允许愿意进入其关键部分的其他进程。

**13。信号(空)**将计数信号量变量 empty 增加 1，因为从缓冲区中移除一个项目时，缓冲区中有一个空间是空的，必须相应地更新变量 empty。

**生产者代码:**

让我们从想要产生元素“F”的生产者()开始，根据代码，它将进入生产者()函数。

等待(空的)；将空值减少 1，即空= 2

假设就在这个上下文切换发生之后，跳转到消费者代码。

消费者代码:

现在开始想消费第一个元素“A”的消费者，根据代码它将进入 consumer()函数，

等待(满)；会将 full 的值减少 1，即 full = 4

等待(S)；将 S 的值减少到 0

itemC =缓冲区[out]；→项目 C = A(因为输出为 0)

现在已移除

out = (out + 1) mod n → (0 + 1)mod 8 → 1，因此 out = 1(第一个填充位置)

![Producer-Consumer problem](../Images/963a1efb77fd5f12dc498a79706490bb.png)

S = 0(二进制信号量的值)

in = 5(下一个空缓冲区)

out = 1(第一个填充的缓冲区)

假设就在这个上下文之后，切换回到生产者代码

因为生产者()的下一个指令是等待(S)；，这将捕获生产者进程，因为 S 的当前值为 0，并等待(0)；是一个无限循环:根据等待的定义，生产者不能再进一步。

因此，我们回到消费者进程的下一个指令。

信号(S)；现在将 S 的值增加到 1。

信号(空)；将空增加 1，即空= 3

![Producer-Consumer problem](../Images/41a61f57fafc66828dee46b0df4f7e84.png)

现在回到生产者()代码；

因为生产者()的下一个指令是等待(S)；将成功执行，因为 S 现在是 1，它将 S 的值减少 1，即 S = 0

缓冲区[in]= ItemP；→缓冲器[5] = F(现在插入 F)

in = (in + 1) mod n → (5 + 1)mod 8 → 6，因此 in = 6；(下一个空缓冲区)

信号(S)；将 S 增加 1，

信号(满)；将递增 1，即 full = 5

![Producer-Consumer problem](../Images/ead9dc4855a3cb50b08404e2ff95bcf7.png)

现在加上当前值 full 和 empty，即 full + empty = 5 + 3 = 8(这绝对没问题)即使经过这么多次上下文切换也不会产生不一致的结果。但是在前面生产者和消费者没有信号量的情况下，我们看到了上下文切换时不一致的结果。

这是生产者消费者问题的解决方案。

* * *