# 贪婪算法

> 原文:[https://www.javatpoint.com/greedy-algorithms](https://www.javatpoint.com/greedy-algorithms)

贪婪方法是解决问题的策略之一。这种方法用于解决优化问题。优化问题是要求最大或最小结果的问题。让我们通过一些术语来理解。

贪婪方法是最简单直接的方法。它不是一种算法，而是一种技术。这种方法的主要功能是根据当前可用的信息做出决定。无论当前的信息是什么，做出决定时都不用担心当前决定在未来的影响。

这种技术基本上用于确定可能是或可能不是最优的可行解。可行解是满足给定标准的子集。最优解是子集内最好的、最有利的解。在可行的情况下，如果一个以上的解满足给定的标准，那么这些解将被认为是可行的，而最优解是所有解中的最优解。

### 贪婪方法的特点

**以下是贪婪方法的特征:**

*   为了以最佳方式构造解，该算法创建两个集合，其中一个集合包含所有选择的项目，另一个集合包含被拒绝的项目。
*   贪婪算法做出好的局部选择，希望解决方案是可行的或最优的。

### 贪婪算法的组成部分

**贪婪算法可以使用的组件有:**

*   **候选集:**从该集创建的解决方案被称为候选集。
*   **选择功能:**该功能用于选择可加入到解中的候选或子集。
*   **可行性函数:**用于确定候选或子集是否可用于为解决方案做出贡献的函数。
*   **目标函数:**一个函数用于给解或部分解赋值。
*   **求解功能:**该功能用于提示是否达到了完整的功能。

### 贪婪算法的应用

*   它用于寻找最短路径。
*   它用于使用 prim 算法或 Kruskal 算法寻找最小生成树。
*   它用于有截止日期的作业排序。
*   该算法也被用于求解分数背包问题。

### 贪婪算法的伪代码

```

Algorithm Greedy (a, n)
{
   Solution : = 0;
  for i = 0 to n do
  {
      x: = select(a);
     if feasible(solution, x)
    {
        Solution: = union(solution , x)
    }
       return solution;
  } }

```

以上就是贪心算法。最初，解决方案被赋予零值。我们在贪婪算法中传递数组和元素数量。在 for 循环中，我们逐个选择元素，并检查解决方案是否可行。如果解决方案可行，那么我们执行联合。

**我们通过一个例子来了解一下。**

假设有一个问题‘P’。我想从 A 地旅行到 B 地，如下图所示:

**P : A → B**

问题是我们这次从 A 到 B 的旅程要旅行，从 A 到 B 有各种各样的解决方案，我们可以通过**步行、汽车、自行车、火车、飞机**等方式从 A 到 B。旅途中有一个限制，我们必须在 12 小时内完成这段旅程。如果我只乘火车或飞机去，我可以在 12 小时内走完这段距离。这个问题有许多解决方案，但只有两个解决方案满足约束。

如果我们说我们必须以最低的费用支付旅程。这意味着我们必须尽可能最小地行进这个距离，所以这个问题被称为最小化问题。到目前为止，我们有两种可行的解决方案，一种是坐火车，另一种是坐飞机。因为坐火车旅行的成本最低，所以这是一个最佳的解决方案。最优解也是可行解，但要提供最好的结果，使解是成本最小的最优解。只有一个最优解。

需要最小或最大结果的问题称为优化问题。贪婪方法是解决优化问题的策略之一。

### 使用贪婪算法的缺点

贪婪算法根据每个阶段的可用信息做出决策，而不考虑更广泛的问题。因此，贪婪的解决方案可能不会给出每个问题的最佳解决方案。

它遵循每个阶段的局部最优选择，目的是找到全局最优。让我们通过一个例子来理解。

**考虑下面给出的图表:**

![Greedy Algorithm](../Images/fd9df86413b3ca9a8e219422a83eee58.png)

我们必须以最低的成本从源头旅行到目的地。因为我们有三个可行的解决方案，成本路径分别为 10、20 和 5。5 是最小成本路径，因此它是最优解。这是局部最优，这样，我们在每个阶段找到局部最优，以便计算全局最优解。

* * *