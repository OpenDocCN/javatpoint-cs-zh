# 设计问题

> 原文：<https://www.javatpoint.com/design-issues>

在代码生成阶段，可能会出现各种问题:

1.  代码生成器的输入
2.  目标程序
3.  内存管理
4.  指令选择
5.  寄存器分配
6.  评估顺序

## 1.代码生成器的输入

*   代码生成器的输入包含源程序的中间表示和符号表的信息。源程序由前端产生。
*   中间表示有以下几种选择:
    a)后缀符号
    b)语法树
    c)三个地址码
*   我们假设前端产生低级中间表示，即其中的名称值可以由机器指令直接操作。
*   代码生成阶段需要完整的无错误中间代码作为输入。

## 2.目标程序:

目标程序是代码生成器的输出。输出可以是:

a) **汇编语言:**允许子程序单独编译。

b) **可重定位机器语言:**它让代码生成的过程变得更加容易。

c) **绝对机器语言:**可以放在内存中的固定位置，可以立即执行。

## 3.内存管理

*   在代码生成过程中，符号表条目必须映射到实际的 p 地址，级别必须映射到指令地址。
*   将源程序中的名称映射到数据地址是由前端和代码生成器共同完成的。
*   局部变量是激活记录中的堆栈分配，而全局变量在静态区域。

## 4.指令选择:

*   目标机器指令集的性质应该是完整和统一的。
*   当你考虑目标机器的效率时，指令速度和机器习惯用法是重要的因素。
*   生成代码的质量可以由其速度和大小决定。

### 示例:

三个地址码是:

```

       a:= b + c
       d:= a + e

```

低效的汇编代码是:

```

MOV b, R0              R0→b                            
ADD c, R0	R0      c + R0
MOV R0, a               a   →   R0
MOV a, R0      R0→  a
ADD e, R0               R0  →       e + R0
MOV R0, d               d    →  R0

```

## 5.寄存器分配

寄存器的存取速度比内存快。涉及寄存器操作数的指令比涉及存储器操作数的指令更短更快。

当我们使用寄存器时，会出现以下子问题:

**寄存器分配:**在寄存器分配中，我们选择将驻留在寄存器中的变量集。

**寄存器分配:**在寄存器分配中，我们选择包含变量的寄存器。

某些机器对于某些操作数和结果需要偶数-奇数对寄存器。

### 例如:

考虑以下表格中的划分说明:

```

D x, y

```

哪里，

**x** 是偶/奇寄存器对中的被除数偶寄存器

**y** 是除数

**偶数寄存器**用于保存提醒。

**旧寄存器**用于保存商。

## 6.评估顺序

目标代码的效率会受到执行计算的顺序的影响。一些计算顺序需要比其他顺序更少的寄存器来保存中间结果。