# 计算机组织中管道的依赖性和数据风险

> 原文：<https://www.javatpoint.com/dependencies-and-data-hazard-in-pipeline-in-computer-organization>

在本节中，我们将了解流水线处理器中的依赖性，描述如下:

## 流水线处理器中的依赖关系

流水线处理器通常有三种类型的依赖关系，描述如下:

1.  结构依赖
2.  数据相关性
3.  控制依赖关系

由于这些依赖性，暂停将在管道中引入。停滞可以描述为管道中没有新输入的循环。换句话说，我们可以说，当后一条指令依赖于前一条指令的输出时，就会发生停顿。

### 结构依赖

由于管道中的资源冲突，通常会出现结构依赖。资源冲突可以描述为存在包含诸如算术逻辑单元、存储器或寄存器等资源的循环的情况。在资源冲突中，多个指令试图访问同一资源。

**示例:**

| 指令/周期 | one | Two | three | four | five |
| **I<sub>1</sub>T3】** | 中频(Mem) | 身份 | 激励器 | 查看内存状况 |  |
| **I<sub>2</sub>T3】** |  | 中频(Mem) | 身份 | 激励器 |  |
| **I<sub>3</sub>T3】** |  |  | 中频(Mem) | 身份 | 激励器 |
| **I<sub>4</sub>T3】** |  |  |  | 中频(Mem) | 身份 |

上表包含四个指令 I <sub>1</sub> ，I <sub>2</sub> ，I <sub>3</sub> ，I <sub>4</sub> ，五个循环 1、2、3、4、5。在周期 4 中，因为我 <sub>1</sub> 和我 <sub>4</sub> 试图访问相同的资源，所以出现了资源冲突。在我们的例子中，资源是内存。这个问题的解决方案是，只要所需的资源可用，我们就必须保持指令处于等待状态。由于这种等待，将在管道中引入这样的停顿:

| 指令/周期 | one | Two | three | four | five | six | seven | eight |
| **I<sub>1</sub>T3】** | 中频(Mem) | 身份 | 激励器 | 查看内存状况 | 世界银行 |  |  |  |
| **I<sub>2</sub>T3】** |  | 中频(Mem) | 身份 | 激励器 | 查看内存状况 | 世界银行 |  |  |
| **I<sub>3</sub>T3】** |  |  | 中频(Mem) | 身份 | 激励器 | 查看内存状况 | 世界银行 |  |
| **I<sub>4</sub>T3】** |  |  |  | - | - | - | 中频(Mem) |  |

**结构相关性的解决方案**

借助硬件机制，我们可以最小化流水线中的结构依赖停顿。该机制被称为**重命名。**

**剩余:**在这个机制中，内存将被分为两个独立的模块，分别称为数据内存(DM)和代码内存(CM)。这里，所有的指令都是在 CM 的帮助下包含的，指令所需的所有操作数都是由 DM 包含的。

| 指令/周期 | one | Two | three | four | five | six | seven |
| **I<sub>1</sub>T3】** | 中频(厘米) | 身份 | 激励器 | 分米 | 世界银行 |  |  |
| **I<sub>2</sub>T3】** |  | 中频(厘米) | 身份 | 激励器 | 分米 | 世界银行 |  |
| **I<sub>3</sub>T3】** |  |  | 中频(厘米) | 身份 | 激励器 | 分米 | 世界银行 |
| **I<sub>4</sub>T3】** |  |  |  | 中频(厘米) | 身份 | 激励器 | 分米 |
| **I<sub>5</sub>T3】** |  |  |  |  | 中频(厘米) | 身份 | 激励器 |
| **I<sub>6</sub>T3】** |  |  |  |  |  | 中频(厘米) | 身份 |
| **I<sub>7</sub>T3】** |  |  |  |  |  |  | 中频(厘米) |

### 控制依赖性(分支危险)

当我们传递控制指令的时候，控制依赖就会在那个时候出现。这些指令可以是 JMP 指令、CALL 指令、BRANCH 指令等等。在许多指令体系结构上，当处理器想要将新指令添加到流水线中时，处理器不知道这些新指令的目标地址。由于这个缺点，不需要的指令被插入到管道中。

**例如:**

为此，我们将假设一个程序，并采取如下指令序列:

```
100: I1
101: I2
102: I3
.
.
250: BI1

```

预期产出描述如下:

```
I1 → I2 → BI1  

```

#### 注意:在 ID 阶段之后，处理器能够知道 JMP 指令的目标地址。

| 指令/周期 | one | Two | three | four | five | six |
| **I<sub>1</sub>T3】** | 如果 | 身份 | 激励器 | 查看内存状况 | 世界银行 |  |
| **I<sub>2</sub>T3】** |  | 如果 | ID（邮编：250） | 激励器 | 查看内存状况 | 世界银行 |
| **I<sub>3</sub>T3】** |  |  | 如果 | 身份 | 激励器 | 查看内存状况 |
| **BI<sub>1</sub>T3】** |  |  |  | 如果 | 身份 | 激励器 |

输出顺序描述如下:

```
I1 → I2 → I3 → BI1 

```

所以上面的例子说明了期望输出和输出顺序是不相等的。这表明管道没有正确实现。

只要我们得到分支指令的目标地址，我们就可以通过停止取指令来纠正这个问题。为此，我们将实现延迟槽，只要我们得到目标地址，如下表所述:

| 指令/周期 | one | Two | three | four | five | six |
| **I<sub>1</sub>T3】** | 如果 | 身份 | 激励器 | 查看内存状况 | 世界银行 |  |
| **I<sub>2</sub>T3】** |  | 如果 | ID（邮编：250） | 激励器 | 查看内存状况 | 世界银行 |
| **延迟** | - | - | - | - | - | - |
| **BI<sub>1</sub>T3】** |  |  |  | 如果 | 身份 | 激励器 |

输出顺序描述如下:

```
I1 → I2 → Delay (Stall) → BI1

```

在上面的例子中，我们可以看到延迟槽没有执行任何操作。这就是为什么这个输出序列和预期输出不相等。但是因为这个槽，管道中会引入一个失速。

**控制依赖的解决方案**

在控制依赖关系中，我们可以借助于称为**分支预测的方法来消除管道中的停滞。**在分支预测的第 1 <sup>阶段</sup>进行关于将采取哪个分支的预测。分支预测包含 0 **分支惩罚。**

**分支罚分:**分支罚分可以描述为流水线中分支操作时引入的停顿数。

### 数据依赖性(数据危害)

为此，我们将假设一个加法指令和三个寄存器，描述如下:

```

S: ADD R1, R2, R3
Addresses read by S = I(S) = {R2, R3}
Addresses written by S = O(S) = {R1} 

```

按照下面的方式，S2 的指令将依赖于 S1 的指令:

```

[I(S1) ? O(S2)] ? [O(S1) ? I(S2)] ? [O(S1) ? O(S2)] ? ?  

```

上述条件被称为**伯恩斯坦条件。**在这种情况下，有三种情况，描述如下:

**流(数据)依赖:**假设这个依赖包含 O(S1)？我(S2)，S1 → S2。在这种情况下，当 S2 读了一些东西，只有在那之后，S1 写。

**反依赖:**假设这个依赖包含 I(S1)？O(S2)，S1 → S2。在这种情况下，在 S2 覆盖 S1 之前，S1 会读一些东西。

**输出依赖:**假设这个依赖包含 O(S1)？O(S2)，S1 → S2。在这种情况下，S1 和 S2 都写在同一个内存位置。

**例如:**这里我们假设我们有两个指令我 <sub>1</sub> ，我 <sub>2</sub> ，如下:

```
I1: ADD R1, R2, R3
I2: SUB R4, R1, R2

```

当上述指令 I <sub>1</sub> ，I <sub>2</sub> 在流水线处理器中执行时，会出现数据依赖的情况。说明在我 <sub>1</sub> 写数据之前，我 <sub>2</sub> 试着去读。因此，指令 I <sub>2</sub> 错误地从 I <sub>1</sub> 获取旧值，如下表所述:

| 指令/周期 | one | Two | three | four |
| **I<sub>1</sub>T3】** | 如果 | 身份 | 激励器 | 分米 |
| **I<sub>2</sub>T3】** |  | 如果 | 标识(旧值) | 激励器 |

这里我们将使用**操作数转发**，这样我们可以最小化数据依赖中的停顿。

**操作数转发:**在这个转发中，我们将使用存在于级间的接口寄存器。这些寄存器用于包含中间输出。在中间寄存器的帮助下，相关指令能够直接访问新值。

为了解释这一点，我们将举同一个例子:

```
I1: ADD R1, R2, R3
I2: SUB R4, R1, R2

```

| 指令/周期 | one | Two | three | four |
| **I<sub>1</sub>T3】** | 如果 | 身份 | 激励器 | 分米 |
| **I<sub>2</sub>T3】** |  | 如果 | 身份 | 激励器 |

## 数据危害

由于数据依赖性，数据危险已经发生。如果在流水线的不同阶段借助于表现出数据依赖性的指令来修改数据，在这种情况下，将会发生数据危险。当指令读/写被其他指令使用的寄存器时，在这种情况下，指令危险将发生。由于数据风险，管道中会有延迟。数据危害基本上有三种类型:

1.  生的
2.  战争
3.  希伯来语的第六个字母

为了理解这些危险，我们将假设我们有两个指令 I1 和 I2，这样 I2 跟随 I1。危险描述如下:

### 原始:

原始危险可称为**“写后读”。**也称为流/真数据依赖。如果后一条指令试图在前一条指令写入操作数之前读取操作数，在这种情况下，将会出现 RAW 危险。检测原始危险的条件是 O <sub>n</sub> 和 I <sub>n+1</sub> 都有一个最小的公共操作数。

**例如:**

```
I1: add R1, R2, R3
I2: sub R5, R1, R4

```

存在 RAW 危险，因为减法指令读取加法的输出。“添加 **R1、** R2、R3”和“R5 号潜艇、 **R1、** R4”的危险说明如下:

| 指令/周期 | one | Two | three | four | five | six |
| **I<sub>1</sub>T3】** | 如果 | 身份 | 激励器 | 查看内存状况 | 世界银行 |  |
| **I<sub>2</sub>T3】** |  | 如果 | 身份 | 激励器 | 查看内存状况 | 世界银行 |

RAW 危害非常普遍。

### 战争

WAR 可以称为“读后写”。它也被称为反数据依赖。如果后一条指令试图在前一条指令读取操作数之前写入操作数，在这种情况下，将会出现 WAR 危险。检测 WAR 危险的条件是 I <sub>n</sub> 和 O <sub>n+1</sub> 都至少有一个公共操作数。

**例如:**

依赖性描述如下:

```
add R1, R2, R3
sub R2, R5, R4

```

这里加法指令产生了 WAR 危险，因为减法指令写 R2，它通过加法读取。在合理的(有序的)管道中，WAR 危险非常罕见或不可能。“添加 R1、 **R2、** R3”和“添加 **R2、** R5、R4”的危险说明如下:

| 指令/周期 | one | Two | three | four | five | six |
| **I<sub>1</sub>T3】** | 如果 | 身份 | 激励器 | 查看内存状况 | 世界银行 |  |
| **I<sub>2</sub>T3】** |  | 如果 | 身份 | 激励器 | 查看内存状况 | 世界银行 |

当指令试图进入流水线的回写阶段时，此时，程序包含的所有先前指令已经通过寄存器的读取阶段并读取它们的输入值。现在，在不引起任何问题的情况下，写指令可以写入其目的寄存器。与 WAW 相比，WAR 指令包含的问题更少，因为在 WAR 中，在流水线的回写阶段之前，会发生寄存器的读阶段。

### 希伯来语的第六个字母

WAW 可以称为**‘写后再写’。**也称为输出数据依赖。如果后一条指令试图在前一条指令写入操作数之前写入操作数，在这种情况下，将会出现 WAW 危险。检测 WAW 危险的条件是 O <sub>n</sub> 和 O <sub>n+1</sub> 都至少有一个公共操作数。

**例如:**

依赖性描述如下:

```
add R1, R2, R3
sub R1, R2, R4

```

这里加法指令产生了一个 WAW 危险，因为减法指令写在同一个寄存器上。“添加 **R1、** R2、R3”和“添加 **R1、** R2、R4”的危险说明如下:

| 指令/周期 | one | Two | three | four | five | six | seven |
| **I<sub>1</sub>T3】** | 如果 | 身份 | 激励器 | 查看内存状况 | MEM2 | MEM3 | 世界银行 |
| **I<sub>2</sub>T3】** |  | 如果 | 身份 | 激励器 | 查看内存状况 | 世界银行 |  |

在流水线的回写阶段，指令的输出寄存器将被写入。带有 WAW 危险的指令在程序中出现的顺序，这些指令将以相同的顺序进入流水线的回写阶段。这些指令的结果将以正确的顺序写入寄存器。与原始程序相比，该处理器的性能有所提高，因为它允许指令以不同的顺序执行。

**WAR 和 WAW 的效果**

WAR 危险和 WAW 危险的发生是因为该过程包含有限数量的寄存器。由于这个原因，这些危险也被称为名称依赖。

如果每个指令包含无限数量的寄存器，处理器将使用不同的寄存器来生成每个指令的输出。在这种情况下，不会发生战争和战争遗留爆炸物的危险。

如果处理器对所有指令使用相同的流水线，并且按照它们在程序中出现的相同顺序执行这些指令，WAR 和 WAW 危险不会导致延迟。这都是因为指令流经管道的过程。

* * *