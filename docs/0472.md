# 数据结构教程

> 原文:[https://www.javatpoint.com/data-structure-tutorial](https://www.javatpoint.com/data-structure-tutorial)

![DS Tutorial](../Images/1f9ed666d783d61464343e574d0746e7.png)

数据结构教程提供了数据结构的基本和高级概念。我们的数据结构教程是为初学者和专业人士设计的。

数据结构是一种存储和组织数据的方式，以便有效地使用数据。

我们的数据结构教程包括数据结构的所有主题，如数组、指针、结构、链表、堆栈、队列、图形、搜索、排序、程序等。

### 什么是数据结构？

数据结构名称本身表示在内存中组织数据。有很多方法来组织内存中的数据，因为我们已经看到了其中一种数据结构，即 C 语言中的数组。数组是按顺序(即一个接一个)存储数据的存储元素的集合。换句话说，我们可以说数组以连续的方式存储元素。这种数据组织是在一系列数据结构的帮助下完成的。还有其他方法来组织内存中的数据。让我们看看不同类型的数据结构。

数据结构不是 C、C++、java 等任何编程语言。它是一组算法，我们可以用任何编程语言来构造内存中的数据。

为了在内存中构造数据，提出了“n”种算法，所有这些算法都被称为抽象数据类型。这些抽象数据类型是一组规则。

![Data Structures Tutorial](../Images/a3ffbe2c07933455114c371f4d66bfba.png)

### 数据结构的类型

有两种数据结构:

*   原始数据结构
*   非原始数据结构

**原始数据结构**

原始数据结构是原始数据类型。int、char、float、double 和 pointer 是可以保存单个值的基本数据结构。

**非原始数据结构**

非原始数据结构分为两种类型:

*   线性数据结构
*   非线性数据结构

**线性数据结构**

以顺序方式排列的数据被称为线性数据结构。用于此目的的数据结构有数组、链表、堆栈和队列。在这些数据结构中，一个元素以线性形式只与另一个元素相连。

**当一个元素连接到‘n’个元素时称为非线性数据结构。最好的例子是树和图。在这种情况下，元素以随机方式排列。**

在接下来的主题中，我们将简要讨论上述数据结构。现在，我们将看到我们可以对这些数据结构执行的常见操作。

**数据结构也可以分为:**

*   **静态数据结构:**是一种在编译时分配大小的数据结构。因此，最大大小是固定的。
*   **动态数据结构:**是一种在运行时分配大小的数据结构。因此，最大尺寸是灵活的。

### 主要运营

可以对数据结构执行的主要或常见操作有:

*   **搜索:**我们可以搜索数据结构中的任何元素。
*   **排序:**我们可以按照升序或降序对数据结构的元素进行排序。
*   **插入:**我们也可以在数据结构中插入新元素。
*   **更新:**我们也可以更新元素，即我们可以用另一个元素替换该元素。
*   **删除:**我们还可以执行删除操作，将元素从数据结构中删除。

### 哪种数据结构？

数据结构是一种组织数据的方式，以便有效地使用它。在这里，我们已经有效地使用了这个词，从空间和时间的角度来看。例如，堆栈是一种 ADT(抽象数据类型)，它使用数组或链表数据结构来实现。因此，我们得出结论，我们需要一些数据结构来实现特定的 ADT。

ADT 告诉**要做什么**，数据结构告诉**如何做**。换句话说，我们可以说 ADT 给了我们蓝图，而数据结构提供了实现部分。现在问题出现了:如何知道哪种数据结构将用于特定的自动数据转换？。

因为不同的数据结构可以在特定的 ADT 中实现，但是不同的实现是在时间和空间上进行比较的。例如，堆栈 ADT 可以通过数组和链表来实现。假设数组提供时间效率，而链表提供空间效率，那么将选择最适合当前用户需求的数组。

### 数据结构的优势

**以下是数据结构的优点:**

*   **效率:**如果选择一个数据结构来实现一个特定的 ADT 是合适的，那么就时间和空间而言，它会使程序非常高效。
*   **复用性:**数据结构提供复用性意味着多个客户端程序可以使用该数据结构。
*   **抽象:**由一个 ADT 指定的数据结构也提供了抽象的层次。客户端看不到数据结构的内部工作，所以不必担心实现部分。客户端只能看到界面。

* * *

## 数据结构索引

* * *

**DS 基础知识**

*   [DS 教程](data-structure-tutorial)
*   [DS 介绍](data-structure-introduction)
*   [DS 算法](data-structure-algorithm)
*   [Ds 渐近分析](data-structure-asymptotic-analysis)
*   [DS 指针](data-structure-pointer)
*   [DS 结构](data-structure-structure)

**DS 阵列**

*   [阵列](data-structure-array)
*   [2D 阵](data-structure-2d-array)

**DS 链表**

*   [链表](singly-linked-list)
    *   [开始插入](insertion-in-singly-linked-list-at-beginning)
    *   [末端插入](insertion-in-singly-linked-list-at-end)
    *   [在指定节点后插入](insertion-in-singly-linked-list-after-specified-node)
    *   [开头删除](deletion-in-singly-linked-list-at-beginning)
    *   [结尾删除](deletion-in-singly-linked-list-at-end)
    *   [指定节点后删除](deletion-in-singly-linked-list-after-specified-node)
    *   [穿越](traversing-in-singly-linked-list)
    *   [搜索](searching-in-singly-linked-list)
*   [双向链表](doubly-linked-list)
    *   [开始插入](insertion-in-doubly-linked-list-at-beginning)
    *   [末端插入](insertion-in-doubly-linked-list-at-the-end)
    *   [在指定节点后插入](insertion-in-doubly-linked-list-after-specified-node)
    *   [开头删除](deletion-in-doubly-linked-list-at-beginning)
    *   [结尾删除](deletion-in-doubly-linked-list-at-the-end)
    *   [删除具有给定数据的节点](deletion-in-doubly-linked-list-after-the-specified-node)
    *   [穿越](traversing-in-doubly-linked-list)
    *   [搜索](searching-in-doubly-linked-list)
*   [循环链表](circular-singly-linked-list)
    *   [开始插入](insertion-in-circular-singly-list-at-beginning)
    *   [末端插入](insertion-in-circular-singly-linked-list-at-end)
    *   [开头删除](deletion-in-circular-singly-linked-list-at-beginning)
    *   [末尾删除](deletion-in-circular-singly-linked-list-at-end)
    *   [穿越](deletion-in-circular-singly-linked-list-at-end)
    *   [搜索](deletion-in-circular-singly-linked-list-at-end)
*   [循环双列表](circular-doubly-linked-list)
    *   [开始插入](insertion-in-circular-doubly-linked-list-at-beginning)
    *   [末端插入](insertion-in-circular-doubly-linked-list-at-end)
    *   [开头删除](deletion-in-circular-doubly-linked-list-at-beginning)
    *   [末尾删除](deletion-in-circular-doubly-linked-list-at-end)

**DS 堆栈**

*   [DS 堆栈](data-structure-stack)
*   [阵列实现](ds-array-implementation-of-stack)
*   [链表实现](ds-linked-list-implementation-of-stack)

ds 队列

*   ds 队列
*   [阵列实现](array-representation-of-queue)
*   [链表实现](linked-list-implementation-of-queue)
*   [循环队列](circular-queue)

**DS 树**

*   [树](tree)
*   [二叉树](binary-tree)
    *   [预序遍历](binary-tree-preorder-traversal)
    *   [有序遍历](binary-tree-inorder-traversal)
    *   [后序遍历](binary-tree-postorder-traversal)
*   [二叉查找树](binary-search-tree)
    *   [在 BST 中搜索](searching-in-binary-search-tree)
    *   [插入 BST](insertion-in-binary-search-tree)
    *   [BST 中的删除](deletion-in-binary-search-tree)
*   [AVL 树](avl-tree)
    *   [插入 AVL 树](insertion-in-avl-tree)
        *   [LL 旋转](ll-rotation-in-avl-tree)
        *   [LR 旋转](lr-rotation-in-avl-tree)
        *   [RL 旋转](rl-rotation-in-avl-tree)
        *   [RR 旋转](rr-rotation-in-avl-tree)
    *   [在 AVL 树中删除](deletion-in-avl-tree)
*   [B 树](b-tree)
*   [B+树](b-plus-tree)
*   [红黑树](red-black-tree)

**DS 图**

*   [DS 图](ds-graph)
*   [图形实现](graph-representation)
*   [BFS 算法](breadth-first-search-algorithm)
*   [DFS 算法](depth-first-search-algorithm)
*   [生成树](spanning-tree)
    *   [普里姆算法](prim-algorithm)
    *   [克鲁斯卡尔算法](kruskal-algorithm)

**DS 搜索**

*   [线性搜索](linear-search)
*   [二分搜索法](binary-search)

**DS 排序**

*   [气泡排序](bubble-sort)
*   [桶排序](bucket-sort)
*   [梳理分类](comb-sort)
*   [计数排序](counting-sort)
*   [堆排序](heap-sort)
*   [插入输出](insertion-sort)
*   [合并排序](merge-sort)
*   [快速排序](quick-sort)
*   [基数排序](radix-sort)
*   [选择排序](selection-sort)
*   [外壳分类](shell-sort)
*   [双音素排序](bitonic-sort)
*   [鸡尾酒种类](cocktail-sort)
*   [循环排序](cycle-sort)
*   [Tim 退出](tim-sort)

**面试问题**

*   [DS 面试问题](data-structure-interview-questions)

**单链表程序**

*   [创建和显示单链表的程序](program-to-create-and-display-a-singly-linked-list)
*   [程序创建 n 个节点的单链表并计算节点数](program-to-create-a-singly-linked-list-of-n-nodes-and-count-the-number-of-nodes)
*   [程序创建 n 个节点的单链表，并以相反的顺序显示](program-to-create-a-singly-linked-list-of-n-nodes-and-display-it-in-reverse-order)
*   [从单链表的开头删除一个新节点的程序](program-to-delete-a-new-node-from-the-beginning-of-the-singly-linked-list)
*   [从单链表中间删除一个新节点的程序](program-to-delete-a-new-node-from-the-middle-of-the-singly-linked-list)
*   [从单链表末尾删除节点的程序](program-to-delete-a-node-from-the-end-of-the-singly-linked-list)
*   [判断单链表是否为回文的程序](program-to-determine-whether-a-singly-linked-list-is-the-palindrome)
*   [从单链表中寻找最大值和最小值节点的程序](program-to-find-the-maximum-and-minimum-value-node-from-a-singly-linked-list)
*   [在单链表中间插入新节点的程序](program-to-insert-a-new-node-at-the-middle-of-the-singly-linked-list)
*   [在单链表开头插入新节点的程序](program-to-insert-a-new-node-at-the-beginning-of-the-singly-linked-list)
*   [在单链表末尾插入新节点的程序](program-to-insert-a-new-node-at-the-end-of-the-singly-linked-list)
*   [从单链表中删除重复元素的程序](program-to-remove-duplicate-elements-from-a-singly-linked-list)
*   [在单链表中搜索元素的程序](program-to-search-an-element-in-a-singly-linked-list)
*   [对单链表的元素进行排序的程序](program-to-sort-the-elements-of-the-singly-linked-list)
*   [在不交换数据的情况下交换单链表中的节点的程序](program-to-swap-nodes-in-a-singly-linked-list-without-swapping-data)
*   [将单链表的最后一个元素与第一个元素交换的程序](program-to-swap-the-last-element-of-the-singly-linked-list-from-the-first-one)

**双链表程序**

*   [将给定二叉树转换为双向链表的程序](program-to-convert-a-given-binary-tree-to-doubly-linked-list)
*   [从三元树创建双链表的程序](program-to-create-a-doubly-linked-list-from-a-ternary-tree)
*   [创建 N 个节点的双向链表并计算节点数的程序](program-to-create-a-doubly-linked-list-of-n-nodes-and-count-the-number-of-nodes)
*   [创建 N 个节点的双向链表并按相反顺序显示的程序](program-to-create-a-doubly-linked-list-of-n-nodes-and-display-it-in-reverse-order)
*   [创建和显示双向链表的程序](program-to-create-and-display-a-doubly-linked-list)
*   [从双向链表开始处删除新节点的程序](program-to-delete-a-new-node-from-the-beginning-of-the-doubly-linked-list)
*   [从双向链表末尾删除新节点的程序](program-to-delete-a-new-node-from-the-end-of-the-doubly-linked-list)
*   [从双向链表中间删除一个新节点的程序](program-to-delete-a-new-node-from-the-middle-of-the-doubly-linked-list)
*   [从双向链表中寻找最大值和最小值节点的程序](program-to-find-the-maximum-and-minimum-value-node-from-a-doubly-linked-list)
*   [在双向链表开头插入新节点的程序](program-to-insert-a-new-node-at-the-beginning-of-the-doubly-linked-list)
*   [在双向链表末尾插入新节点的程序](program-to-insert-a-new-node-at-the-end-of-doubly-linked-list)
*   [在双向链表中间插入新节点的程序](program-to-insert-a-new-node-at-the-middle-of-doubly-linked-list)
*   [从双向链表中删除重复元素的程序](program-to-remove-duplicate-elements-from-a-doubly-linked-list)
*   [将双链表旋转 N 个节点的程序](program-to-rotate-doubly-linked-list-by-n-nodes)
*   [在双向链表中搜索元素的程序](program-to-search-an-element-in-a-doubly-linked-list)
*   [双链表元素排序程序](program-to-sort-the-elements-of-the-doubly-linked-list)

**循环链表程序**

*   [创建 N 个节点的循环链表并计算节点数的程序](program-to-create-a-circular-linked-list-of-n-nodes-and-count-the-number-of-nodes)
*   [创建 N 个节点的循环链表并按相反顺序显示的程序](program-to-create-a-circular-linked-list-of-n-nodes-and-display-it-in-reverse-order)
*   [创建和显示循环链表的程序](program-to-create-and-display-a-circular-linked-list)
*   [从循环链表开始删除新节点的程序](program-to-delete-a-new-node-from-the-beginning-of-the-circular-linked-list)
*   [从循环链表末尾删除新节点的程序](program-to-delete-a-new-node-from-the-end-of-the-circular-linked-list)
*   [从循环链表中间删除一个新节点的程序](program-to-delete-a-new-node-from-the-middle-of-the-circular-linked-list)
*   [从循环链表中寻找最大值和最小值节点的程序](program-to-find-the-maximum-and-minimum-value-node-from-a-circular-linked-list)
*   [在循环链表开头插入新节点的程序](program-to-insert-a-new-node-at-the-beginning-of-the-circular-linked-list)
*   [在循环链表末尾插入新节点的程序](program-to-insert-a-new-node-at-the-end-of-the-circular-linked-list)
*   [在循环链表中间插入新节点的程序](program-to-insert-a-new-node-at-the-middle-of-the-circular-linked-list)
*   [从循环链表中删除重复元素的程序](program-to-remove-duplicate-elements-from-a-circular-linked-list)
*   [在循环链表中搜索元素的程序](program-to-search-an-element-in-a-circular-linked-list)
*   [循环链表元素排序程序](program-to-sort-the-elements-of-the-circular-linked-list)

**树形程序**

*   [计算二叉树奇数层和偶数层节点之和之差的程序](program-to-calculate-the-difference-between-the-sum-of-the-odd-level-and-even-level-nodes-of-a-binary-tree)
*   [构建二叉查找树并执行删除和有序遍历的程序](program-to-construct-a-binary-search-tree-and-perform-deletion-and-inorder-traversal)
*   [将二叉树转换成二叉查找树的程序](program-to-convert-binary-tree-to-binary-search-tree)
*   [确定所有叶子是否在同一水平的程序](program-to-determine-whether-all-leaves-are-at-same-level)
*   [确定两棵树是否相同的程序](program-to-determine-whether-two-trees-are-identical)
*   [求二叉树最大宽度的程序](program-to-find-maximum-width-of-a-binary-tree)
*   [寻找二叉树中最大元素的程序](program-to-find-the-largest-element-in-a-binary-tree)
*   [寻找树木最大深度或高度的程序](program-to-find-the-maximum-depth-or-height-of-a-tree)
*   [寻找二叉树中距离最大的节点的程序](program-to-find-the-nodes-which-are-at-the-maximum-distance-in-a-binary-tree)
*   [寻找二叉树中最小元素的程序](program-to-find-the-smallest-element-in-a-binary-tree)
*   [求二叉树所有节点之和的程序](program-to-find-the-sum-of-all-the-nodes-of-a-binary-tree)
*   [用 N 个键寻找可能的二分搜索法树总数的程序](program-to-find-the-total-number-of-possible-binary-search-trees-with-n-keys)
*   [使用链表实现二叉树的程序](program-to-implement-binary-tree-using-the-linked-list)
*   [在二叉树中搜索节点的程序](program-to-search-a-node-in-a-binary-tree)

* * *

## 先决条件

在学习数据结构之前，你必须具备 c 语言的基础知识

## 观众

我们的数据结构教程旨在帮助初学者和专业人士。

## 问题

我们保证您在本数据结构教程中不会发现任何问题。但是如果有任何错误，请在联系表中公布。

* * *