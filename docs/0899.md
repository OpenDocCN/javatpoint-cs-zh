# 操作系统中的系统调用

> 原文:[https://www.javatpoint.com/system-calls-in-operating-system](https://www.javatpoint.com/system-calls-in-operating-system)

系统调用是用户程序与操作系统接口的一种方式。程序请求几个服务，操作系统通过调用一系列系统调用来满足请求。系统调用可以用汇编语言或高级语言编写，如 **C** 或**帕斯卡**。系统调用是预定义的函数，如果使用高级语言，操作系统可以直接调用这些函数。

在本文中，您将了解操作系统中的系统调用，并讨论它们的类型和许多其他事情。

## 什么是系统调用？

系统调用是计算机程序向运行它的[操作系统](https://www.javatpoint.com/os-tutorial)的内核请求服务的一种方法。系统调用是一种通过程序与操作系统交互的方法。系统调用是计算机软件对操作系统内核的请求。

**应用程序接口**将操作系统的功能连接到用户程序。它充当操作系统和进程之间的链接，允许用户级程序请求操作系统服务。内核系统只能使用系统调用来访问。任何使用资源的程序都需要系统调用。

## 系统调用是如何进行的？

当计算机软件需要访问操作系统的内核时，它会进行系统调用。系统调用使用一个应用编程接口向用户程序公开操作系统的服务。这是访问内核系统的唯一方法。所有需要资源来执行的程序或进程都必须使用系统调用，因为它们充当操作系统和用户程序之间的接口。

以下是系统调用如何不同于用户函数的一些示例。

1.  系统调用函数可以创建并使用内核进程来执行异步处理。
2.  系统调用比标准子程序具有更大的权限。具有内核模式权限的系统调用在内核保护域中执行。
3.  不允许系统调用使用共享库或内核保护域中不存在的任何符号。
4.  系统调用的代码和数据存储在全局内核内存中。

## 为什么在操作系统中需要系统调用？

在各种情况下，您必须在操作系统中要求系统调用。以下情况如下:

1.  当文件系统想要创建或删除文件时，这是必须的。
2.  网络连接需要系统调用来发送和接收数据包。
3.  如果你想读或写一个文件，你需要系统调用。
4.  如果您想要访问硬件设备，包括打印机、扫描仪，则需要系统调用。
5.  系统调用用于创建和管理新流程。

## 系统调用如何工作

应用程序运行在一个称为用户空间的内存区域。系统调用连接到操作系统的内核，该内核在内核空间中执行。当应用程序创建系统调用时，它必须首先从内核获得权限。它使用中断请求来实现这一点，中断请求会暂停当前进程，并将控制权转移给内核。

如果请求被允许，内核执行请求的操作，比如创建或删除文件。作为输入，应用程序接收内核的输出。收到输入后，应用程序将恢复该过程。操作完成后，内核将结果返回给应用程序，然后将数据从内核空间移动到内存中的用户空间。

一个简单的系统调用可能需要几纳秒来提供结果，比如检索系统日期和时间。更复杂的系统调用，例如连接到网络设备，可能需要几秒钟。大多数操作系统为每个系统调用启动不同的内核线程，以避免瓶颈。现代操作系统是多线程的，这意味着它们可以同时处理各种系统调用。

## 系统调用的类型

通常有五种类型的系统调用。这些措施如下:

![System Calls in Operating System](../Images/f2baf782ba9bab324840bae7709f679a.png)

1.  **过程控制**
2.  **文件管理**
3.  **设备管理**
4.  **信息维护**
5.  **沟通**

现在，您将逐一了解所有不同类型的系统调用。

### 过程控制

过程控制是用于指导过程的系统调用。一些过程控制示例包括创建、加载、中止、结束、执行、处理、终止过程等。

### 文件管理

文件管理是用于处理文件的系统调用。一些文件管理示例包括创建文件、删除文件、打开、关闭、读取、写入等。

### 设备管理

设备管理是用于处理设备的系统调用。设备管理的一些示例包括读取、设备、写入、获取设备属性、释放设备等。

### 信息维护

信息维护是用于维护信息的系统调用。有一些信息维护的例子，包括获取系统数据、设置时间或日期、获取时间或日期、设置系统数据等。

### 沟通

通信是用于通信的系统调用。有一些通信示例，包括创建、删除通信连接、发送、接收消息等。

## Windows 和 Unix 系统调用示例

有各种各样的 Windows 和 Unix 系统调用的例子。这些在下表中列出:

| 过程 | Windows 操作系统 | Unix 操作系统 |
| **过程控制** | CreateProcess()
ExitProcess()
WaitForSingleObject() | Fork()
Exit()
Wait() |
| **文件操作** | create file()
read file()
write file()
close handler() | 打开()
读取()
写入()
关闭() |
| **设备管理** | set onslemode()
read console()
write console() | Ioctl()
Read()
Write() |
| **信息维护** | GetCurrentProcessID（）
SetTimer（）
Sleep（） | Getpid()
报警()
睡眠() |
| **沟通** | createpipe()
create file mapping()
mapviewoffile() | 管道()
shmget()
mmap() |
| **保护** | setfile security()
InitializeSecurityDescriptor()
SetSecurityDescriptorgroup() | Chmod()
Umask()
Chown() |

在这里，您将简要了解一些方法:

### 打开()

**open()** 系统调用允许您访问文件系统上的文件。它为文件分配资源，并提供进程可能引用的句柄。许多进程可以一次打开一个文件，也可以只由一个进程打开。这都是基于文件系统和结构。

### 已读()

它用于从文件系统上的文件中获取数据。它总体上接受三个论点:

*   文件描述符。
*   存储读取数据的缓冲区。
*   要从文件中读取的字节数。

要读取的文件的文件描述符可用于识别它，并在读取前使用 **open()** 打开它。

### 等待()

在某些系统中，一个进程可能必须等待另一个进程完成其执行才能继续。当父进程成为子进程时，父进程的执行将暂停，直到子进程完成。 **wait()** 系统调用用于暂停父进程。一旦子进程完成了它的执行，控制权就返回给父进程。

### 写入()

它用于将数据从用户缓冲区写入文件等设备。这个系统调用是程序生成数据的一种方式。通常需要三个参数:

*   文件描述符。
*   指向保存数据的缓冲区的指针。
*   要从缓冲区写入的字节数。

### 叉子()

进程使用 **fork()** 系统调用生成自己的克隆。这是在操作系统中创建进程的最常见方式之一。当父进程生成子进程时，父进程的执行将被中断，直到子进程完成。一旦子进程完成了它的执行，控制权就返回给父进程。

### 关闭()

它用于结束文件系统访问。当这个系统调用被调用时，它表示程序不再需要该文件，缓冲区被刷新，文件信息被改变，结果文件资源被取消分配。

### exec()

当一个可执行文件替换了一个已经在执行的进程中的早期可执行文件时，这个系统函数被调用。由于没有构建新的流程，旧的流程标识会保留，但是新的流程会替换数据、堆栈、数据、头等。

### 出口()

**退出()**是一个系统调用，用于结束程序执行。这个调用表示线程执行完成，这在多线程环境中特别有用。在使用**退出()**系统功能后，操作系统回收进程消耗的资源。

* * *