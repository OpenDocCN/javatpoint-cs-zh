# 自动电压调节器微控制器中的条件转移指令

> 原文:[https://www . javatpoint . com/conditional-branch-in-instruction-AVR-微控制器](https://www.javatpoint.com/conditional-branch-instruction-in-avr-microcontroller)

就汇编语言编程而言，最重要和最基本的方面是控制程序流程的能力。如果我们控制程序流，这意味着我们指示微控制器从程序中的一个地址跳到另一个地址。这个过程被称为分支。如果没有此功能，只要指令用完，微控制器就会在内存中按顺序执行。如果我们试图编写一个没有条件分支的非平凡程序，那将是极其困难的，但这个过程并非不可能。借助寄存器，我们可以理解 AVR 微控制器的指令，描述如下:

### 状态寄存器

在 AVR 微控制器中，状态寄存器也称为标志寄存器或条件码寄存器。程序员将它用于某些编程目的。它包含与处理器状态相关的信息。该寄存器为 8 位。它包含 8 个标志，根据先前指令的结果进行更新。在 6 位(从位 0 到位 5)的帮助下，条件标志表示为 V、S、Z、N、C 和 h

在状态寄存器中，8 位的表示如下:

![Conditional Branch instruction in AVR Microcontroller](../Images/138b719e593fa337218a687d653882b2.png)

这里，数据位的使用描述如下:

**位 0:** 是 C 表示的进位标志，也称为 D0。

**位 1:** 是 Z 表示的零标志，也叫 D1。

**位 2:** 是 N 代表的否定标志，也叫 D2。

**位 3:** 是 V 表示的二进制补码溢出标志，也称为 D3。

**位 4:** 是 S 表示的符号位，也叫 D4。

**位 5:** 是 H 代表的半进位标志，也叫 D5。

**位 6:** 是以 T 为代表的位拷贝存储，也叫 D6。

**位 7:** 是以 I 为代表的全局中断使能，也称为 D7。

### 进位标志

进位标志也称为 C 标志。假设我们正在执行 n 位算术或逻辑运算。如果运算产生的结果超过 n 位，进位标志将设置为值 1。否则，进位标志将被重置为值 0。

### 零标志

这个标志也被称为 Z 标志。如果算术运算的结果为零，该标志将被设置为值 1。如果结果不为零，标志将被重置为值 0。换句话说，我们可以这样表达零标志:

```

If result = 0, then Z = 1
If result = non zero, then Z = 0 

```

### 负标志

这个标志也被称为 N 标志。这里我们将使用符号位 D7，它用于显示有符号数字的二进制表示。标志将设置为值 1，如果 D7 位显示值 1，结果将为负。该标志将被重置为值 0，如果 D7 位显示值 0，结果将为正。换句话说，我们可以这样表达一个否定的标志:

```

If D7 = 1, then N = 1 and result = negative
If D7 = 0, then N = 0 and result = positive

```

### 溢出标志

这种旗帜也被称为 V 旗。如果有符号数运算的输出非常大，溢出标志将被设置为值 1。因此，高位将溢出到符号位。在另一种情况下，溢出标志将被重置为值 0。

### 标志旗

这种旗帜也被称为 S 旗。在任何逻辑运算或算术运算之后，如果 D7 显示值 1，那么 1 将指示负数，并且还显示现在设置了符号标志。如果 D7 显示值 0，则 0 将指示正数，并显示符号标志被重置。

### 半进位标志

这种旗帜也被称为 H 旗。当进行加法或加法运算时，如果有从 D3 到 D4 的进位，将设置半进位标志。

下表显示了各种类型的条件分支指令及其说明:

| 指令 | 说明 | 标志状态 |
| 布雷克 | BREQ 指的是“**分支如果相等**”。它是一种条件相对分支。如果零标志(Z)被**设置**，该指令将测试相对于 PC(程序计数器)的 Z 和分支。假设有两个寄存器，D(目的寄存器)和 S(源寄存器)，包含有符号或无符号二进制数。如果寄存器 **D** 和寄存器 **S** 的二进制数**相等**，则分支发生。BREQ 相对于程序计数器在任一方向上，即 PC - 63 ≤目的地≤ PC + 64。这里用 k 表示偏移量。 | Z = 1 时的分支 |
| 布尔诺 | 如果不相等，BRNE 指的是“**分支**”。它是一种条件相对分支。如果零标志(Z)被**清除**，该指令将测试相对于 PC(程序计数器)的 Z 和分支。假设有两个寄存器，D(目的寄存器)和 S(源寄存器)，包含有符号或无符号二进制数。如果寄存器 **D** 和寄存器 **S** 的二进制数**不相等**，则分支发生。 | Z = 0 时的分支 |
| 布朗什 | BRSH 指的是“**分支，如果相同或更高(无符号)**”。它是一种条件相对分支。如果进位标志(C)被**清除**，该指令将测试 C 和相对于 PC(程序计数器)的分支。假设有两个寄存器，D(目的寄存器)和 S(源寄存器)，包含无符号二进制数。如果寄存器 **D** 的无符号数大于或等于寄存器 **S** 的无符号数，则分支发生。BRSH 相对于程序计数器在任一方向上，即 PC - 63 ≤目的地≤ PC + 64。这里用 k 表示偏移量。 | C = 0 时的分支 |
| -我不知道 | 如果低于，BRSH 指的是“**分支”。如果进位标志(C)被**设置**，该指令将测试 C 和相对于 PC(程序计数器)的分支。假设有两个寄存器，D(目的寄存器)和 S(源寄存器)，包含无符号二进制数。如果寄存器 **D** 的无符号数小于寄存器**S 的无符号数，则分支发生。 | C = 1 时的分支 |
| 带？带 | 如果低于，BRSH 指的是“**分支”。如果一个有符号的标志被**设置**，该指令将测试相对于 PC 机(程序计数器)的 S 和分支。假设有两个寄存器，D(目的寄存器)和 S(源寄存器)，包含有符号的二进制数。如果寄存器 **D** 的签名数**小于寄存器**S**的签名数，则分支发生。BRLT 相对于程序计数器在任一方向上，即 PC - 63 ≤目的地≤ PC + 64。这里用 k 表示偏移量。 | S = 1 时的分支 |
| 布哥 | 如果大于或等于，BRGE 指的是“**分支”。如果一个有符号的标志被**清除**，该指令将测试相对于 PC(程序计数器)的 S 和分支。假设有两个寄存器，D(目的寄存器)和 S(源寄存器)，包含有符号的二进制数。如果寄存器 **D** 的签名数大于或等于寄存器**S 的签名数，则分支发生。 | S = 0 时的分支 |
| BRVS | BRVS 指的是“溢出设置时的**分支”。如果溢出标志(V)为**设置**，该指令将测试相对于 PC(程序计数器)的 V 和分支。** | V = 1 时的分支 |
| BRVC | 如果溢出被清除，BRVC 指的是“**分支”。如果溢出标志(V)被**清除**，该指令将测试相对于 PC(程序计数器)的 V 和分支。** | V = 0 时的分支 |

* * *