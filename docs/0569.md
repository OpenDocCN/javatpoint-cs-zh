# 将中缀转换为后缀符号

> 原文：<https://www.javatpoint.com/convert-infix-to-postfix-notation>

在理解中缀到后缀符号的转换之前，我们应该分别了解中缀和后缀符号。

中缀和后缀是表达式。表达式由常量、变量和符号组成。符号可以是运算符或括号。所有这些组件都必须根据一组规则进行排列，以便可以使用该组规则评估所有这些表达式。

**表达式的例子有:**

**5 + 6**

**A - B**

**(P * 5)**

以上所有表达式都有一个共同的结构，即我们在两个操作数之间有一个运算符。操作数是要对其执行操作的对象或值。在上面的表达式中，5、6 是操作数，而“+”、“-”和“*”是运算符。

### 什么是中缀符号？

当运算符写在操作数之间时，则称为**中缀符号**。操作数不一定总是常数或变量；它也可以是一种表达本身。

**例如**

(p + q) * (r + s)

在上面的表达式中，乘法运算符的两个表达式都是操作数，即 **(p + q)** 、 **(r + s)** 是操作数。

在上面的表达式中，有三个运算符。第一个加号运算符的操作数是 p 和 q，第二个加号运算符的操作数是 r 和 s。在对表达式执行**运算时，我们需要遵循一些规则来评估结果。在上面的**表达式中，将对两个表达式，即 p+q 和 r+s 执行加法运算，然后执行乘法运算。

**中缀符号的语法如下:**

**<操作数> <操作数> <操作数>**

如果表达式中只有一个运算符，我们不需要应用任何规则。比如 5+2；在这个表达式中，可以在两个操作数(5 和 2)之间执行加法运算，运算结果将是 7。

如果表达式中有多个运算符，则需要遵循一些规则来计算表达式。

如果表达式为:

4 + 6 * 2

如果首先计算加号运算符，则表达式如下所示:

10 * 2 = 20

如果先计算乘法运算符，则表达式如下所示:

4 + 12 = 16

上述问题可以通过遵循运算符优先级规则来解决。在代数表达式中，运算符优先级的顺序如下表所示:

| 经营者 | 标志 |
| 圆括号 | ( ), {}, [ ] |
| 倡导者 | ^ |
| 乘法和除法 | *, / |
| 加法和减法 | + , - |

第一个选择是括号；然后下一个优先选择指数。在多个指数运算符的情况下，操作将从右向左应用。

**例如:**

2^2^3 = 2 ^ 8

= 256

计算指数、乘法和除法运算符后。如果两个操作符都出现在表达式中，那么操作将从左向右应用。

接下来是加法和减法。如果两个运算符在表达式中都可用，那么我们从左到右。

具有相同优先级的运算符称为**运算符关联性**。如果我们从左到右，那么它被称为左联想。如果我们从右向左，那么它被称为右联想。

### 中缀符号的问题

求中缀表达式，要知道**运算符优先级**规则，如果运算符优先级相同，那么要遵循**结合律**规则。在中缀符号中，括号的使用对于控制操作的执行顺序非常重要。括号提高了表达式的可读性。中缀表达式是最常见的编写表达式的方式，但是要解析和评估中缀表达式而不产生歧义并不容易。因此，数学家和逻辑学家研究了这个问题，发现了另外两种书写表达式的方法，即前缀和后缀。这两个表达式都不需要任何括号，并且可以无歧义地解析。它不需要运算符优先级和结合规则。

### 后缀表达式

后缀表达式是运算符写在操作数之后的表达式。例如，中缀符号(2+3)的后缀表达式可以写成 23+。

关于后缀表达式的一些要点是:

*   在后缀表达式中，操作按照从左到右的顺序执行。
*   它不需要任何括号。
*   我们不需要应用运算符优先级规则和结合规则。

**计算后缀表达式的算法**

*   从左到右扫描表达式，直到我们遇到任何运算符。
*   执行操作
*   用计算值替换表达式。
*   重复步骤 1 至 3，直到不再有操作员为止。

**我们通过一个例子来了解一下上面的算法。**

中缀表达式:2 + 3 * 4

我们将从表情的最左边开始扫描。乘法运算符是从左向右扫描时首先出现的运算符。现在，这个表达应该是:

表达式= 2 + 34*

= 2 + 12

同样，我们将从左向右扫描，表达式将是:

表达式= 2 ^ 12+

= 14

### 使用堆栈计算后缀表达式。

*   从左向右扫描表达式。
*   如果我们在表达式中遇到任何操作数，那么我们将操作数推入堆栈。
*   当我们在表达式中遇到任何运算符时，我们会从堆栈中弹出相应的操作数。
*   当我们完成对表达式的扫描时，最终值会保留在堆栈中。

**我们来了解一下使用栈对后缀表达式的求值。**

**例 1:后缀表达式:2 3 4 * +**

| 投入 | 堆 |  |
| 2 3 4 * + | 空的 | 推 2 |
| 3 4 * + | Two | 推 3 |
| 4 * + | 3 2 | 推 4 |
| * + | 4 3 2 | 弹出 4 和 3，执行 4*3 = 12。将 12 推入堆栈。 |
| + | One hundred and twenty-two | 从堆栈中弹出 12 和 2，执行 12+2 = 14。将 14 推入堆栈。 |

上面表达式的结果是 14。

**例 2:后缀表达式:3 4 * 2 5 * +**

| 投入 | 堆 |  |
| 3 4 * 2 5 * + | 空的 | 推 3 |
| 4 * 2 5 * + | three | 推 4 |
| *2 5 * + | 4 3 | 从堆栈中弹出 3 和 4，并执行 3*4 = 12。将 12 推入堆栈。 |
| 2 5 * + | Twelve | 推 2 |
| 5 * + | 2 12 | 推 5 |
| *+ | 5 2 12 | 从堆栈中弹出 5 和 2，并执行 5*2 = 10。将 10 推入堆栈。 |
| + | 10 12 | 从堆栈中弹出 10 和 12，执行 10+12 = 22。将 22 推入堆栈。 |

上面表达式的结果是 22。

**计算后缀表达式的算法**

1.  读一个角色
2.  如果字符是数字，将字符转换为 int，并将整数推入堆栈。
3.  如果角色是操作员，
    *   从堆栈中弹出元素两次，得到两个操作数。
    *   执行操作
    *   将结果推入堆栈。

### 中缀到后缀的转换

这里，我们将使用堆栈数据结构将中缀表达式转换为前缀表达式。每当遇到一个操作符，我们就把操作符推入堆栈。如果我们遇到一个操作数，那么我们将该操作数追加到表达式中。

**中缀到后缀表达式的转换规则**

1.  到达时打印操作数。
2.  如果堆栈为空或顶部包含左括号，则将传入的运算符推到堆栈上。
3.  如果传入的符号是'('，则将它推到堆栈上。
4.  如果输入符号是')'，弹出堆栈并打印运算符，直到找到左括号。
5.  如果传入符号的优先级高于堆栈顶部，请将其推送到堆栈上。
6.  如果传入符号的优先级低于堆栈顶部，则弹出并打印堆栈顶部。然后，针对堆栈的新顶部测试传入的运算符。
7.  如果传入运算符与堆栈顶部具有相同的优先级，则使用关联性规则。如果关联性是从左到右，则弹出并打印堆栈顶部，然后按下传入运算符。如果关联性是从右向左，则按下传入运算符。
8.  在表达式的末尾，弹出并打印堆栈的所有操作符。

**我们通过一个例子来了解一下。**

**中缀表达式:K + L - M*N + (O^P) * W/U/V * T + Q**

| 输入表达式 | 堆 | 后缀表达式 |
| K |  | K |
| + | + |  |
| L | + | 九龙城 |
| - | - | K L+ |
| M | - | K L+ M |
| * | - * | K L+ M |
| 普通 | - * | 钾锂+锰氮 |
| + | + | KL+M ^ N *
KL+M ^ N *- |
| （ | + ( | K L + M N *- |
| O | + ( | K L + M N * - O |
| ^ | + ( ^ | K L + M N* - O |
| P | + ( ^ | K L + M N* - O P |
| ) | + | K L + M N* - O P ^ |
| * | + * | K L + M N* - O P ^ |
| W | + * | K L + M N* - O P ^ W |
| / | + / | K L + M N* - O P ^ W * |
| U | + / | K L + M N* - O P ^W*U |
| / | + / | K L + M N* - O P ^W*U/ |
| V | + / | KL + MN*-OP^W*U/V |
| * | + * | KL+MN*-OP^W*U/V/ |
| T | + * | KL+MN*-OP^W*U/V/T |
| + | + | kl+mn*-op^w*u/v/t*
kl+mn*-op^w*u/v/t*+ |
| Q | + | KL+MN*-OP^W*U/V/T*Q |
|  |  | KL+MN*-OP^W*U/V/T*+Q+ |

中缀表达式(K + L - M*N + (O^P) * W/U/V * T + Q)的最后一个后缀表达式是 KL+MN*-OP^W*U/V/T*+Q+.

* * *