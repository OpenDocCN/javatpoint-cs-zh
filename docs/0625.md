# 数据结构中的大 0 符号

> 原文：<https://www.javatpoint.com/big-O-notation-in-data-structure>

渐近分析是研究当输入大小的顺序改变时，算法的性能如何改变。我们使用大符号将运行时间的扩展渐近地限制在上下恒定的因子内。执行算法所需的时间、存储和其他资源决定了算法的效率。渐近符号用于确定效率。对于不同类型的输入，算法的性能可能会有所不同。随着输入大小的增加，性能会有所波动。

当输入趋向于某个值或极限值时，渐近符号被用来表示一个算法需要执行多长时间。例如，当输入数组已经排序时，方法花费的时间是线性的，这是最好的情况。

但是，当输入数组的顺序相反时，该方法需要最长的(二次)时间来对项目进行排序，这是最坏的情况。当输入数组未排序或顺序相反时，平均花费的时间。渐近符号用于表示这些持续时间。

大 O 符号根据函数的增长率对函数进行分类:几个增长率相同的函数可以用相同的 O 符号编写。使用符号 0 是因为一个函数的发展速度也称为函数的顺序。一个函数的大 O 符号描述通常只对函数的开发速度提供一个上限约束。

如果有一种渐近表示法，意味着“运行时间最多增长这么多，但它可能增长得更慢”，这将是很方便的。我们在这样的场合使用“大 0”符号。

## 大 O 符号的优势

*   当使用运行时输入检查算法的效率时，渐近分析非常有用。否则，如果我们手动通过各种输入的测试用例，性能可能会随着算法输入的变化而变化。
*   当算法在多台计算机上执行时，其性能会有所不同。因此，我们选择一种算法，它的性能不会随着输入数量的增加而发生很大变化。因此，数学表示提供了对算法运行时的上限和下限的清晰理解。

## 例子

现在让我们更深入地了解各种示例的大 O 符号:

**O(1):**

```

void constantTimeComplexity(int arr[])
{
    printf("First element of array = %d",arr[0]);
}

```

该函数相对于其输入以 0(1)时间(或“恒定时间”)运行。输入数组可以是 1 个项目或 1，000 个项目，但是这个函数仍然只需要一个步骤。

**O(n):**

```

void linearTimeComplexity(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        printf("%d\n", arr[i]);
    }
}

```

该函数在 O(n)时间(或“线性时间”)内运行，其中 n 是数组中的项数。如果数组有 10 项，我们要打印 10 次。如果它有 1000 个项目，我们必须打印 1000 次。

**O(n^2):**

```

void quadraticTimeComplexity(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        for (int j = 0; j < size; j++)
        {
            printf("%d = %d\n", arr[i], arr[j]);
        }
     }
}

```

这里我们嵌套了两个循环。如果我们的数组有 n 个项目，那么我们的外部循环运行 n 次，并且我们的内部循环在外部循环的每次迭代中运行 n 次，从而得到 n^2 总打印量。如果数组有 10 项，我们要打印 100 次。如果它有 1000 个项目，我们要打印 1000000 次。因此，该函数在 O(n^2 时间(或“二次时间”)中运行。

**O(2^n):**

```

int fibonacci(int num)
{
    if (num <= 1) return num;
    return fibonacci(num - 2) + fibonacci(num - 1);
}

```

O(2^n 函数的一个例子是斐波那契数的递归计算。O(2^n)表示一种算法，其增长随着输入数据集的每次增加而翻倍。O(2^n 函数的增长曲线是指数型的——从非常浅的地方开始，然后迅速上升。

因此，在本文中，我们了解了什么是数据结构中的大 O 符号，以及如何在日常实践中使用它来理解日常交付的时间复杂性。

* * *