# 自动电压调节器微控制器中的分支指令

> 原文:[https://www . javatpoint . com/branch-in-instruction-in-AVR-微控制器](https://www.javatpoint.com/branch-instruction-in-avr-microcontroller)

为了理解分支指令，我们应该了解 AVR 微控制器中的循环。之后，我们将学习两种类型的分支指令:条件分支指令和无条件分支指令。

### 在 AVR 微控制器中循环

当我们编写代码时，我们想到的最基本的技术是循环。该循环可以被描述为一组指令或编程方面的重复操作。如果我们在 AVR (Alf 和 Vegard 的 RISC 处理器)中重复编写一组指令，那么执行循环的方法只有一种。

**例如:**

```

LDI A, 0
LDI B, 1
ADD A, B
ADD A, B
ADD A, B
ADD A, B
ADD A, B
ADD A, B

```

借助上面的例子，我们可以看到上面的代码占用了大量的空间，效率也很低。因此，我们可以在分支指令的帮助下，使循环的上述代码更加简单和节省空间。

## 分支指令:

在程序循环和条件中，控制流是借助分支指令实现的。如果给定的条件得到满足，那么只有特定的指令序列被执行。当我们执行分支指令时，执行被切换到不同的指令。分支指令有两种类型:条件分支指令和无条件分支指令。

### 条件转移指令

条件转移指令可以描述为一组指令。它通过提供循环外的分支来控制程序流。

下表描述了各种类型的条件分支指令及其说明:

| 指令 | 说明 | 标志状态 |
| 布雷克 | BREQ 指的是“**分支如果相等**”。它是一种条件相对分支。如果零标志(Z)被**设置**，该指令将测试相对于 PC(程序计数器)的 Z 和分支。假设有两个寄存器 D(目的寄存器)和 S(源寄存器)，包含有符号或无符号二进制数。如果寄存器 **D** 和寄存器 **S** 的二进制数彼此相等**，则分支发生。** | Z = 1 时的分支 |
| 布尔诺 | 如果不相等，BRNE 指的是“**分支**”。如果零标志(Z)被**清除**，该指令将测试相对于 PC(程序计数器)的 Z 和分支。假设有两个寄存器 D(目的寄存器)和 S(源寄存器)，包含有符号或无符号二进制数。如果寄存器 **D** 和寄存器 **S** 的二进制数彼此不相等**，则分支发生。** | Z = 0 时的分支 |
| 布朗什 | 如果相同或更高，BRSH 指的是“**分支”。如果进位标志(C)被**清除**，该指令将测试 C 和相对于 PC(程序计数器)的分支。假设有两个寄存器 D(目的寄存器)和 S(源寄存器)，包含无符号二进制数。如果寄存器 **D** 的无符号数大于或等于寄存器 **S** 的无符号数，则分支发生。** | C = 0 时的分支 |
| -我不知道 | 如果低于，BRSH 指的是“**分支”。如果进位标志(C)被**设置**，该指令将测试 C 和相对于 PC(程序计数器)的分支。假设有两个寄存器 D(目的寄存器)和 S(源寄存器)，包含无符号二进制数。如果寄存器 **D** 的无符号数小于寄存器**S 的无符号数，则分支发生。 | C = 1 时的分支 |
| 带？带 | 如果低于，BRSH 指的是“**分支”。如果一个有符号的标志被**设置**，该指令将测试相对于 PC 机(程序计数器)的 S 和分支。假设两个寄存器 D(目的寄存器)和 S(源寄存器)包含有符号的二进制数。如果寄存器 **D** 的签名数**小于寄存器**S**的签名数，则分支发生。 | S = 1 时的分支 |
| 布哥 | 如果大于或等于，BRGE 指的是“**分支”。如果签名标志为**清除**，该指令将测试与 PC 机(程序计数器)相关的 S 和分支。假设两个寄存器 D(目的寄存器)和 S(源寄存器)包含有符号的二进制数。如果寄存器 **D** 的签名数大于或等于寄存器**S 的签名数，则分支发生。 | S = 0 时的分支 |
| BRVS | BRVS 指的是“溢出设置时的**分支”。如果溢出标志(V)为**设置**，该指令将测试相对于 PC(程序计数器)的 V 和分支。** | V = 1 时的分支 |
| BRVC | 如果溢出被清除，BRVC 指的是“**分支”。如果溢出标志(V)被**清除**，该指令将测试相对于 PC(程序计数器)的 V 和分支。** | V = 0 时的分支 |

### 使用 BRNE 循环

如果不相等，BRNE 指的是分支。如果 Z 被清除，它将测试零标志(Z)并相对于 PC 分支。它基本上使用状态寄存器中的 Z 标志。

**例如:**

在这个例子中，我们将编写一个代码将 5 加到 C 上，这个过程将重复 20 次。最后，在 BRNE 指令的帮助下，我们将把总数发送给 PORTC。

```

      LDI A, 20;            counter register
      LDI B, 0
      LDI C, 5
LOOP:    ADD B, C
      DEC A;            decrement the counter  
      BRNE LOOP;      repeat until counter = 0
      OUT PORTC, B

```

所有的条件分支基本上都使用短跳转。这意味着目标地址必须在程序计数器的 64 字节内。

### 无条件转移指令

无条件分支可以描述为控制无条件转移到目标地址的跳转。AVR 基本上有三种类型的无条件分支指令，即 JMP、IJMP 和 RJMP。无条件分支的指令描述如下:

**JMP:**

JMP 指令也被称为跳远。这是一种无条件跳转，可以跳转到任何内存位置，但该位置必须在 AVR 的 4M(字)地址空间内。JMP 指令是 4 字节指令。在 10 位的帮助下，操作码被表示，在其余位的帮助下，意味着 22 位，目标位置的 22 位地址被表示。

**RMP:**

RJMP 指令也称为相对跳转。RJMP 指令是 2 字节指令。在前四位的帮助下，操作码被表示，在其余位的帮助下，目标位置的相对地址被表示。相对地址的范围是 000-$FFF，分为两跳:后跳和前跳。该跳转必须在内存的-2048 和+2047 范围内，这是相对于当前程序计数器地址的。

**jmp:**

IJMP 指令也被称为间接跳转。IJMP 指令是 2 字节指令。当我们执行 IJMP 指令时，程序计数器将借助 Z 寄存器的内容加载。这意味着 Z 寄存器提供一个地址，IJMP 跳到这个地址。该指令能够在个人计算机(程序计数器)的最低 64k 字(128KB)内跳转。

* * *