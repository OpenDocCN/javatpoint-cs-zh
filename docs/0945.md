# 操作系统中的活锁

> 原文:[https://www.javatpoint.com/livelock-in-operating-system](https://www.javatpoint.com/livelock-in-operating-system)

在本文中，您将了解操作系统中的 Livelock。

## 什么是活锁？

当对排他锁的请求由于多个重叠的共享锁不断干扰而不断被拒绝时，就会发生活锁。流程状态不断变化，阻止他们完成任务，使他们更难完成任务。

当多个进程重复执行相同的交互以响应其他进程的变化而不执行任何有用的工作时，就会发生这种情况。这些进程不处于等待状态，同时运行，与死锁不同，因为死锁的所有进程都处于等待状态。

## 活锁的例子

活锁的各种例子如下:

### 例 1:

活锁的一个常见例子是，当两个人在走廊里面对面相遇时，两个人都闪开让另一个人过去。他们最终从一边走到另一边，没有取得任何进展，因为他们同时朝着同一个方向前进。所以，他们是没能互相跨越的。

### 例 2:

Livelock 的另一个例子是两个进程需要两个资源，它们使用原语轮询进入注册表来获取所需的锁。如果第一次尝试失败，将尝试第二次尝试。让我们假设:

![Livelock in Operating System](../Images/70d5797cba58f641e594bba26cc39f56.png)

1.  流程 **A** 持有 **Y** 资源
2.  处理 **B** 持有 **X** 资源
3.  流程 **A** 需要 **X** 资源
4.  流程 **B** 需要 **Y** 资源

假设流程 **A** 先运行并获取数据资源 **X** ，流程 **B** 后运行并获取资源 **Y** ，无论哪个流程先运行都没有流程进展。但是，没有任何进程被阻止。它们持续使用 CPU 资源而没有任何进展，但是它们也停止任何处理块。因此，这不是死锁，因为没有单个进程被停止，但是您处于类似于死锁的情况，这就是 LIVELOCK。

## 什么导致活锁？

当给定系统中允许的总进程必须由进程表中的条目数来定义时，活锁就发生了。因此，进程表槽应该称为有限资源。如果一个分叉由于满表而失败，分叉程序应该随机等待一段时间再尝试。

来看看一个带有 **100** 进程槽的 UNIX 系统。 **10** 程序正在运行，每个程序负责创建 **12** (子)流程。每道工序都创建了 **9** 新工艺后，表格就被 **10** 原工艺和 **90** 新工艺耗尽了。每一个 **10** 的原始进程都陷入了一个永无止境的分叉和失败的循环，这被称为死锁。虽然这种情况发生的几率微乎其微，但还是有可能的。

* * *