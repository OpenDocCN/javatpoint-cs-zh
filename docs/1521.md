# 哥德尔-奥库本模型

> 原文:[https://www . javatpoint . com/software-engineering-goel-oku moto-model](https://www.javatpoint.com/software-engineering-goel-okumoto-model)

Goel 和 Okumoto 在 1979 年开发的模型基于以下假设:

1.  时间 t 经历的故障次数遵循泊松分布，平均值函数为μ (t)。该平均值法有边界条件 **μ(0) = 0 和 Lim <sub>t→∞</sub> μ(t) = N < ∞** 。
2.  在带有**δt→0**的 **(t，t+δt)**中发生的软件故障数量与未检测到的错误的预期数量 **N - μ(t)** 成正比。相称的常数是∅.
3.  对于任何有限的时间集合**t<sub>1</sub><t<sub>2</sub><<t<sub>n</sub>**在每个不相交的间隔 **(0，t <sub>1</sub> )，(t <sub>1</sub> ，t <sub>2</sub> )...(t <sub>n-1</sub> ，t <sub>n</sub> )** 独立。
4.  每当出现故障时，导致故障的故障会被立即消除，并且不会给软件带来任何新的故障。

由于每一个故障都是在导致故障后被完美修复的，所以在测试开始时软件中固有故障的数量等于无限量测试后出现的故障数量。根据假设 1，M (∞)遵循泊松分布，期望值为 N。因此，与 Jelinski Moranda 模型中固定但未知的初始软件故障实际数量μ <sub>0</sub> 相比，N 是初始软件故障的预期数量。

假设 2 指出，时间 t 的失效强度由下式给出

**d<sub>【t】</sub>/d<sub>=【n-μ(t)]</sub>**

就像在 Jelinski-Moranda 模型中一样，故障强度是单个故障的恒定危险率和软件中剩余的预期故障数量的乘积。然而，N 本身是一个期望值。

## 穆萨的基本执行时间模型

Musa 的基本执行时间模型基于一个执行时间模型，即建模过程中花费的时间是被建模软件的实际 CPU 执行时间。该模型易于理解和应用，其预测价值已被普遍发现是良好的。可靠性建模中的失效强度模型目标。

它假设故障强度随时间降低，也就是说，随着(执行)时间的增加，故障强度降低。这种假设通常是正确的，因为以下是关于软件测试活动的假设，在此期间收集数据:在测试期间，如果观察到故障，则检测到导致该故障的故障，并删除该故障。

即使某个特定的故障排除操作可能不成功，总体故障也会减少软件中的故障。因此，故障强度降低。大多数其他模型都做出了类似的假设，这与实际观察一致。

在基本模型中，考虑到每一次故障都会导致相同数量的故障强度衰减。也就是说，故障强度随着故障次数以恒定的速率降低。在更复杂的穆萨对数模型中，缩减不是线性的，而是对数的。

Musa 在 1975 年建立的基本执行时间模型是第一个明确要求时间测量以执行被测应用程序所用的实际 CPU 时间(简称“执行时间”t)为单位的模型。

虽然最初并不是这样表述的，但模型可以通过三个特征来分类:

*   无限时间内可以经历的失败次数是有限的。
*   时间 t 所注意到的故障数量的分布是泊松型的。
*   失效强度随时间变化的函数方法是指数函数。

它与 Goel-Okumoto 模型共享这些方法，这两个模型在数学上是等价的。除了使用执行时间之外，一个不同之处在于对恒定的每故障危险率∅.的解释 Musa 将∅分解为两个常数方法，线性执行频率 f 和所谓的故障暴露率 k:

**d<sub>【t】</sub>/d<sub>= f k[n-μ(t)]</sub>**

f 可以计算为计算机的平均目标指令执行率 r 除以被测应用的源代码指令数 l <sub>s</sub> ，乘以每个源代码指令的平均目标指令数，**Q<sub>x</sub>:f = r/l<sub>s</sub>Q<sub>x</sub>T9】。**

故障暴露率将故障速度**f【N-μ(t)】**(如果连续执行所有语句，代码的缺陷部分将通过的速度)与经历的故障强度相关联。因此，它可以被解释为在程序的一次线性执行期间，代码中剩余的每个故障发生的平均故障数。

* * *