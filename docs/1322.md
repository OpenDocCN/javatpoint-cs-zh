# 调用指令和跳转指令的区别

> 原文：<https://www.javatpoint.com/call-vs-jump-instructions>

**跳转指令**是一种转移指令。在这个指令的帮助下，我们能够将信息从一个位置传送到另一个位置。如果我们正在运行一个程序，并想跳过一些横档或逻辑部分，在这种情况下，跳转指令将是有用的。返回的信息不会存储在跳转指令中。

**调用指令**也是一种控制转移指令。在指令的帮助下，我们能够调用子程序。子程序包含一个指令块，需要频繁执行。由于这一点，程序将更加结构化，并节省大量的内存空间。当调用指令调用子程序并且子程序的执行完成时，控制将在 **RET** 指令的帮助下转移回调用方。

跳转指令和调用指令之间有许多不同之处，描述如下:

| 序列号 | 转移指令 | 呼叫指令 |
| one | 在跳转中，我们简单地分支到一个新的位置，然后从那里继续。 | 在调用中，我们分支到一个新的位置，这就是所谓的子程序。当我们使用 CALL 指令时，子程序将被执行。当子程序完全执行时，一条 RET 指令将被放入我们的程序中，这样返回的地址将从堆栈中被放入电脑。 |
| Two | 在 JUMP 指令中初始化堆栈指针不是强制性的。 | 在 CALL 指令中必须初始化堆栈指针。 |
| three | 在 JUMP 指令中，堆栈指针的值不会改变。 | 在 CALL 指令中，堆栈指针的值减 2。 |
| four | 在执行 JUP 之后，返回指令不包含，因为它不要求返回到前一个位置。 | 我们使用 CALL 指令，以便调用子程序。在堆栈返回地址的帮助下，控制将在子程序结束时由 RET 指令转移回主程序。 |
| five | 跳转指令不需要将返回地址存储到堆栈中。 | 在调用时，程序计数器的返回地址将被推入堆栈。
RET 指令时，从栈中弹出返回地址，并加入程序计数器。 |
| six | JUMP 指令不用于将程序计数器的值转移到堆栈中。 | CALL 指令用于将程序计数器的值转移到子程序中，这样它就可以回到主程序中。 |
| seven | 跳转指令中有一个立即寻址模式。 | CALL 指令有寄存器寻址模式和立即寻址模式。 |
| eight | 程序计数器被跳转指令永久改变。 | 该指令包含堆栈上留下的信息，用于恢复原始程序的执行顺序。 |
| nine | 在跳转指令中，PC 机被转移到一个存储单元，该存储单元是主程序的一部分。 | 在 CALL 指令中，PC 被转移到一个内存位置，而这个位置不是主程序的一部分。 |
| Ten | 跳跃有三种类型，即跳远、短跳和绝对跳。 | CALL 有两种，即长呼、绝对呼。 |
| Eleven | 为了执行跳转指令，我们需要 10 T 状态。 | 为了执行 CALL 指令，我们需要 18 个 T 状态。 |
| Twelve | 为了执行跳转指令，我们还需要 3 个机器周期。 | 为了执行 CALL 指令，我们还需要 5 个机器周期。 |
| Thirteen | JUMP 指令被描述为条件跳转和无条件跳转。 | CALL 指令仅被描述为无条件的。 |

* * *