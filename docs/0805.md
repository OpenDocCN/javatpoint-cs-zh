# 感兴趣的可变机制

> 原文：<https://www.javatpoint.com/os-interested-variable-mechanism>

我们必须确保进度必须由我们的同步机制提供。在转向变量机制中，由于不想进入关键部分的过程没有考虑其他感兴趣的过程，所以没有提供进度。

另一个过程也将不得不等待，而不管临界区内没有人的事实。如果操作系统可以利用额外的变量和转弯变量，那么这个问题就可以解决，我们的问题可以在很大程度上提供进展。

感兴趣的变量机制利用一个额外的布尔变量来确保提供进度。

**对于过程 Pi**

```

Non CS 
Int[i] = T ;
while ( Int[j] == T ) ; 
Critical Section
Int[i] = F ;

```

**对于工艺 Pj**

```

Non CS
Int [1] = T ;
while ( Int[i] == T ) ; 
Critical Section 
Int[j]=F ; 

```

在这个机制中，使用了一个额外的感兴趣的变量**。这是一个布尔变量，用于存储进入临界区的进程的兴趣。**

 **想要进入临界区的进程首先在入口区检查另一个进程是否有兴趣进入。该进程将等待时间，直到另一个进程感兴趣。

在退出部分，进程使其兴趣变量的值为假，以便其他进程可以进入关键部分。

该表显示了流程和在场景中获得机会的流程的可能的兴趣变量值。

| 利息[皮] | 利息[Pj] | 有机会的过程 |
| 真实的 | 真实的 | 首先表现出兴趣的过程。 |
| 真实的 | 错误的 | 圆周率 |
| 错误的 | 真实的 | 沙俊春 |
| 错误的 | 错误的 | X |

让我们根据需求来分析这个机制。

### 互斥现象

在感兴趣的变量机制中，如果一个进程对进入中央处理器感兴趣，那么另一个进程将等待，直到它变得不感兴趣。因此，一个以上的进程绝不能同时出现在关键部分，因此该机制保证了互斥。

### 进步

在这个机制中，如果一个进程对进入临界区不感兴趣，那么它不会阻止另一个进程进入临界区。所以这个方法一定会提供进度。

### 有界等待

为了分析有界等待，让我们考虑两个进程 Pi 和 Pj，它们是要在关键部分执行的协作进程。下面以相对的方式示出了由进程执行的指令。

| 过程 Pi | 过程 Pj | 过程 Pi | 过程 Pj |
| 1.Int [Pi] = True
2。while(Int[Pj]= = True)；
3。临界断面 | 1.Int [Pj] = True
2。while(Int[Pi]= = True)； | 1.Int [Pi] = False
2。Int [Pi] = True
3。while(Int[Pj]= = True)；//等待 Pj | 1.while(Int[Pi]= = True)；//等待 Pj |

最初，两个过程的兴趣变量都是**假**。过程 Pi 显示了进入关键部分的兴趣。

它将其兴趣变量设置为真，并检查 Pj 是否也感兴趣。由于另一个进程的兴趣变量为假，因此 Pi 将进入临界区。

同时，进程 Pi 被抢占，Pj 被调度。Pj 是一个合作的过程，因此，它也想进入关键部分。它通过将兴趣变量设置为 true 来显示其兴趣。

它还检查其他进程是否也感兴趣。我们应该注意到 Pi 被抢占了，但是它感兴趣的变量是真的，这意味着它需要在关键部分进一步执行。因此 Pj 不会得到机会，陷入 while 循环。

同时，中央处理器将 Pi 的状态从阻塞变为运行。Pi 尚未完成其关键部分，因此它完成了关键部分，并通过将兴趣变量设置为 False 来退出。

现在，当 Pi 再次想进入临界区，并将其感兴趣变量设置为 true，并检查 Pj 的感兴趣变量是否为 true 时，一种情况就可能出现。这里，Pj 的兴趣变量为真，因此 Pi 将陷入 while 循环，等待 Pj 变得不感兴趣。

从那以后，Pj 仍然停留在循环中，等待 Pi 感兴趣的变量变成假的。因此，两个过程都在相互等待，没有一个进入关键部分。

这是死锁的一个条件，在死锁的情况下永远不能提供有界等待。

因此，我们可以说，感兴趣的变量机制并不能保证死锁。

### 建筑中立

该机制是在用户模式下执行的完整软件机制，因此它保证了可移植性或架构中立性。

![os Interested Variable Mechanism](img/6dd80bde140b5f92960e56f2ff789b83.png)**