# 前缀到后缀表达式的转换

> 原文:[https://www . javatpoint . com/前缀到后缀表达式的转换](https://www.javatpoint.com/conversion-of-prefix-to-postfix-expression)

在理解前缀到后缀的转换之前，我们应该分别了解前缀和后缀表达式。

### 什么是前缀转换？

中缀表达式是将运算符写在两个操作数之间的表达式。如果我们把运算符放在操作数之前，那么它就是前缀表达式。换句话说，前缀表达式可以定义为所有运算符都在两个操作数之前的表达式。

**例如:**

**如果中缀表达式为:A + B * C**

我们知道乘法运算符*比加法运算符具有更高的优先级。首先，乘法运算符将移动到操作数 B 之前，如下所示:

A + * B C

一旦乘法运算符移到“B”操作数之前，加法运算符将移到操作数“A”之前，如下所示:

+ A * B C

**使用堆栈评估前缀表达式**

**步骤 1:** 初始化指向表达式末尾的指针“S”。

**第二步:**如果‘S’所指向的符号是操作数，则将它推入堆栈。

**步骤 3:** 如果“S”所指向的符号是一个运算符，则从堆栈中弹出两个操作数。对这两个操作数执行运算，并将结果存储到堆栈中。

**第 4 步:**将指针“S”减 1，移动到第 2 步，只要符号留在表达式中。

**第五步:**最终结果存储在栈顶并返回。

**第 6 步:**结束

**我们通过一个例子来理解前缀表达式的求值。**

**表达式:+，-，*，2，2，/，16，8，5**

**首先，我们将反转上面给出的表达式。**

**表达式:5，8，16，/，2，2，*，-，+**

**我们将使用堆栈数据结构来评估前缀表达式。**

| 符号扫描 | 堆 |
| five | five |
| eight | 5, 8 |
| Sixteen | 5, 8, 16 |
| / | 5, 2 |
| Two | 5, 2, 2 |
| Two | 5, 2, 2, 2 |
| * | 5, 2, 4 |
| - | 5, 2 |
| + | seven |

**上述表达式的最终结果为 7。**

### 什么是后缀表达式？

如果我们把操作符移到操作数之后，那么它就被称为后缀表达式。换句话说，后缀表达式可以定义为所有运算符都出现在操作数之后的表达式。

**例如:**

如果中缀表达式是 A + B * C

我们知道乘法运算符的优先级高于加法运算符，因此乘法运算符将移动到操作数 B 和 C 之后，如下所示:

A + B C *

一旦乘法运算符移到操作数 C 之后，加法运算符将位于乘法运算符之后，如下所示:

A B C * +

**使用堆栈评估后缀表达式**

使用堆栈计算后缀表达式的算法；

**第一步**:创建一个用于存储操作数的空栈。

**第 2 步:**扫描表达式的每个元素，一个接一个，并执行以下操作:

*   如果该元素是操作数，则将它推入堆栈。
*   如果该元素是运算符，则从堆栈中弹出两个操作数。对这些操作数执行运算。将最终结果推入堆栈。

**步骤 3:** 当表达式被完全扫描时，堆栈中可用的值将是给定表达式的最终输出。

**我们通过一个例子来理解使用栈对后缀表达式的求值。**

**如果表达式为:5，6，2，+，*，12，4，/，-**

| 符号扫描 | 堆 |
| five | five |
| six | 5, 6 |
| Two | 5, 6, 2 |
| + | 5, 8 |
| * | Forty |
| Twelve | 40, 12 |
| four | 40, 12, 4 |
| / | 40, 3 |
| - | Thirty-seven |

**上述表达式的结果为 37。**

### 前缀到后缀表达式的转换

在这里，我们将看到使用堆栈数据结构将前缀转换为后缀表达式。

**使用堆栈数据结构的前缀到后缀表达式的规则:**

*   从右向左扫描前缀表达式，即反向。
*   如果输入的符号是操作数，则将它推入堆栈。
*   如果传入的符号是运算符，则从堆栈中弹出两个操作数。一旦操作数从堆栈中弹出，我们就在操作数后添加输入符号。当运算符被加在操作数之后时，表达式被推回到堆栈中。
*   扫描完整个表达式后，从堆栈中弹出并打印后缀表达式。

**前缀到后缀转换的伪代码**

```

Function PrefixToPostfix(string prefix)
1\.   Stack s
2\.   Loop: i = prefix.length-1 to 0
•   if prefix[i] is operand ->
s.push(prefix[i])
•   else if prefix[i] is operator->
op1 = s.top()
s.pop()
op2 = s.top()
s.pop()
exp = op1 + op2 + prefix[i]
s.push(exp)
End Loop
3\.   Return s.top

```

**我们通过一个例子来了解一下使用 Stack 的前缀到后缀表达式的转换。**

**如果表达式为:* - A / B C - / A K L**

| 要扫描的符号 | 行动 | 堆 | 描述 |
| L | 将 L 推入堆栈 | L |  |
| K | 将 K 推入堆栈 | 左，右 |  |
| A | 将 A 推入堆栈 | l，K，A |  |
| / | 从堆栈中弹出 A
从堆栈中弹出 k
将 A/K 推入堆栈 | 左，右/ | 从栈中弹出两个操作数，即 A 和 K，K 操作数后加“/”运算符，即 AK/。将 AK/推入堆栈。 |
| - | 从堆栈中弹出 A/K 和 L。
推入堆栈 | 开/关- | 从栈中弹出两个操作数，即 AK/和 L，在“L”操作数后加“-”运算符。 |
| C | 将 C 推入堆栈 | AK/L-，C |  |
| B | 将 B 推入堆栈 | AK/L-，C，B |  |
| / | 从堆栈中弹出 B 和 C。
推 BC/入栈。 | AK/L-，BC/ | 从堆栈中弹出两个操作数，即 B 和 C。在 C 运算符后添加“/”运算符，即 BC/。将 BC/推入堆栈。 |
| A | 将 A 推入堆栈 | AK/L-，BC/，A |  |
| - | 从堆栈中弹出 BC/和 A。将 ABC/-推入堆栈。 | AK/L-，ABC/- | 从堆栈中弹出两个操作数，即 A 和 BC/。在“/”后添加“-”运算符。 |
| * | 从堆栈中弹出 ABC/-和 AK/L-。将 ABC/AK/L-*推入堆栈。 | ABC/-AK/L-* | 从堆栈中弹出两个操作数，即 ABC/-，和 AK/L-。在 L 和“-”运算符后加“*”运算符，即 ABC/-AK/L-*。 |

* * *