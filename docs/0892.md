# 操作系统中的银行家算法

> 原文：<https://www.javatpoint.com/bankers-algorithm-in-operating-system>

这是一个银行家算法，用于**避免死锁**和**将资源**安全地分配给计算机系统中的每个进程。“**S-State”**检查所有可能的测试或活动，然后决定是否允许分配给每个流程。它还帮助操作系统成功地在所有进程之间共享资源。银行家算法之所以被命名，是因为它检查一个人是否应该被制裁贷款金额，以帮助银行系统安全地模拟资源分配。在这一节中，我们将详细学习**银行家算法**。另外，我们将基于**银行家算法**解决问题。为了理解银行家算法，我们首先来看一个真实的单词例子。

假设某家银行的账户持有人数量为‘n’，某家银行的资金总额为‘T’。如果账户持有人申请贷款；首先，银行从全额现金中减去贷款金额，然后估计现金差额大于 T，以批准贷款金额。采取这些步骤是因为如果另一个人申请贷款或从银行提取一些金额，它将帮助银行管理和运营所有事情，而不会对银行系统的功能产生任何限制。

同样，它在 [**操作系统**](https://www.javatpoint.com/operating-system) 中工作。当在计算机系统中创建新进程时，该进程必须向[操作系统](https://www.javatpoint.com/os-tutorial)提供所有类型的信息，如即将到来的进程、对其资源的请求、计数和延迟。基于这些标准，操作系统决定应该执行或等待哪个进程序列，以便在系统中不发生死锁。因此在操作系统中又被称为**死锁避免算法**或**死锁检测**。

## 优势

以下是银行家算法的基本特征:

1.  它包含满足每个流程要求的各种资源。
2.  每个进程都应该向操作系统提供即将到来的资源请求、资源数量以及资源将被保留多长时间的信息。
3.  它帮助操作系统管理和控制计算机系统中每种类型资源的进程请求。
4.  该算法有一个最大资源属性，表示每个进程可以容纳系统中最大数量的资源。

## 不足之处

1.  它需要固定数量的进程，在执行该进程时，系统中不能启动额外的进程。
2.  该算法不再允许进程在处理其任务时交换其最大需求。
3.  每个进程都必须事先知道并说明它们对系统的最大资源需求。
4.  可以在有限的时间内批准资源请求的数量，但是分配资源的时间限制是一年。

当使用银行家算法时，它要求了解三件事:

1.  每个进程可以为系统中的每个资源请求多少。由[ **最大值** ]请求表示。
2.  每个进程当前在系统中占有多少资源。它由[ **已分配的**资源表示。
3.  它表示系统中当前可用的每个资源的数量。它由[**]资源表示。**

 **以下是银行家算法中应用的重要数据结构术语:

假设 n 是进程的数量，m 是计算机系统中使用的每种资源的数量。

1.  **可用**:它是一个长度为‘m’的数组，定义了系统中可用的每种类型的资源。当可用[j] = K 时，意味着资源类型为 R[j]的“K”个实例在系统中可用。
2.  **Max:** 它是一个[n×m]矩阵，表示每个进程 P[i]可以存储系统中最大数量的资源 R[j](每种类型)。
3.  **分配:**是 m×n 个订单的矩阵，表示当前分配给系统中每个进程的资源类型。当 Allocation [i，j] = K 时，表示进程 P[i]当前在系统中被分配了资源类型 R[j]的 K 个实例。
4.  **需求:**是一个 M×N 的矩阵序列，表示每个进程的剩余资源数量。当需求[i] [j] = k 时，那么过程 P[i]可能需要更多的资源类型 Rj 的实例来完成分配的工作。
    Nedd[i][j] = Max[i][j] -分配[i][j]。
5.  **完成**:是 **m** 阶的向量。它包括一个布尔值(真/假)，指示进程是否已分配给请求的资源，以及完成任务后所有资源是否已释放。

银行家算法是安全算法和资源请求算法的结合，用于控制系统中的进程和避免死锁:

### 安全算法

它是一种安全算法，用于检查系统是否处于安全状态或遵循银行家算法中的安全顺序:

1.在一个安全算法中有两个向量 **Wok** 和 **Finish** 长度为 m 和 n。

初始化:工作=可用
完成【I】=假；对于 I = 0，1，2，3，4… n - 1。

2.检查每种类型资源的可用性状态[i]，例如:

需要【I】<= Work
完成【I】= =假
如果 I 不存在，转到步骤 4。

3.工作=工作+分配(i) //获取新的资源分配

完成[i] =真

转到步骤 2，检查下一个流程的资源可用性状态。

4.如果完成[i] ==真；这意味着系统对所有进程都是安全的。

## 资源请求算法

资源请求算法检查当进程将系统中的每种类型的资源请求作为请求矩阵时，系统的行为。

让我们为每个进程 P[i]创建一个资源请求数组 R[i]。如果资源请求<sub>I</sub>【j】等于‘K’，这意味着进程 P[i]需要系统中资源类型 R[j]的‘K’个实例。

1.当每种类型的**请求资源**的数量小于**需要的**资源时，转到步骤 2，如果条件失败，这意味着进程 P[i]超过其对资源的最大要求。正如这个表达所暗示的:

如果请求(i) <= Need
转到步骤 2；

2.当每种类型的请求资源数量少于每个进程的可用资源时，转到步骤(3)。正如这个表达所暗示的:

如果请求(i) <= Available
否则进程 P[i]必须等待资源，因为它不可用。

3.当通过改变状态将请求的资源分配给进程时:

可用=可用-请求
分配(i) =分配(i) +请求(i)
需要 <sub>i</sub> =需要 <sub>i</sub> -请求 <sub>i</sub>

当资源分配状态安全时，其资源被分配给进程 P(i)。如果新状态不安全，进程 P (i)必须等待每种类型的请求 R(i)并恢复旧的资源分配状态。

**示例:**考虑一个包含五个进程 P1、P2、P3、P4、P5 以及三种资源类型 A、B 和 C 的系统，资源类型如下:A 有 10 个，B 有 5 个，资源类型 C 有 7 个实例。

| 过程 | 分配
甲乙丙 | 最大
A B C | 可用
A B C |
| 第一亲代 | 0         1          0 | 7         5         3 | 3         3         2 |
| P2 | 2         0         0 | 3         2         2 |  |
| P3 | 3         0         2 | 9         0         2 |  |
| P4 | 2         1         1 | 2         2         2 |  |
| 孕烯醇酮 | 0         0         2 | 4         3         3 |  |

**用庄家算法回答以下问题:**

1.  需求矩阵的参考是什么？
2.  确定系统是否安全。
3.  如果进程 P1 的资源请求(1，0，0)可以被系统立即接受，会发生什么？

**Ans。2:** 需求矩阵的上下文如下:

需要[i] = Max [i] -分配[i]
需要 P1: (7，5，3) - (0，1，0) = 7，4，3
需要 P2: (3，2，2) - (2，0，0) = 1，2，2
需要 P3: (9，0，2) - (3，0，2) = 6，0，0
需要 P4: (2，2，2) - (2，1，1) = 0，1，1
需要 P5: (4，4

| 过程 | 需要
A B C |
| 第一亲代 | 7         4         3 |
| P2 | 1         2         2 |
| P3 | 6         0         0 |
| P4 | 0         1         1 |
| 孕烯醇酮 | 4         3         1 |

因此，我们创建了需求矩阵的上下文。

**Ans。2:应用银行家算法:**

A、B 和 C 的可用资源是 3、3 和 2。

现在，我们检查每种类型的资源请求对于每个进程是否可用。

**步骤 1:** 对于过程 p 1:

需求< =可用

7、4、3 <= 3, 3, 2 condition is **假**。

**所以，我们考察另一个过程，P2。**

**步骤 2:** 对于过程 p 2:

需求< =可用

1、2、2 <= 3, 3, 2 condition **真**

新可用=可用+分配

(3, 3, 2) + (2, 0, 0) => 5, 3, 2

**同样，我们考察另一个过程 P3。**

**步骤 3:** 对于过程 p 3:

P3 需求< =可用

6，0，0 < = 5, 3, 2 condition is **假**。

**同样，我们考察另一个过程，P4。**

**步骤 4:** 对于过程 p 4:

P4 需求< =可用

0，1，1 <= 5, 3, 2 condition is **真**

新可用资源=可用+分配

5, 3, 2 + 2, 1, 1 => 7, 4, 3

**同样，我们考察另一个流程 P5。**

**步骤 5:** 对于流程 p 5:

P5 需求< =可用

4、3、1 <= 7, 4, 3 condition is **真**

新的可用资源=可用+分配

7, 4, 3 + 0, 0, 2 => 7, 4, 5

现在，我们再次检查 P1 和 P3 进程的每种类型的资源请求。

**步骤 6:** 对于过程 P1:

P1 需求< =可用

7、4、3 <= 7, 4, 5 condition is **真**

新可用资源=可用+分配

7, 4, 5 + 0, 1, 0 => 7, 5, 5

**所以，我们考察另一个过程 P2。**

**步骤 7:** 对于过程 P3:

P3 需求< =可用

6，0，0 <= 7，5，5 条件为真

新可用资源=可用+分配

7, 5, 5 + 3, 0, 2 => 10, 5, 7

**因此，我们执行银行家算法来寻找安全状态和安全序列，如 P2、P4、P5、P1 和 P3。**

**Ans。3:** 为了批准请求(1，0，2)，首先我们必须检查**请求< =可用**，即(1，0，2) < = (3，3，2)，因为条件为真。所以 P1 立即得到了请求。

* * ***