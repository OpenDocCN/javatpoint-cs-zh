# 排序算法的时间复杂度

> 原文：<https://www.javatpoint.com/time-complexity-of-sorting-algorithms>

我们可能会遇到各种情况，需要以特定的格式处理数据，而不需要任何进一步的延迟，同样的情况还有以更高的速度处理未排序的数据，以便结果可以有所用处。在这种情况下，我们使用排序算法，以便达到预期的效率。在本文中，我们将讨论各种类型的排序算法，重点是时间复杂性。但是，在进一步讨论之前，让我们先了解什么是复杂性，以及谈论复杂性有什么重要的。

### 复杂性

复杂性根本没有正式的定义。它只是定义了任务执行的效率。在数据结构和算法中，有两种类型的复杂性决定了算法的效率。它们是:

**空间复杂度:**空间复杂度是程序执行时消耗的总内存。

**时间复杂度:**定义为具体来说，数字指令预计执行的次数，而不是花费的总时间。由于时间是一种依赖现象，时间复杂性可能会因一些外部因素而异，如处理器速度、使用的编译器等。

在计算机科学中，算法的时间复杂度用大 O 符号表示。让我们讨论一些时间复杂性。

**O(1):** 表示恒定时间。0(1)通常意味着算法将具有恒定的时间，而与输入大小无关。**散列图**是恒定时间的完美例子。

**O(log n):** 表示对数时间。O(log n)表示随着操作的每个实例而减少。**二分搜索法树**是对数时间最好的例子。

**O(n):** 表示线性时间。O(n)表示性能与输入大小成正比。简单地说，输入的数量和执行这些输入所花费的时间将是成比例的或相同的。**阵列**中的线性搜索是线性时间复杂度的最佳示例。

**O(n2):** 这表示二次时间。O(n2)表示性能与输入的平方成正比。简单来说，执行所用的时间将是输入大小的平方倍。**嵌套循环**是二次时间复杂度的完美例子。

让我们进入主要计划，讨论不同排序算法的时间复杂性。

### 冒泡排序的时间复杂性

冒泡排序是一种简单的排序算法，通过比较每对元素来对元素进行排序，如果一个元素没有遵循所需的排序顺序，则切换它们。这个过程一直重复，直到达到元素所需的顺序。

平均案例时间复杂度: **O(n2)**

最坏情况时间复杂度: **O(n2)**

最佳情况时间复杂度: **O(n)**

最好的情况是给定的元素列表已经被排序。这就是为什么当输入大小很大时，冒泡排序被认为不够好。

### 选择排序的时间复杂性

选择排序以就地比较为基础。在这个算法中，我们主要是拾取一个元素，然后移动到它的正确位置。只要它们都按照所需的顺序排序，就会执行此过程。

平均案例时间复杂度: **O(n2)**

最坏情况时间复杂度: **O(n2)**

最佳情况时间复杂度: **O(n2)**

选择排序也遭受与我们在冒泡排序中看到的相同的缺点。对大型数据集进行排序是低效的。它通常是首选的，因为它简单，在辅助内存有限的情况下可以提高性能。

### 插入排序的时间复杂度

插入排序通过获取输入并将它们放在正确的顺序或位置来处理这种现象。因此，它基于在获取输入的同时迭代现有的元素，并将它们放在它们应该在的地方。

最佳情况时间复杂度: **O(n)**

平均和最坏情况时间复杂度: **O(n2)**

**快速排序的时间复杂度**

Quicksort 在著名的分治算法的保护下工作。在这种技术中，大的输入数组被分成更小的子数组，这些子数组被递归排序，并在排序后合并成一个巨大的数组。

最佳和平均时间复杂度: **O(n log n)**

最坏情况时间复杂度: **(n2)**

### 合并排序的时间复杂度

合并排序也在分治算法的影响下工作。在这种排序技术中，输入数组被分成两半，然后这两半被排序。排序后，这两个减半的子数组合并成一个，形成一个完整的排序数组。

最佳和平均时间复杂度: **O(n log n)**

最坏情况时间复杂度: **O(n log n)**

## 结论

时间复杂性在决定程序的整体性能方面起着至关重要的作用。它只是为了提高程序的性能并影响系统的整体性能。然而，速度越快，责任越大。因此，为了获得最佳的时间复杂度，开发人员需要敏锐地关注使用特定的算法或技术来提供最佳的情况复杂度。此外，要达到这样的速度，开发人员需要携带关于排序算法的先验知识。因此，强烈建议您详细了解本文中讨论的每一种技术，并找出最适合这种情况的技术。

* * *