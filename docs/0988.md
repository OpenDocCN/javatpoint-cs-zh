# 自旋锁和信号量的区别

> 原文：<https://www.javatpoint.com/spinlock-vs-semaphore>

在本文中，您将了解自旋锁和信号量之间的区别。但是在讨论差异之前，您必须了解自旋锁和信号量。

## 什么是自旋锁？

这是一种锁定机制。它使线程能够等待锁准备就绪，即线程可以循环或旋转等待，直到锁准备就绪。它只保持很短的时间，在多处理器系统中很有用。线程持有自旋锁，直到它在获取锁后被释放。在一些实现中，如果持有锁的线程被阻塞或进入睡眠状态，则自旋锁被自动释放。

自旋锁还避免了操作系统进程重调度或上下文切换带来的开销。此外，自旋锁是暂时阻塞线程的有效方法。因此，大多数操作系统内核都使用了自旋锁。但是，如果一个线程长时间保持自旋锁，它可能会阻止其他线程执行。在这种情况下，其他线程会反复尝试获取锁，而持有锁的线程不会开始释放锁。通常，它可能主要发生在单处理器系统中。

### 自旋锁的优缺点

自旋锁有各种各样的优点和缺点。自旋锁的一些优点和缺点如下:

**优势**

1.  它不需要上下文切换，因为它正忙于等待，并且线程没有休眠。
2.  如果临界截面(CS)较小，则有帮助。

**缺点**

1.  Spinlock 需要忙碌的等待。
2.  当锁不可用时，它会浪费一个 CPU 周期，并反复检查它是否可访问。

## 什么是信号量？

信号量是由多个进程共享的变量。使用信号量的主要目标是并发环境中公共资源的进程同步和访问控制。有两种 **wait()** 和 **signal()** 方法可以修改信号量中的信号量值。当一个进程改变信号量值时，其他进程可能不会同时改变信号量值。

此外，操作系统将信号量分为两种类型:

1.  **计数信号量**
2.  **二进制信号量**

**计数信号量**

在计算信号量时，会处理多个资源。它们用 count 函数初始化，分配资源，直到计数达到 0。请求资源的任务将被阻止，并且它们有一个不受限制的值域。当添加几个资源时，计数值增加，当资源数量减少时，计数减少。

**二进制信号量**

在二进制信号量中，信号量值的范围从 **0** 到 **1** 。它类似于互斥锁，区别在于互斥是一种锁定方法，信号量是一种信号方法。当一个进程需要使用二进制信号量资源时，它调用 **wait()** 方法，将信号量的值从 **1** 减少到 **0** 。

当进程释放资源时，它使用**信号()**方法将信号量值增加到 **1** 。当一个进程需要访问一个资源，信号量值为 **0** 时，它使用 **wait()** 方法进行阻塞，直到正在使用该资源的当前进程将其释放。

### 信号量的优缺点

信号量有各种各样的优缺点。信号量的一些优点和缺点如下:

**优势**

1.  它不允许各种进程进入临界区。
2.  不会因为信号量中的繁忙等待而浪费处理时间或资源。只有在满足特定条件的情况下，才允许进程访问关键区域。
3.  它允许灵活管理资源。
4.  它允许多个线程访问关键部分。

**缺点**

1.  必须执行等待和信号方法来避免死锁。
2.  如果使用不当，程序可能会被阻止。这种情况叫做死锁。
3.  它会导致优先级反转，这意味着低优先级进程可以先访问关键部分，高优先级进程可以稍后访问。

## 自旋锁和信号量的主要区别

![Spinlock vs Semaphore](img/5652ca5ada8e0c8a427aabdebb426d0f.png)

在这里，您将了解自旋锁和信号量之间的主要区别。自旋锁和信号量之间的不同之处如下:

1.  自旋锁可以用于互斥。相反，信号量可以用于互斥或计数信号量。
2.  自旋锁只允许单个进程在任何特定时间访问临界区。相比之下，信号量允许多个进程在任何特定时间访问关键部分。
3.  自旋锁可能只有两个值，即锁定和解锁。相反，在信号量中，互斥体的值将是 1 或 0，但是如果像信号量一样使用，它可能有不同的值。
4.  Spinlock 一次只允许一个线程获取锁，并继续执行关键部分。相比之下，信号量允许多个线程访问临界区。
5.  Spinlock 是一种低级同步机制。相反，信号量是一种信号机制。
6.  在 spinlock 中等待锁的进程将立即访问关键部分，因为该进程将不断轮询锁。相比之下，等待信号量中的锁的进程可能不会在锁释放后立即进入关键部分，因为该进程已经进入睡眠状态，并且在被唤醒时会进入关键部分。
7.  Spinlock 是一个繁忙的等待过程。相比之下，信号量是一个睡眠等待过程。

## 自旋锁和信号量的直接比较

在这里，您将学习自旋锁和信号量之间的直接比较。自旋锁和信号量之间的不同之处如下:

| 斯宾洛克 | 旗语 |
| 它可以用于互斥。 | 它可以用于互斥或计数信号量。 |
| Spinlock 是一种低级同步技术。 | 这是一种信号机制。 |
| 如果长时间持有自旋锁，可能会造成浪费。 | 没有资源浪费资源和处理时间。 |
| 自旋锁非常有效，因为它们只能被短时间阻塞。 | 它被保持更长的时间，并且它使用自旋锁来访问它的控制结构。 |
| 它一次只允许一个线程获取锁，并以一个关键部分继续操作。 | 它允许多个线程访问关键部分。 |
| 这是一个繁忙的等待过程。 | 这是一个睡眠等待过程。 |
| 自旋锁在单处理器系统中是无效的，因为它们使处理器每次轮询锁时都很忙，并阻止任何其他进程运行。 | 信号量在单处理器系统中很有帮助，因为它们不会让处理器在等待锁的时候保持忙碌。 |
| 它可能只有两个值，即“锁定”和“解锁”。 | 在信号量中，互斥体的值将为 1 或 0，但是如果用作计数信号量，它可能会有不同的值。 |
| 它一次只允许一个进程访问关键部分。 | 它允许几个进程在任何特定时间访问关键部分。 |
| 持有自旋锁时，建议禁用中断。 | 它可能在中断使能的情况下被锁定。 |
| 它仅对单个进程有效。 | 它可以用于许多进程之间的同步。 |
| 在 spinlock 中等待锁的进程将立即访问关键部分，因为该进程将不断轮询锁。 | 等待信号量中的锁的进程可能不会在锁释放后立即进入关键部分，因为该进程已经进入睡眠状态，当它被唤醒时将进入关键部分。 |

## 结论

Spinlock 是一种低级同步方法。安装简单快捷。然而，它浪费了系统资源。另一方面，信号量为进程同步问题提供了更高级的解决方案。他们不会浪费系统资源，因为他们让等待过程进入休眠状态。然而，如果不小心使用信号量，它们可能会导致死锁。

* * *