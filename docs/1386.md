# 迪克斯特拉算法:

> 原文:[https://www . javatpoint . com/离散-数学-dijkstras-算法](https://www.javatpoint.com/discrete-mathematics-dijkstras-algorithm)

该算法维护一组顶点，这些顶点到源的最短路径是已知的。该图由其代价邻接矩阵表示，其中代价是边的权重。在图的代价邻接矩阵中，所有对角值都为零。如果没有从源顶点 V <sub>s</sub> 到任何其他顶点 V <sub>i</sub> 的路径，那么它由+∞表示。在这个算法中，我们假设所有权重都是正的。

1.  最初，集合中没有顶点。
2.  将源顶点 V <sub>s</sub> 包含在 S 中。确定从 V <sub>s</sub> 到所有其他顶点的所有路径，而不经过任何其他顶点。
3.  现在，将距离 V <sub>s</sub> 最近的顶点包含在 S 中，并通过该顶点找到所有顶点的最短路径，然后更新值。
4.  重复该步骤，直到如果图中有 n 个顶点，则 S 中不包含 n-1 个顶点。

完成这个过程后，我们得到了从源顶点到所有顶点的最短路径。

**示例:**使用 Dijkstra 算法在图中所示的图中找到 K 和 L 之间的最短路径。

![Dijkstra's Algorithm](../Images/490a72de82c25bcabb680bb74abfa7a9.png)

**解决方案:**

**步骤 1:** 包含顶点 K 为 S，并确定从 K 到所有其他顶点的所有直接路径，而不经过任何其他顶点。

**到所有其他顶点的距离**

| S | K | a | b | c | d | L |
| K | Zero | 4(K) | ∞ | 2(K) | ∞ | 20(千) |

**步骤 2:** 在 S 中包含距离 K 最近的顶点，确定通过该顶点到所有顶点的最短路径，并更新值。最近的顶点是 c。

**到所有其他顶点的距离**

| S | K | a | b | c | d | L |
| K | Zero | 3(K，c) | 7(K，c) | 2(K) | 8(K，c) | 18(K，c) |

**第三步:**距离 K 最近的第二个<sup>和第三个</sup>的顶点是 9，包含在 s 中

**到所有其他顶点的距离**

| S | K | a | b | c | d | L |
| K | Zero | 3(K，c) | 7(K，c) | 2(K) | 7(K，c，a) | 18(K，c) |

**第四步:**距离 K 最近的第三个<sup>第三个</sup>的顶点是 b，包含在 s 中

**到所有其他顶点的距离**

| S | K | a | b | c | d | L |
| K | Zero | 3(K，c) | 7(K，c) | 2(K) | 7(K，c，a) | 8(K，c，b) |

**第五步:**距离 K 最近的顶点是 d，包含在 s 中

**到所有其他顶点的距离**

| S | K | a | b | c | d | L |
| K(c、a、b、d) | Zero | 3(K，c) | 7(K，c) | 2(K) | 7(K，c，a) | 8(K，c，b) |

因为，n-1 个顶点包含在 s 中。因此，我们找到了从 K 到所有其他顶点的最短距离。因此，K 和 L 之间的最短距离是 8，最短路径是 K，c，b，L。

* * *