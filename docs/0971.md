# LRU 和 LFU 页面替换算法的区别

> 原文:[https://www . javatpoint . com/LRU-vs-lfu-page-replacement-algorithm](https://www.javatpoint.com/lru-vs-lfu-page-replacement-algorithm)

在本文中，您将了解 LRU 和 LFU 页面替换算法之间的区别。但是在讨论差异之前，您需要了解 LRU 和 LFU 页面替换算法。

## 什么是 LRU 页面替换算法？

LRU 代表最近最少使用的 T1。它在短时间内跟踪内存中的页面使用情况。它基于这样一个概念，即过去被大量使用的页面在未来可能会再次被大量使用。它会删除内存中最长时间未被使用的页面。LRU 算法是使用最广泛的算法，因为它比其他方法提供更少的页面错误。

**示例:**

让我们使用下面的引用字符串来理解 LRU 页面替换算法。

**5 0 1 2 0 3 2 0 3 4 1 0 5 0 3 2 1 2 0 1**

查找使用 LRU 页面替换策略时页面错误的数量。此外，考虑页面框架大小为三。

**解决方案:**

参考字符串:

5 0 1 2 0 3 2 0 3 4 1 0 5 0 4 3 2 1 2 0 1

| 线 | five | Zero | one | Two | Zero | three | Two | Zero | three | four | one | Zero | five | Zero | four | three | Two | one | Two | Zero | one |
| **第 3 帧** |  |  | one | one | one | three | three | three | three | three | three | Zero | Zero | Zero | Zero | three | three | three | three | Zero | Zero |
| **第 2 帧** |  | Zero | Zero | Zero | Zero | Zero | Zero | Zero | Zero | Zero | one | one | one | one | four | four | four | one | one | one | one |
| 第 1 帧 | five | five | five | Two | Two | Two | Two | Two | Two | four | four | four | five | five | five | five | Two | Two | Two | Two | Two |
| **未命中/命中** | M | M | M | M | H | M | H | H | H | M | M | M | M | H | M | M | M | M | H | M | H |

**参考字符串总数= 21**

**页面错误或页面缺失总数= 14**

我们知道，

**页面点击总数=引用字符串总数-页面错误总数**

页面点击总数= 21 - 14 = 7

**页面错误概率=页面错误总数/引用字符串总数**

页面故障概率= 14/21 = 0.67

**页面错误百分比=页面错误总数/引用字符串总数* 100**

页面错误百分比= 14/21*100 = 67%

**说明:**

1.  首先，内存中有三个空帧。因此，当 5、0、1 进入帧时，它们按照到达的顺序被分配给空帧。发生页面错误是因为内存中没有 5、0、1。
2.  当 2 到来时，它不在内存中。因此，出现页面错误，它会替换最旧的第 5 页，这是最近使用最少的页面。
3.  当 0 出现时，它存在于内存中。因此，会发生页面命中，并且不会发生替换。
4.  当 3 来临时，它不存在于记忆中。因此，出现页面错误，它会替换最旧的页面 1，这是最近使用最少的页面。
5.  当 2，0，3 到来时，它就出现在记忆中。因此，会发生页面命中，并且不会发生替换。
6.  当 4 到来时，它不存在于记忆中。因此，出现页面错误，它将替换最近使用最少的页面第 2 页。
7.  当 1 出现时，它不在内存中。因此，出现页面错误，它会替换最旧的页面 0，这是最近使用最少的页面。
8.  当 0 出现时，它不在内存中。因此，出现页面错误，它会替换最旧的页面 3，这是最近使用最少的页面。
9.  当 5 到来时，它不存在于记忆中。因此，出现页面错误，它会替换最旧的页面 4，这是最近使用最少的页面。
10.  当 0 出现时，它存在于内存中。因此，会发生页面命中，并且不会发生替换。
11.  当 4 到来时，它不存在于记忆中。因此，出现页面错误，它会替换最旧的页面 1，这是最近使用最少的页面。
12.  当 3 来临时，它不存在于记忆中。因此，出现页面错误，它会替换最旧的页面 0，这是最近使用最少的页面。
13.  当 2 到来时，它不在内存中。因此，出现页面错误，它会替换最旧的第 5 页，这是最近使用最少的页面。
14.  当 1 出现时，它不在内存中。因此，出现页面错误，它会替换最旧的页面 4，这是最近使用最少的页面。
15.  当 2 到来时，它存在于记忆中。因此，会发生页面命中，并且不会发生替换。
16.  当 0 出现时，它不在内存中。因此，出现页面错误，它会替换最旧的页面 3，这是最近使用最少的页面。
17.  当 1 来临时，它存在于记忆中。因此，会发生页面命中，并且不会发生替换。

### LRU 页面替换算法的优缺点

LRU 页面替换算法有各种优点和缺点。这些优点和缺点如下:

**优势**

1.  LRU 没有遭受贝拉迪异常。
2.  主内存中使用时间最长的页面将被替换。
3.  它给出的页面错误比任何其他页面替换算法都少。所以，LRU 是最常用的方法。
4.  这是一个非常有效的算法。
5.  这有助于全面分析。

**缺点**

1.  它不容易实现，因为它需要硬件的帮助。
2.  它既昂贵又复杂。
3.  它需要一个额外的数据结构。

## 什么是 LFU 页面替换算法？

LFU 页面替换算法代表最少使用的**。在 LFU 页面替换算法中，给定时间段内访问量最少的页面将被删除。它会替换最不常用的页面。如果页面的频率保持不变，则最先出现的页面会被最先替换。**

 ****示例:**

让我们使用下面的引用字符串来理解 LFU 页面替换算法。

**7 0 2 4 3 1 4 2 0 4 3 3 2 7**

查找使用 LFU 页面替换策略时页面错误的数量。此外，考虑页面框架大小为三。

**解决方案:**

参考字符串:

7 0 2 4 3 1 4 7 2 0 4 3 0 3 2 7

| 线 | seven | Zero | Two | four | three | one | four | seven | Two | Zero | four | three | Zero | three | Two | seven |
| **第 3 帧** |  |  | Two | Two | Two | one | one | one | Two | Two | Two | three | three | three | three | three |
| **第 2 帧** |  | Zero | Zero | Zero | three | three | three | seven | seven | Zero | Zero | Zero | Zero | Zero | Two | seven |
| **第 1 帧** | seven | seven | seven | four | four | four | four | four | four | four | four | four | four | four | four | four |
| **未命中/命中** | M | M | M | M | M | M | H | M | M | M | H | M | H | H | M | M |

**参考字符串总数= 16**

**页面错误或页面缺失总数= 12**

我们知道，

**页面点击总数=引用字符串总数-页面错误总数**

页面点击总数= 16 - 12 = 4

**页面错误概率=页面错误总数/引用字符串总数**

页面故障概率= 12/16 = 0.75

**页面错误百分比=页面错误总数/引用字符串总数* 100**

页面错误百分比= 12/16*100 = 75%

**说明:**

1.  首先，内存中有三个空帧。因此，当 7、0、2 进入帧时，它们按照到达的顺序被分配给空帧。发生页面错误是因为内存中没有 7、0、2。
2.  当 4 到来时，它不存在于记忆中。因此，会出现页面错误，替换使用频率最低的页面 7。
3.  当 3 来临时，它不存在于记忆中。因此，会出现页面错误，替换使用频率最低的页面 0。
4.  当 1 出现时，它不在内存中。因此，会出现页面错误，替换使用频率最低的页面 2。
5.  当 4 来临时，它存在于记忆中。因此，会发生页面命中，并且不会发生替换。
6.  当 7 到来时，它不存在于记忆中。因此，出现页面错误，替换使用频率最低的页面 3。
7.  当 2 到来时，它不在内存中。因此，会出现页面错误，替换使用频率最低的页面 1。
8.  当 0 出现时，它不在内存中。因此，会出现页面错误，替换使用频率最低的页面 7。
9.  当 4 来临时，它存在于记忆中。因此，会发生页面命中，并且不会发生替换。
10.  当 3 来临时，它不存在于记忆中。因此，会出现页面错误，替换使用频率最低的页面 2。
11.  当 0，3 到来时，它就出现在记忆中。因此，会发生页面命中，并且不会发生替换。
12.  当 2 到来时，它不在内存中。因此，会出现页面错误，替换使用频率最低的页面 0。
13.  当 7 到来时，它不存在于记忆中。因此，会出现页面错误，替换使用频率最低的页面 2。

## LRU 和 LFU 页面替换算法的主要区别

![LRU vs LFU Page Replacement Algorithm](../Images/6229cf4ce0a83244a2caac3fc7d3af7b.png)

在这里，您将了解 LRU 和 LFU 页面替换算法之间的主要区别。LRU 和 LFU 页面替换算法之间的不同之处如下:

1.  LRU 代表最近最少使用的页面替换算法。相比之下，LFU 代表的是**最少使用的**页面替换算法。
2.  LRU 页面替换算法在短时间内跟踪内存中的页面使用情况。相比之下，在 LFU 页面替换算法中，给定时间段内访问量最少的页面将被删除。
3.  LRU 删除了最长时间没有在内存中使用的页面。相比之下，LFU 取代了最不常用的页面。

## LRU 和 LFU 页面替换算法的面对面比较

在这里，您将学习 LRU 和 LFU 页面替换算法之间的面对面比较。LRU 和 LFU 页面替换算法的主要区别如下:

| LRU 页面替换算法 | LFU 页面替换算法 |
| LRU 代表最近最少使用的页面替换算法。 | LFU 代表最少使用的页面替换算法。 |
| 它会删除最长时间没有在内存中使用的页面。 | 它会替换最不常用的页面。 |
| 它在短时间内跟踪内存中的页面使用情况。 | 在 LFU 页面替换算法中，给定时间段内访问量最少的页面将被删除。 |

* * ***