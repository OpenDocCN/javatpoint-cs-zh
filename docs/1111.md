# TCP 重传

> 原文:[https://www.javatpoint.com/tcp-retransmission](https://www.javatpoint.com/tcp-retransmission)

TCP 重传意味着通过网络重新发送丢失或损坏的数据包。这里，重传是 [TCP](https://www.javatpoint.com/tcp) 等协议用来提供可靠通信的机制。这里，可靠的通信意味着即使数据包丢失或损坏，协议也能保证数据包的传送。

网络不可靠，不能保证丢失或损坏的数据包的延迟或重新传输。使用确认和重传受损或丢失数据包相结合的网络提供了可靠性。

### 重传机制

这里，重传意味着数据分组已经丢失，这导致缺少确认。缺少确认会触发定时器超时，从而导致数据包的重新传输。这里，定时器意味着如果在定时器到期之前没有接收到确认，则数据分组被重传。

**我们来考虑以下重传的场景。**

**场景 1:数据包丢失或出错时。**

![TCP Retransmission](../Images/462f5590bdab724decc4f3b2b23388b8.png)

在这种情况下，数据包被发送到接收器，但在超时期限内没有收到确认。当超时时间到期时，数据包将再次发送。当分组被重传时，接收到确认。一旦收到确认，就不会再发生重传。

**场景 2:收到数据包但确认丢失。**

![TCP Retransmission](../Images/7df64c8692893ece9b855450d8c2084f.png)

在这种情况下，数据包在另一端被接收，但确认丢失，即发送方没有收到确认。一旦超时，数据包将被重新发送。另一边有两个数据包的副本；尽管数据包被正确接收，但没有收到确认，因此发送方会重新发送数据包。在这种情况下，可以避免重传，但是由于丢失了确认，分组被重传。

**场景三:发生提前超时的时候。**

![TCP Retransmission](../Images/4676e379a4c60d42e60fa81d486b5d54.png)

在这种情况下，分组被发送，但是由于在实际超时之前发生了确认延迟或超时，分组被重发。在这种情况下，由于确认延迟或超时设置早于实际超时，数据包被不必要地再次发送。

在上述场景中，第一个场景无法避免，但其他两个场景可以避免。让我们看看如何避免这些情况。

**发件人要等多久？**

**发送方设置确认的超时时间。超时时间可以有两种类型:**

*   **太短:**如果超时时间太短，则重传将被浪费。
*   **太长:**如果超时时间太长，那么数据包丢失时会有过大的延迟。

为了克服上述两种情况，  将超时设置为 RTT(往返时间)的函数，其中往返时间是数据包从源传输到目的地然后再返回所需的时间。

**如何才能获得 RTT？**

RTT 可能因网络特征而异，即如果网络拥塞，则意味着 RTT 非常高。我们可以通过简单地观察卫星来估计 RTT。

让我们看看如何测量 RTT。

我们将使用**原始算法**来测量 RTT。

**第一步:**首先，我们测量每个段或 ACK 对的**样本时间**。当发送方发送数据包时，我们知道发送数据包的计时器，也知道接收确认的计时器。计算这两者之间的时间，这就变成了**采样时间**。

**第二步:**我们不会只取一个样本。我们将继续采集不同的样本，并计算这些样本的加权平均值，这就成为估计 RTT。

**其中，α+ β = 1**

**α介于 0.8 和 0.9 之间**

**β介于 0.1 和 0.2 之间**

**第三步:**超时基于 EstRTT 设置。

**超时= 2 *挤压。**

超时设置为估计 RTT 的两倍。这是实际超时因子的计算方法。

**这种方法的一个缺陷**

**原算法有缺陷。让我们考虑两种情况。**

**场景一。**

![TCP Retransmission](../Images/c3613ba5d71ccec312d4908cc2f3addf.png)

上图显示发送方发送数据，据说是原始传输。在超时期限内，没有收到确认。因此，发送方会重新传输数据。重传数据后，会收到确认。让我们假设收到的确认是原始传输，而不是重传。因为我们得到了原始传输的确认，所以**采样时间**是在原始传输的时间和接收到确认的时间之间计算的。但是实际上，**采样时间**应该在重传时间和确认时间之间。

**场景二。**

![TCP Retransmission](../Images/a56e291a58bb05090a1977c469d94516.png)

上图显示发送方发送原始数据包，我们也收到了确认。但是在重传数据后收到确认。如果我们假设确认属于重传，则在重传时间和确认时间之间计算**采样时间**。

在上述两种情况下，都存在不知道确认是用于原始传输还是用于重传的模糊性。

**上述算法的结论。**

*   这里，确认并不意味着确认传输，但实际上，它确认数据的接收。
*   如果我们考虑第一种情况，将对丢失的数据包进行重传。在这种情况下，我们假设确认属于原始传输，因此样本量非常大。
*   如果我们考虑第二种情况，两个相同的数据包被发送，因此在这种情况下会发生欺骗。在这种情况下，我们假设确认属于重传，因此样本变得非常小。

为了克服上述问题，卡尔恩/帕特里奇算法给出了一个简单的解决方案。该算法给出了一个简单的解决方案，即收集一次发送的样本，并且在计算估计的 RTT 时不考虑重发时的样本。

### 卡尔恩/帕特里奇算法

在上面两个场景中，发生了重传，我们考虑了样本 RTT。但是该算法在重传时没有考虑样本 RTT。因为重传已经发生，这意味着在这个往返时间内发生了一些事情，或者网络中可能发生一些拥塞。为了克服这个问题，该算法在每次重传后将超时加倍。该算法是在 TCP 网络中实现的。

**限制**

**不考虑 RTT 的方差。**

*   **如果方差很小，估计出来就是准确的。如果方差很大，估计值就不准确。**

为了克服上述限制，开发了雅各布森/卡雷尔算法，该算法在 RTT 引入了方差因子。

**雅各布森/卡雷尔算法**

该算法是为了克服**卡尔恩/帕特里奇**算法的局限性而开发的。它计算采样点和估计点之间的差值，并根据差值提升 RTT。

平均 RTT 的计算

*   首先，我们计算差异因子。

**diff = sample RTT-estimated TT**

*   现在，我们计算估计值，它将以与上面相同的方式计算。

**EstRTT = EstRTT + (δ*Diff)**

*   现在，我们计算差因子的平均值。

**Dev = Dev + δ ( |Diff| - Dev)**

这里，Dev 是一个偏差因子，δ是一个介于 0 和 1 之间的因子。 **Dev** 是对**estrett**方差的估计。

*   我们将在计算超时值时考虑方差。

Timeout = µ * EstRTT + ɸ * Dev

其中， **=1，ɸ =4**

### 快速重传

基于超时的重传策略效率低下。TCP 是一种滑动窗口协议，因此每当发生重传时，它都会从丢失的数据包开始向前发送。

![TCP Retransmission](../Images/7f2bfdb800526b104dea2a31eba25a4f.png)

假设我传输数据包 0、1、2 和 3。由于数据包 0 和数据包 1 是在另一端接收的，因此数据包 2 会在网络中丢失。我已经收到了包 0 和包 1 的确认，所以我再发送两个包，即包 4 和包 5。当发送数据包 3、4 和 5 时，我将获得数据包 1 的确认，因为 TCP 确认是累积的，所以它会按顺序确认收到的数据包。在超时期限内，我没有收到数据包 2、3、4 和 5 的确认，因此我重新发送了数据包 2、3、4 和 5。由于分组 2 丢失，但是其他分组，即 3、4、5 在另一侧被接收，由于这种超时机制，它们仍然被重传。

**如何消除这种超时低效？**

滑动窗口下更好的解决方案:

假设 n 个分组已经丢失，但是仍然接收到分组 n+1、n+2 等等。接收器持续接收数据包并发送确认数据包，表示接收器仍在等待第 n 个数据包。接收方正在发送重复或重复的确认。在上述情况下，分组 1 的确认被发送三次，因为分组 2 已经丢失。这个重复的确认包是第 n 个包丢失的指示，但是后面的包被接收。

上述情况可以通过以下方式解决:

*   发送方可以将“重复确认”作为第 n 个分组已经丢失的早期提示，以便发送方可以尽可能早地进行重传，即发送方不应该等到超时发生。
*   发送方可以在 TCP 中实现快速传输策略。在快速传输策略中，发送方应该将三重重复确认视为触发并重新发送。

TCP 使用三个重复的确认作为触发，然后执行重传。在上述情况下，当接收到包 1 的三个 ack 时，则发送者应该发送丢失的包，即包 2，而不等待超时周期的出现。

* * *