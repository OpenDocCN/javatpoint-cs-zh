# 分割

> 原文:[https://www.javatpoint.com/os-segmentation](https://www.javatpoint.com/os-segmentation)

在操作系统中，分段是一种内存管理技术，其中内存被分成大小可变的部分。每个部分都被称为一个可以分配给一个进程的段。

每个段的详细信息存储在一个名为段表的表中。段表存储在一个(或多个)段中。

段表主要包含关于段的两个信息:

1.  基址:它是段的基址
2.  极限:是线段的长度。

## 为什么需要细分？

到目前为止，我们使用分页作为我们的主要内存管理技术。分页更接近操作系统，而不是用户。它将所有的进程划分为页面的形式，而不管一个进程可以有一些需要在同一个页面中加载的函数的相关部分。

操作系统不关心用户对过程的看法。它可以将相同的功能分成不同的页面，这些页面可以同时加载到内存中，也可以不加载。它降低了系统的效率。

最好进行分段，将流程分成几个部分。每个段包含相同类型的函数，例如主函数可以包含在一个段中，库函数可以包含在另一个段中。

![os Segmentation](../Images/3720db49f903358bf2d82708a38f6c9a.png)

## 通过段表将逻辑地址转换为物理地址

中央处理器生成一个包含两部分的逻辑地址:

1.  段号
2.  抵消

**例如:**

假设使用 16 位地址，4 位用于段号，12 位用于段偏移，因此最大段大小为 4096，可引用的最大段数为 16。

当一个程序被加载到内存中时，分段系统试图定位足够大的空间来容纳进程的第一个段，空间信息从内存管理器维护的空闲列表中获得。然后它会尝试为其他片段定位空间。一旦为所有片段找到足够的空间，它就会将它们加载到各自的区域。

操作系统还为每个程序生成一个段映射表。

![os Segmentation](../Images/ad6b28177b56e9c0aad1d706bc253353.png)

借助于段映射表和硬件辅助，操作系统可以在执行程序时轻松地将逻辑地址转换为物理地址。

**段号**映射到段表。将各个段的极限与偏移量进行比较。如果偏移量小于限制，则该地址有效，否则它会抛出一个错误，因为该地址无效。

在有效地址的情况下，段的基址被加到偏移量上，以获得主存储器中实际字的物理地址。

上图显示了在分段的情况下如何进行地址转换。

## 细分的优势

1.  没有内部碎片
2.  平均段大小大于实际页面大小。
3.  开销更少
4.  重新定位段比重新定位整个地址空间更容易。
5.  与分页中的页表相比，段表的大小较小。

## 不足之处

1.  它可以有外部碎片。
2.  很难将连续内存分配给可变大小的分区。
3.  昂贵的内存管理算法。

* * *