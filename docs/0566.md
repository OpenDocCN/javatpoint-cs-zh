# 稀疏矩阵

> 原文:[https://www.javatpoint.com/sparse-matrix](https://www.javatpoint.com/sparse-matrix)

在本文中，我们将讨论稀疏矩阵。

让我们首先看一下矩阵的简要描述。

### 什么是矩阵？

矩阵可以被定义为具有“m”行和“n”列的二维阵列。有 m 行 n 列的矩阵叫做 m n 矩阵。它是一组排列在条目的水平线或垂直线中的数字。

例如-

![Sparse Matrix](../Images/a11bb187e96625f77aea144e82a3c335.png)

### 什么是稀疏矩阵？

稀疏矩阵是那些大部分元素等于零的矩阵。换句话说，稀疏矩阵可以被定义为具有比非零元素更多的零元素的矩阵。

现在，问题出现了:我们也可以用简单的矩阵来存储元素，那么为什么需要稀疏矩阵呢？

### 如果我们可以用简单矩阵存储元素，为什么需要稀疏矩阵？

使用稀疏矩阵有以下好处-

**存储-** 我们知道稀疏矩阵包含的非零元素比零少，因此可以使用更少的内存来存储元素。它只计算非零元素。

**计算时间:**在稀疏矩阵中搜索的情况下，我们只需要遍历非零元素，而不是遍历所有稀疏矩阵元素。它通过逻辑设计遍历非零元素的数据结构来节省计算时间。

## 稀疏矩阵的表示

现在，让我们看看稀疏矩阵的表示。稀疏矩阵中的非零元素可以使用行、列和值的三元组来存储。稀疏矩阵有两种表示方法，如下所示-

*   数组表示
*   链表表示

**稀疏矩阵的数组表示**

用 2D 阵列表示稀疏矩阵会导致大量内存的浪费。这是因为矩阵中的零没有用，所以用非零元素存储零是对内存的浪费。为了避免这种浪费，我们只能存储非零元素。如果我们只存储非零元素，就会减少遍历时间和存储空间。

在稀疏矩阵的 2D 阵列表示中，使用了三个字段，命名为-

![Sparse Matrix](../Images/bff3d40322734e99cfbcbe075ecf27db.png)

*   **Row -** 是矩阵中非零元素所在行的索引。
*   **列-** 是矩阵中非零元素所在列的索引。
*   **值-** 位于索引处(行、列)的非零元素的值。

**示例-**

让我们借助下面给出的例子来理解稀疏矩阵的数组表示

考虑稀疏矩阵-

![Sparse Matrix](../Images/72fbd2b2154213fd0f824cab30566487.png)

在上图中，我们可以观察到一个包含 7 个非零元素和 13 个零元素的 5x4 稀疏矩阵。上面的矩阵占用 5x4 = 20 的内存空间。增加矩阵的大小会增加浪费的空间。

上述矩阵的表格表示如下-

![Sparse Matrix](../Images/c67bd47bc1f587f8684f759d82a9f5a7.png)

在上面的结构中，第一列代表行，第二列代表列，第三列代表非零值。表格的第一行代表三个单词。第一个三元组表示值 4 存储在第 0 行第 1 列。类似地，第二个三元组表示值 5 存储在第 0 行和第 3 列。以类似的方式，所有三元组表示非零元素在矩阵中的存储位置。

表的大小取决于给定稀疏矩阵中非零元素的总数。上表占用了 8x3 = 24 的内存空间，比稀疏矩阵占用的空间还多。那么，使用稀疏矩阵有什么好处呢？考虑这样的情况:如果矩阵是 8*8，并且矩阵中只有 8 个非零元素，那么稀疏矩阵占用的空间将是 8*8 = 64，而使用三元组表示的表占用的空间将是 8*3 = 24。

### 稀疏矩阵数组表示的实现

现在，让我们看看稀疏矩阵的数组表示在 C 语言中的实现。

在下面的程序中，我们将显示存储在数组中的稀疏矩阵的非零元素的表格表示。

```

#include <stdio.h>
int main()
{
    // Sparse matrix having size 4*5
    int sparse_matrix[4][5] =
    {
        {0 , 0 , 6 , 0 , 9 },
        {0 , 0 , 4 , 6 , 0 },
        {0 , 0 , 0 , 0 , 0 },
        {0 , 1 , 2 , 0 , 0 }
    };
   // size of matrix
    int size = 0;
    for(int i=0; i<4; i++)
    {
        for(int j=0; j<5; j++)
        {
            if(sparse_matrix[i][j]!=0)
            {
                size++;
            }
        }
    }
   // Defining final matrix
    int matrix[3][size]; 
     int k=0;
   // Computing final matrix
    for(int i=0; i<4; i++)
    {
        for(int j=0; j<5; j++)
        {
            if(sparse_matrix[i][j]!=0)
            {
                matrix[0][k] = i;
                matrix[1][k] = j;
                matrix[2][k] = sparse_matrix[i][j];
                k++;
            }
      }
    }
   // Displaying the final matrix
    for(int i=0 ;i<3; i++)
    {
        for(int j=0; j<size; j++)
        {
            printf("%d ", matrix[i][j]);
            printf("\t");
        }
        printf("\n");
    }
    return 0;
}

```

**输出**

在输出中，表的第一行表示值的行位置，第二行表示值的列位置，第三行表示值本身。

在下面的截图中，值为 0、2 和 6 的第一列代表存储在第 0<sup>行和第 2 <sup>第</sup>列的值 6。</sup>

![Sparse Matrix](../Images/332f7273f1e381da01f30e3317731e2c.png)

## 稀疏矩阵的链表表示

在链表表示中，链表数据结构用于表示稀疏矩阵。使用链表来表示稀疏矩阵的优点是，在链表中插入或删除节点的复杂度小于数组。

与数组表示不同，链表表示中的节点由四个字段组成。链表的四个字段如下-

*   **Row -** 表示非零元素所在行的索引。
*   **列-** 表示非零元素所在列的索引。
*   **值-** 位于索引处(行、列)的非零元素的值。
*   **下一个节点-** 存储下一个节点的地址。

稀疏矩阵的链表表示的节点结构如下图所示-

![Sparse Matrix](../Images/e03bad63b296ccca711bd193b066f543.png)

**示例-**

让我们借助下面给出的例子来理解稀疏矩阵的链表表示

考虑稀疏矩阵-

![Sparse Matrix](../Images/6629f0ed64b84225d3706e4a9180a9a7.png)

在上图中，我们可以观察到一个包含 5 个非零元素和 11 个零元素的 4x4 稀疏矩阵。上面的矩阵占用 4x4 = 16 的内存空间。增加矩阵的大小会增加浪费的空间。

上述矩阵的链表表示如下-

![Sparse Matrix](../Images/0361d0b2989d8214e03ba22a085b4ebf.png)

在上图中，稀疏矩阵以链表的形式表示。在节点中，第一个字段代表行的索引，第二个字段代表列的索引，第三个字段代表值，第四个字段包含下一个节点的地址。

在上图中，链表第一个节点的第一个字段包含 0，表示 0 <sup>第</sup>行，第二个字段包含 2，表示 2 <sup>第</sup>列，第三个字段包含 1，为非零元素。因此，第一个节点表示元素 1 存储在给定稀疏矩阵的第 0 <sup>行第</sup>行第 2 <sup>列第</sup>列。以类似的方式，所有节点代表稀疏矩阵的非零元素。

### 稀疏矩阵链表表示的实现

现在，让我们看看稀疏矩阵的链表表示在 Java 中的实现。

```

class Node {
int row;
int col;
int value;
Node next;
Node(int r, int c, int val) 
{ row = r; col = c; this.value = val; }
}
public class Sparse{
public static void main(String[] args)
{
/*Assume a 4x4 sparse matrix */
int sparseMatrix[][] = {
{0, 0, 1, 2},
{3, 0, 0, 0},
{0, 4, 5, 0},
{0, 6, 0, 0}
};
Node start = null; /*Start with the empty list*/
Node tail = null;
int k = 0;
for (int i = 0; i < 4; i++)
for (int j = 0; j < 4; j++)
{
if (sparseMatrix[i][j] != 0) /*Pass only non-zero values*/
{
Node temp = new Node(i, j, sparseMatrix[i][j]);
temp.next = null;
if(start == null){
start = temp;
tail=temp;
}
else{
tail.next = temp;
tail = tail.next;
}
}
}
Node itr = start;
while(start != null){
System.out.println(start.row  + " " + start.col + " " + start.value);
start = start.next;
}
}
}

```

**输出**

输出中的每一行都代表链表的节点。在下面截图的每一行中，第一个元素代表非零元素的行索引位置，第二个元素代表非零元素的列索引位置，第三个元素代表非零元素本身。

![Sparse Matrix](../Images/f541cadf50af18216b5fbd5cffc8075a.png)

所以，这就是文章的全部内容。在本文中，我们首先讨论了矩阵和稀疏矩阵的简要描述。之后，我们看到了为什么稀疏矩阵是有用的，最后，我们讨论了稀疏矩阵的数组和链表表示。希望，文章会对你有所帮助和启发。

* * *