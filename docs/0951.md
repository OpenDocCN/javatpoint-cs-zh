# 互斥体与信号量

> 原文:[https://www.javatpoint.com/mutex-vs-semaphore](https://www.javatpoint.com/mutex-vs-semaphore)

按照操作系统术语，互斥体和信号量是提供同步服务的内核资源，也称为 ***同步原语*** 。进程同步在维护共享数据的一致性方面起着重要的作用。软件和硬件解决方案都用于处理关键部分的问题。但是关键部分问题的硬件解决方案很难实现。互斥体和信号量都提供同步服务，但是它们不一样。

### 什么是互斥？

Mutex 是一个互斥对象，用于同步对资源的访问。它是在程序开始时用一个唯一的名称创建的。互斥锁机制确保只有一个线程可以获取互斥锁并进入临界区。这个线程只有在关键部分退出时才会释放互斥体。

![Mutex vs Semaphore](../Images/6b7b2e4eb2389bb901fbbb53fbea3dea.png)

它是一种特殊类型的二进制信号量，用于控制对共享资源的访问。它包括优先级继承机制，以避免扩展的优先级反转问题。它允许当前优先级较高的任务在尽可能短的时间内保持阻塞状态。然而，优先级继承并不能纠正优先级反转，而只能最小化其影响。

**例**

这是在以下示例的帮助下显示的，

```

wait (mutex);
.....
Critical Section
.....
signal (mutex);

```

### 互斥的使用

互斥体提供互斥，生产者或消费者可以拥有密钥(互斥体)并继续他们的工作。只要生产者填满缓冲区，用户就需要等待，反之亦然。在互斥锁中，始终只有一个线程可以使用整个缓冲区。

当一个程序启动时，它请求系统为给定的资源创建一个互斥对象。系统用唯一的名称或标识创建互斥对象。每当程序线程想要使用资源时，它占用互斥对象上的锁，利用资源，并在使用后释放互斥对象上的锁。然后允许下一个进程获取互斥对象的锁。

同时，一个进程已经获得了互斥对象的锁，没有其他线程或进程可以访问该资源。如果互斥对象已经被锁定，那么需要获取互斥对象锁的进程必须等待，并由系统排队，直到互斥对象被解锁。

### 互斥的优点

互斥体有以下优点，例如:

*   互斥只是简单的锁，在进入它的临界区之前获得，然后释放它。
*   由于在任何给定时间只有一个线程处于其关键部分，因此不存在竞争条件，数据始终保持一致。

### 互斥的缺点

互斥也有一些缺点，例如:

*   如果一个线程获得锁并进入睡眠或被抢占，那么另一个线程可能不会前进。这可能会导致饥饿。
*   不能从获取它的上下文之外的其他上下文锁定或解锁它。
*   关键部分一次只能允许一个线程。
*   正常实现可能会导致繁忙的等待状态，从而浪费 CPU 时间。

### 什么是信号量？

信号量只是一个非负变量，在线程间共享。信号量是一种信号机制，另一个线程可以向等待信号量的线程发出信号。

![Mutex vs Semaphore](../Images/0cbb2d6804be8b41920566270a71d797.png)

一个信号量使用两个原子操作，

**1。等待:**如果参数为正，则等待操作递减其参数的值。如果 S 为负或零，则不执行任何操作。

```

wait(S)
{
   while (S<=0);
   S--;
}

```

**2。进程同步信号:**信号操作增加其参数 s 的值

```

signal(S)
{
   S++;
}

```

信号量允许或拒绝对资源的访问，这取决于它是如何设置的。

### 信号量的使用

在单个缓冲区的情况下，我们可以将 4 KB 缓冲区分成 4kb 的四个缓冲区。信号量可以与这四个缓冲区相关联，允许用户和生产者同时在不同的缓冲区上工作。

### 信号量的类型

操作系统将信号量分为两类**计数信号量**和**二进制信号量**。

**1。计数信号量:**信号量 S 值被初始化为系统中存在的**资源数量**。每当进程想要访问资源时，它对信号量执行**等待()**操作，并将信号量值减 1。当它释放资源时，它对信号量执行**信号()**操作，**将信号量值增加 1。**

当信号量计数变为 0 时，意味着进程占用了所有资源。当信号量计数为 0 时，进程需要使用资源。它执行 **wait()** 操作并使**阻塞**，直到信号量值变得大于 0。

![Mutex vs Semaphore](../Images/6bd01077e6e72d8e8e89736c9ea205e5.png)

**2。二进制信号量:**信号量的值介于 **0** 和 **1** 之间。它类似于互斥锁，但是互斥是一种锁定机制，而信号量是一种信号机制。在二进制信号量中，如果进程想要访问资源，它会对信号量执行**wait()**操作，并将信号量的值从 1 递减到 0。当它释放资源时，它对信号量执行**信号** **()** 操作，并将其值增加到 1。假设信号量的值为 0，并且一个进程想要访问资源。在这种情况下，它执行 **wait()** 操作并阻塞自身，直到当前使用资源的进程释放资源。

![Mutex vs Semaphore](../Images/98d36c557da40ff156544c7b07d20b21.png)

### 信号量的优势

以下是信号量的优点，例如:

*   它允许多个线程访问临界区。
*   信号量是独立于机器的。
*   信号量在微内核的机器无关代码中实现。
*   它们不允许多个进程进入关键部分。
*   因为信号量中有繁忙和等待，所以永远不会浪费处理时间和资源。
*   它们是独立于机器的，应该在微内核的独立于机器的代码中运行。
*   它们允许灵活管理资源。

### 信号量的缺点

信号量也有一些缺点，例如:

*   信号量最大的限制之一是优先级反转。
*   操作系统必须跟踪所有等待的调用并发出信号。
*   它们的使用从未被强制执行，但这只是惯例。
*   等待和信号操作需要以正确的顺序执行，以避免信号量中的死锁。
*   信号量编程是一种复杂的方法，因此有可能无法实现互斥。
*   这也不是大规模使用的实用方法，因为它们的使用会导致模块性的丧失。
*   信号量更容易出现程序员错误
*   ，它可能会由于程序员错误而导致死锁或违反互斥。

### 互斥和信号量的区别

信号量和互斥量的基本区别在于信号量是一种信令机制，即进程执行 wait()和 signal()操作来指示它们是获取还是释放资源。相反，互斥是一种锁定机制，如果进程想要获取资源，它必须获取互斥对象的锁。信号量和互斥量之间还有一些不同，例如:

![Mutex vs Semaphore](../Images/7fdfdc9b6ed70bc152f7a2160425e7d3.png)

| 条款 | 互斥（体）… | 旗语 |
| 定义 | 互斥是一种锁定机制，当获取资源时，进程需要锁定互斥对象，而释放资源时，进程必须解锁互斥对象。 | 信号量是一种信令机制，因为对信号量变量执行的 wait()和 signal()操作指示进程是获取还是释放资源。 |
| 存在 | 互斥体是一个对象。 | 信号量是一个整数变量。 |
| 功能 | 互斥体允许多个程序线程访问单个资源，但不能同时访问。 | 信号量允许多个程序线程访问有限的资源实例。 |
| 所有权 | 互斥对象锁仅由获得互斥对象锁的进程释放。 | 任何进程都可以通过执行 wait()和 signal()操作来获取或释放资源，从而更改信号量值。 |
| 将…进行分类 | 互斥体没有进一步分类。 | 信号量可以分为计数信号量和二进制信号量。 |
| 操作 | 互斥对象被请求或释放资源的过程锁定或解锁。 | 除初始化之外，信号量值使用 wait()和 signal()操作进行修改。 |
| 占用的资源 | 如果一个互斥对象已经被锁定，那么想要获取资源的进程等待，并被系统排队，直到资源被释放，互斥对象被解锁。 | 假设进程获取了所有的资源，没有一个资源是空闲的。在这种情况下，希望获取资源的进程对信号量变量执行 wait()操作，并阻塞自身，直到信号量的计数变得大于 0。 |

* * *