# DS 算法

> 原文:[https://www.javatpoint.com/data-structure-algorithm](https://www.javatpoint.com/data-structure-algorithm)

## 什么是算法？

算法是执行计算或某些其他问题解决操作(尤其是由计算机执行)所需的过程或一组规则。算法的正式定义是，它包含有限的指令集，这些指令集以特定的顺序执行特定的任务。它不是完整的程序或代码；它只是一个问题的解决方案(逻辑)，可以用流程图或伪代码的非正式描述来表示。

### 一种算法的特征

**算法的特征如下:**

*   **输入:**算法有一些输入值。我们可以将 0 或一些输入值传递给算法。
*   **输出:**我们将在一个算法结束时得到 1 个或更多的输出。
*   **Unambiguity:** 一个算法应该是不含糊的，这意味着一个算法中的指令应该是清晰简单的。
*   **有限性:**算法要有有限性。这里，有限性意味着算法应该包含有限数量的指令，即指令应该是可计数的。
*   **有效性:**算法应该是有效的，因为算法中的每一条指令都会影响整个过程。
*   **语言无关:**算法必须是语言无关的，这样算法中的指令就可以用任何一种具有相同输出的语言来实现。

### 算法的数据流

*   **问题:**问题可以是现实世界的问题，也可以是现实世界问题的任何实例，我们需要为其创建程序或指令集。这组指令被称为算法。
*   **算法:**将为一个问题设计一个算法，这是一个逐步的过程。
*   **输入:**设计算法后，将所需和期望的输入提供给算法。
*   **处理单元:**输入将被给予处理单元，处理单元将产生期望的输出。
*   **输出:**输出是程序的结果或结果。

### 为什么我们需要算法？

**我们需要算法是因为以下原因:**

*   **可扩展性:**帮助我们了解可扩展性。当我们遇到一个现实世界的大问题时，我们需要把它缩小成小步骤，以便轻松地分析问题。
*   **性能:**现实世界不容易分解成更小的台阶。如果问题可以很容易地分解成更小的步骤，就意味着这个问题是可行的。

让我们通过一个真实的例子来理解这个算法。假设我们想制作柠檬汁，那么制作柠檬汁的步骤如下:

第一步:首先，我们将柠檬切成两半。

第二步:尽可能多地挤压柠檬，并在容器中取出它的汁液。

第三步:加入两汤匙糖。

第四步:搅拌容器，直到糖溶解。

第五步:当糖溶解时，加入一些水和冰。

第六步:将果汁在冰箱里储存 5 到 10 分钟。

第七步:现在，它可以喝了。

以上现实世界可以直接对比算法的定义。我们不能在步骤 2 之前执行步骤 3，我们需要按照特定的顺序来制作柠檬汁。一个算法还说，每一条指令都应该按照特定的顺序执行特定的任务。

现在我们来看一个编程算法的例子。

我们将编写一个算法，将用户输入的两个数字相加。

**以下是用户输入的两个数字相加所需的步骤:**

第一步:开始

第二步:声明三个变量 a、b 和 sum。

第三步:输入 a 和 b 的值

第四步:将 a 和 b 的值相加，并将结果存储在 sum 变量中，即 sum=a+b。

第五步:打印总和

停止

### 算法的因素

**以下是我们设计算法需要考虑的因素:**

*   **模块化:**如果给定了任何一个问题，我们可以把那个问题分解成小-小模块或者小-小步骤，这是一个算法的基本定义，意味着这个特性已经为算法完美设计好了。
*   **正确性:**一个算法的正确性定义为当给定的输入产生期望的输出时，这意味着该算法已经被设计成算法。对算法的分析是正确的。
*   **可维护性:**这里的可维护性是指算法要以非常简单的结构化方式进行设计，这样在我们重新定义算法的时候，就不会对算法做大的改动。
*   **功能性:**考虑解决现实问题的各种逻辑步骤。
*   **鲁棒性:**鲁棒性是指一个算法如何能够清晰地定义我们的问题。
*   **用户友好:**如果算法不用户友好，那么设计者就无法向程序员解释。
*   **简单性:**如果算法简单，那么很容易理解。
*   **扩展性:**如果任何其他算法设计者或程序员想要使用你的算法，那么它应该是可扩展的。

### 算法的重要性

1.  **理论重要性:**当任何现实世界的问题交给我们，我们把问题分解成一个个小模块。要分解这个问题，我们应该了解所有的理论方面。
2.  **实际重要性:**众所周知，理论离不开实际的实施。因此，算法的重要性可以从理论和实践两方面来考虑。

### 算法问题

**以下是设计算法时出现的问题:**

*   **如何设计算法:**我们知道算法是一个循序渐进的过程，所以我们必须遵循一些步骤来设计算法。
*   **如何分析算法效率**

### 算法途径

**以下是在考虑了设计算法的理论和实际重要性后使用的方法:**

*   **蛮力算法:**应用通用逻辑结构设计算法。它也被称为穷举搜索算法，搜索所有可能性以提供所需的解决方案。这种算法有两种类型:
    1.  **优化:**找到一个问题的所有解，然后取出最佳解，或者如果已知最佳解的值，那么如果已知最佳解，那么它将终止。
    2.  **牺牲:**一找到最优解，那么就停止。
*   **分而治之:**是一个算法的非常实现。它允许你设计一个逐步变化的算法。它分解算法，用不同的方法解决问题。它允许您将问题分解成不同的方法，并为有效的输入生成有效的输出。这个有效输出被传递给其他函数。
*   **贪婪算法:**是在每次迭代上做出最优选择，希望得到最优解的算法范式。它易于实现，执行时间更快。但是，在极少数情况下，它提供了最优解。
*   **动态规划:**通过存储中间结果使算法更高效。它遵循五个不同的步骤来寻找问题的最佳解决方案:
    1.  它把问题分解成一个子问题来寻找最优解。
    2.  分解问题后，它从这些子问题中找到最优解。
    3.  存储子问题的结果被称为记忆。
    4.  重用结果，这样就不能为相同的子问题重新计算结果。
    5.  最后，它计算复杂程序的结果。
*   **分支定界算法:**分支定界算法只能应用于整数规划问题。这种方法将所有可行解集合分成更小的子集。进一步评估这些子集以找到最佳解决方案。
*   **随机化算法:**正如我们在常规算法中看到的，我们有预定义的输入和所需的输出。那些具有某一组定义的输入和所需的输出，并遵循某些描述的步骤的算法被称为确定性算法。在随机化算法中引入随机变量会发生什么？。在随机化算法中，算法引入一些随机位，并将其添加到输入中以产生输出，该输出本质上是随机的。随机化算法比确定性算法更简单有效。
*   **回溯:**回溯是一种递归解决问题的算法技术，如果不满足问题的约束条件，则移除解决方案。

算法的主要类别如下:

*   **排序:**为按一定顺序对项目进行排序而开发的算法。
*   **搜索:**为搜索数据结构中的项目而开发的算法。
*   **删除:**为从数据结构中删除现有元素而开发的算法。
*   **插入:**为在数据结构中插入项目而开发的算法。
*   **更新:**为更新数据结构中的现有元素而开发的算法。

### 算法分析

算法可以分两个层次进行分析，即第一是创建算法之前，第二是创建算法之后。以下是对一个算法的两个分析:

*   先验分析:这里，先验分析是对算法的理论分析，是在实现算法之前完成的。在实现算法之前可以考虑各种因素，比如处理器速度，对实现部分没有影响。
*   后验分析:这里的后验分析是对一个算法的实际分析。实际分析是通过使用任何编程语言实现算法来实现的。这个分析基本上是评估算法占用了多少运行时间和空间。

### 算法复杂性

算法的性能可以用两个因素来衡量:

*   **时间复杂度:**算法的时间复杂度是完成执行所需的时间量。算法的时间复杂度用大 O 符号表示。这里，大 O 符号是表示时间复杂度的渐近符号。时间复杂度主要通过计算完成执行的步骤数来计算。让我们通过一个例子来理解时间的复杂性。

```

sum=0;
// Suppose we have to calculate the sum of n numbers.
for i=1 to n
sum=sum+i;
// when the loop ends then sum holds the sum of the n numbers
return sum;

```

在上面的代码中，循环语句的时间复杂度至少为 n，如果 n 的值增加，那么时间复杂度也会增加。而代码的复杂性，即返回和将是恒定的，因为它的值不依赖于 n 的值，并且将只在一个步骤中提供结果。我们通常考虑最坏时间复杂度，因为它是任何给定输入大小所花费的最大时间。

*   **空间复杂度:**算法的空间复杂度是解决一个问题并产生一个输出所需的空间量。与时间复杂度类似，空间复杂度也用大 O 符号表示。

对于算法，空间需要用于以下目的:

1.  存储程序指令
2.  存储常量值
3.  存储变量值
4.  跟踪函数调用、跳转语句等。

辅助空间:算法所需的额外空间，不包括输入大小，称为辅助空间。空间复杂度考虑了空间(即辅助空间)和输入使用的空间。

所以，

**空间复杂度=辅助空间+输入大小。**

### 算法的类型

**以下是算法类型:**

*   **搜索算法**
*   **排序算法**

**搜索算法**

每天，我们在日常生活中寻找一些东西。类似地，就计算机而言，巨大的数据存储在计算机中，每当用户要求任何数据时，计算机就在存储器中搜索该数据，并将该数据提供给用户。主要有两种技术可用于搜索数组中的数据:

*   **线性搜索**
*   **二分搜索法**

**线性搜索**

线性搜索是一种非常简单的算法，它从数组的开头开始搜索元素或值，直到找不到所需的元素。它将待搜索的元素与数组中的所有元素进行比较，如果找到匹配项，则返回该元素的索引，否则返回-1。该算法可以在未排序的列表上实现。

**二分搜索法**

二进制算法是搜索元素非常快速的最简单的算法。它用于从排序列表中搜索元素。元素必须以顺序或排序的方式存储，以实现二进制算法。如果元素以随机方式存储，则无法实现二分搜索法。它用于查找列表的中间元素。

### 排序算法

排序算法用于以升序或降序重新排列数组或给定数据结构中的元素。比较运算符决定元素的新顺序。

### 为什么我们需要一个排序算法？

*   需要一种高效的排序算法来优化其他算法(如二分搜索法算法)的效率，因为二分搜索法算法需要以特定的顺序(主要是升序)对数组进行排序。
*   它以排序的顺序产生信息，这是一种人类可读的格式。
*   在排序列表中搜索特定元素比在未排序列表中搜索更快。

* * *