# 实时系统中的任务

> 原文:[https://www.javatpoint.com/tasks-in-real-time-systems](https://www.javatpoint.com/tasks-in-real-time-systems)

**实时操作系统(RTOS)** 服务于处理数据而没有任何缓冲延迟的实时应用程序。在 RTOS，处理时间要求以十分之几秒的时间增量计算。这是一个有时间限制的系统，被定义为固定时间限制。在这种类型的系统中，处理必须在指定的约束内完成。否则，系统将失败。

***实时任务*** 是与时间的量化表达相关联的任务。这个时间的定量表达描述了实时任务的行为。实时任务被调度来完成它所涉及的所有计算事件，进入时间限制。与实时任务相关的时间限制是截止日期。所有的实时任务都需要在截止日期前完成。例如，与设备的输入输出交互、网页浏览等。

### 实时系统中的任务类型

实时系统中有以下类型的任务，例如:

![Tasks in Real-Time Systems](../Images/1e788aefd9b35cc7bfb93da190833f52.png)

**1。周期性任务**

在周期性任务中，作业会定期发布。定期任务在固定的时间间隔后重复进行。周期任务由五个元组表示:**T<sub>I</sub>=<φ<sub>I</sub>，P <sub>i</sub> ，e <sub>i</sub> ，D <sub>i</sub> >**

哪里，

*   **φ<sub>I</sub>:**是任务的阶段，阶段是任务中第一个作业的发布时间。如果没有提到阶段，那么假设第一个作业的发布时间为零。
*   **P <sub>i</sub> :** 是任务的周期，即两个连续作业的发布时间之间的时间间隔。
*   **e <sub>i</sub> :** 是任务的执行时间。
*   **D <sub>i</sub> :** 是任务的相对截止时间。

**例如:**考虑周期= 5、执行时间= 3 的任务 T <sub>i</sub>

阶段不是这样给定的，假设第一个作业的发布时间为零。所以这个任务的作业先在 t = 0 时释放，然后执行 3s，然后在 t = 5 时释放下一个作业，t = 5 时执行 3s，t = 10 时释放下一个作业。所以作业在 t = 5k 时释放，其中 k = 0，1。。。普通

![Tasks in Real-Time Systems](../Images/a34b198d132327dc234144240f86ff9e.png)

周期任务集合的超周期是该集合中所有任务的最小公倍数。例如，分别具有周期 4 和 5 的两个任务 T <sub>1</sub> 和 T <sub>2</sub> 将具有超周期，H = lcm(p1，p2) = lcm(4，5) = 20。超级周期是作业发布时间模式开始重复的时间。

**2。动态任务**

它是一个连续的程序，通过事件的发生来调用。事件可能由系统外部的进程或系统内部的进程生成。动态到达的任务可以根据其重要性和对其发生时间的了解进行分类。

1.  **非周期性任务:**在这种类型的任务中，作业以任意时间间隔发布。非周期性任务有软期限或没有期限。
2.  **零星任务:**类似于非周期性任务，即随机实例重复。唯一不同的是，零星的任务有严格的期限。三元组表示一个零星任务: **T <sub>i</sub> =(e <sub>i</sub> ，g <sub>i</sub> ，D <sub>i</sub> )**
    *   在哪里
    *   **e <sub>i</sub> :** 是任务的执行时间。
    *   **g <sub>i</sub> :** 是任务连续两个实例出现之间的最小间隔。
    *   **D <sub>i</sub> :** 是任务的相对截止时间。

**3。关键任务**

关键任务是那些及时执行非常关键的任务。如果错过最后期限，灾难就会发生。

例如，生命维持系统和飞机的稳定性控制。如果关键任务的执行频率更高，那么就有必要。

**4。非关键任务**

非关键任务是实时任务。顾名思义，它们对应用程序并不重要。然而，他们可以处理时间，不同的数据，因此，如果他们没有在最后期限内完成是没有用的。安排这些任务的目标是最大限度地提高任务在期限内成功执行的百分比。

### 任务调度

实时任务调度本质上是指确定操作系统如何选择执行各种任务。每个操作系统都依赖一个或多个任务调度器来准备运行所需的各种任务的执行时间表。每个任务调度器都以其采用的调度算法为特征。迄今为止，已经开发了大量用于实时调度任务的算法。

### 任务调度的分类

以下是实时系统中的任务调度类型，例如:

![Tasks in Real-Time Systems](../Images/f1151a8bb1ae0d79dbc74092b10d2647.png)

1.  **有效调度:**一组任务的有效调度是一次最多给一个处理器分配一个任务，在其到达时间之前不调度任何任务，并且满足所有任务的优先级和资源约束的调度。
2.  **可行日程:**只有当所有任务都满足日程中各自的时间限制时，有效的日程才称为可行日程。
3.  **精通调度器:**如果 S1 可以可行地调度 S2 可以可行地调度的所有任务集，那么任务调度器 S1 比另一个调度器 S2 更精通，但反之则不然。S1 可以可行地安排 S2 可以安排的所有任务集，但是至少有一个任务集 S2 不能可行地安排，而 S1 可以。如果 S1 能够可行地调度所有 S2 能够可行调度的任务集，反之亦然，那么 S1 和 S2 被称为同样熟练的调度者。
4.  **最优调度器:**实时任务调度器如果能够可行地调度任何其他调度器能够可行地调度的任何任务集，则称为最优调度器。换句话说，不可能找到比最优调度器更精通的调度算法。如果一个最佳调度程序不能调度某个任务集，那么其他调度程序就不应该为该任务集生成可行的调度。
5.  **调度点:**调度器的调度点是时间线上的点，在该点调度器决定下一步运行哪个任务。需要注意的是，任务调度器不需要连续运行，操作系统只在调度点激活它来决定下一步运行哪个任务。调度点被定义为由时钟驱动调度器中的周期定时器产生的中断所标记的时刻。某些事件的发生决定了事件驱动调度程序中的调度点。
6.  **抢占式调度器:**抢占式调度器是指当优先级较高的任务到达时，挂起任何可能正在执行的优先级较低的任务，并占用优先级较高的任务来执行。因此，在抢先调度器中，不可能出现较高优先级的任务准备好并等待执行，而较低优先级的任务正在执行的情况。被抢占的低优先级任务只有在没有高优先级任务准备就绪时才能继续执行。
7.  **利用率:**任务的处理器利用率(或简称为利用率)是任务在单位时间间隔内执行的平均时间。在符号中:
    对于周期任务 Ti，利用率 ui = ei/pi，其中
    对于一组周期任务{Ti}:所有任务的总利用率 U = i=1∑ n ei/pi。
    任何好的调度算法的目标都是可行地调度那些利用率非常高的任务集，即利用率接近 1 的任务集。当然，在单处理器上，不可能调度利用率超过 1 的任务集。
    *   ei 是执行时间
    *   圆周率是钛的周期。
8.  **抖动**
    抖动是周期性任务与其严格周期性行为的偏差。到达时间抖动是任务与精确的周期性到达时间的偏差。它可能是由不精确的时钟或其他因素(如网络拥塞)引起的。类似地，完成时间抖动是任务完成与精确周期点的偏差。
    完成时间抖动可能是由所采用的特定调度算法引起的，该算法在某一时刻根据便利性和负载占用任务进行调度，而不是在某些严格的时刻进行调度。抖动对于某些应用来说是不可取的。
    有时一项工作的实际发布时间是未知的。只知道 r <sub>i</sub> 在一个范围内【r <sub>i</sub> -，r <sub>i</sub> +】。这个范围被称为释放时间抖动。这里只知道作业执行时间的范围[ei-，e <sub>i</sub> +]。这里
    *   r <sub>i</sub> 是作业可以多早发布，
    *   r <sub>i</sub> +是作业可以发布到多晚。Only the range [ei-, e
    *   e <sub>i</sub> -是作业完成其执行所需的最短时间，
    *   e <sub>i</sub> +是作业完成其执行所需的最长时间。

### 作业的优先约束

如果任务中的作业可以以任何顺序执行，则它们是独立的。如果作业必须按特定的顺序执行，那么作业就被称为具有优先约束。为了表示作业的优先约束，偏序关系< is used, and this is called precedence relation. A job J <sub>i</sub> 是作业 J <sub>j</sub> 的前身，如果 J<sub>I</sub>T40】J<sub>J</sub>，即 J <sub>j</sub> 在 J <sub>i</sub> 完成之前不能开始执行。J <sub>i</sub> 是 J <sub>j</sub> 的直接前身如果 J<sub>I</sub>T41】J<sub>J</sub>，并且没有其他工作 J <sub>k</sub> 这样的 J<sub>I</sub>T42】J<sub>k</sub>T43】J<sub>J</sub>。如果 J<sub>I</sub>T44】J<sub>J</sub>J<sub>J</sub>T45 J<sub>I</sub>都不是真的，那么 J <sub>i</sub> 和 J <sub>j</sub> 是独立的。

表示优先约束的有效方法是使用有向图 G = (J， i 到 J <sub>j</sub> ，这意味着 J <sub>i</sub> 是 J <sub>j</sub> 的直接前身。

例如:考虑一个任务 T 有 5 个作业 J <sub>1</sub> 、J <sub>2</sub> 、J <sub>3</sub> 、J <sub>4</sub> 和 J <sub>5</sub> ，使得 J <sub>2</sub> 和 J <sub>5</sub> 在 J <sub>1</sub> 完成并且没有其他约束之前无法开始执行。本例的优先约束是:

J<sub>1</sub>T8】J<sub>2</sub>和 J<sub>1</sub>T9】J<sub>5</sub>

![Tasks in Real-Time Systems](../Images/35dee77ca4311443f333aafa6256b151.png)

优先图的集合表示:

1.  < (1) = { }
2.  < (2) = {1}
3.  < (3) = { }
4.  < (4) = { }
5.  < (5) = {1}

考虑另一个例子，给出了一个优先图，你必须找到优先约束。

![Tasks in Real-Time Systems](../Images/d5197570b0fe963c5f43bce629b21079.png)

从上图中，我们导出了以下优先约束:

1.  J<sub>1</sub>T4 J<sub>2</sub>
2.  J<sub>2</sub>T4 J<sub>3</sub>
3.  J<sub>2</sub>T4 J<sub>4</sub>
4.  J<sub>3</sub>T4 J<sub>4</sub>

* * *