# 树在离散数学中的应用

> 原文:[https://www . javatpoint . com/离散数学中的应用程序树](https://www.javatpoint.com/applications-of-tree-in-discrete-mathematics)

## 树

**一棵树**可以描述为节点的集合，称为节点之间有连接线或边的图。所以我们可以说，线是用来连接所有的节点。树的第一个节点称为根。

树的各种应用描述如下:

## 二叉查找树

最重要的任务是在列表中搜索项目。我们的主要目标是通过实现搜索算法来有效地搜索订购的商品。我们可以利用二叉查找树，这样我们就可以完成它。在二叉查找树，顶点的每个子节点被分成右子节点或子树或左子节点或子树。顶点(左或右子)的子树只能是一个。树的每个顶点都有一个被称为键的值。顶点的左子树用来包含各种带关键点的顶点，但这个关键点必须小于顶点的关键点。一个顶点的右子树用来包含各种带关键点的顶点，但是这个关键点必须大于顶点的关键点。右子树和左子树应该是二叉查找树。

### 二叉树的插入方法

在起点，树只包含一个顶点，称为根。之后，我们将分配第一项，即根的键。

**例如:**假设我们要**插入 45** 。那么 45 将成为这棵树的根，描述如下:

![Applications of Tree in Discrete Mathematics](../Images/6c7d41230fa37032c9e64288b1fbb37a.png)

如果我们想先在树中插入项目，我们必须将其与根的键进行比较。如果它小于键，它将移动到左边，被称为左子级；否则，它将移动到右边，被称为右子级。根的左子级和右子级不能超过一个。

**例如:**

*   假设根是 45，我们要插入 **39** 和 **50** 。在这种情况下，首先， **39** 将与 45 进行比较。第 39 项小于 45，因此将添加到 45 的左侧。第 39 项将被称为根 45 的左子项。
*   之后我们将**插入 50** 。我们还将与 45 进行比较。第 50 项大于 45，因此将被添加到 45 的右侧。第 50 项将被称为根 45 的右子项。

![Applications of Tree in Discrete Mathematics](../Images/ba6f24c98457c3c50864365fe8120660.png)

如果我们想插入更多的项目，我们必须遵循上述程序。这意味着我们将首先用根比较项目。根据这个比较，我们将它与左边或右边的孩子进行比较。如果新项目小于左边的子项目，它将移动到左边这个子项目的左边，否则，它将移动到左边这个子项目的右边。否则，我们会将新项目与正确的子项目进行比较。如果新项目大于右子项目，它将移动到这个右子项目的右边，否则，它将移动到这个右子项目的左边。

**例如:**

*   在上图中，假设我们要插入 **33，41，47** ，和 **52** 。在这种情况下，首先，我们必须遵循上述程序。所以我们先来试试**插入 33** 。为此，我们将比较 33 和 45。它小于 45，所以它会向左移动。现在我们来比较一下 33 和 39。它小于 39，所以它会向左移动，33 会在那里相加。
*   现在我们将**插入 41** 。所以我们将它与 45 进行比较。它小于 45，所以它会向左移动。现在我们将它与 39 进行比较。它大于 39，所以它会向右移动，41 会在那里相加。
*   之后我们将**插入 47** 。所以我们将 47 和 45 进行比较。它大于 45，所以会向右移动。现在我们来比较一下 47 和 50。它小于 50，所以它会移到 50 的左边，47 会在那里相加。
*   现在我们将**插入 52** 。所以我们将 52 和 45 进行比较。它大于 45，所以会向右移动。现在我们来比较一下 52 和 50。它大于 50，所以它会移到 50 的右边，52 会加在那里。

![Applications of Tree in Discrete Mathematics](../Images/a246a3c885c6ad5752bfb55d8c7ecda2.png)

可以有另一种情况，其中左或右子孩子也可以有多个孩子。在这种情况下，我们必须比较最后一个节点的所有项目，并根据它们的比较，将其放在左侧或右侧。

**例如:**

*   在上图中，假设我们要插入 **31、35、37、40、44、46、48、51、**和 **55** 。在这种情况下，首先我们必须遵循上述程序。所以首先，我们将尝试**插入 31** 。为此，我们将比较 31 和 45。它小于 45，所以它会向左移动。现在我们来比较 31 和 39。它小于 39，所以它会向左移动，并再次与 33 进行比较。它小于 33，所以 31 将加在 33 的左边。
*   现在我们尝试**插入 35** 。所以我们将它与 45 进行比较。它小于 45，所以它会向左移动。现在我们将它与 39 进行比较。它小于 39，所以 35 将向左移动，并再次与 33 进行比较。第 35 项大于 33，因此它将向右移动。
*   现在我们尝试**插入 37** 。所以我们将它与 45 进行比较。它小于 39，所以它会向左移动，并再次与 33 进行比较。它大于 33，所以它会向右移动，但是 33 已经是有一个右子 35 了。所以我们必须再次比较 37 和 35。它大于 35，所以 37 会加在 35 之后。
*   将遵循相同的程序插入所有剩余项目。所以 41 的**左侧**增加 **40** ，41 的**右侧**增加 **44** 。当我们尝试插入 46 和 48 时，那么 **46** 将插入 47 的**左侧**，而 **48** 将插入 47 的**右侧**。最后，如果我们尝试插入 51 和 55，那么 **51** 将插入 52 的**左侧**，而 **55** 将插入 52 的**右侧**。

![Applications of Tree in Discrete Mathematics](../Images/8d0ffeec862738784cf68f2c9c2b54de.png)

### 二叉查找树插入算法

**第一步:**开始

**第二步:**存储要插入的钥匙(x)

**步骤 3:** 检查树中存在的元素，如果不存在，则转到步骤 4，否则转到步骤 5

**步骤 4:** 制作插入的关键根节点

**步骤 5:** 将 x 与根节点进行比较如果较小，则转到步骤 6，否则转到步骤 7，否则没有根节点找到，则转到步骤 9。

**步骤 6:** 元素到达左边的子树重复步骤 5

**步骤 7:** 元素到达右子树重复步骤 5

**第 8 步:**插入钥匙

**第 9 步:**停止

## 决策图表

决策树是一种层次树结构或图表，它帮助我们在各种动作之间进行选择。它主要用于决策目的。这是一种有根树，其中每个内部顶点对应一个决策。这些顶点包含决策的每个可能结果的子树。叶子顶点的路径对应于问题的可能解决方案。决策树包含树状结构，这就是为什么人们可以很容易地理解这棵树背后的逻辑。使用这棵树，人们可以很容易地做出他们的决定，因为它将我们的问题分成更小的部分，这有助于我们非常容易地做出决定。

在属性值测试的基础上，决策树将子集划分为更小的子集。以递归的方式，我们将在每个派生的子集上重复这个过程。这个过程被称为**递归分区**。当目标变量和节点上的子集都有相同的值时，递归过程就完成了。如果我们不知道如何构造决策树分类器，那么我们不需要任何参数设置或领域知识。决策树可以很容易地处理高维数据。决策树分类器的准确性非常好。

### 决策树的表示

在决策树中，我们将通过对实例进行分类来对它们进行分类。我们将它们从根节点排序到某个叶节点，这些叶节点用于提供实例的分类。为了对实例进行分类，我们将从树的根节点开始。然后我们将测试由这个节点指定的属性。之后，我们将向下移动到树分支，它对应于属性的值。我们将对以新节点为根的子树重复这个过程。

![Applications of Tree in Discrete Mathematics](../Images/19f7f2793cf97b5e53b2247c8de2a8e9.png)

### 决策树示例

假设我们有一封报价信。现在我们必须决定是否接受这封信。

**解决方案:**

对于这个问题，我们将创建一个决策树，它从根节点开始，即薪资属性。现在，我们的根节点将分为两个节点:一个决策节点，用于显示家庭和办公室之间的距离，以及一个叶节点，将基于相应的标签创建。之后，下一个决策节点将再次分成两个节点:一个决策节点，用于显示 Cab 工具，以及一个叶节点。最后，决策节点将分为两个叶节点:一个用于已接受的报价，另一个用于已拒绝的报价。

![Applications of Tree in Discrete Mathematics](../Images/2a774feaabb87c9724c60eec0f7df598.png)

## 博弈树

游戏树可以描述为一种递归搜索函数，用于检查策略游戏的所有可能的移动。它还将检查结果，以便他们能够确定最佳移动。如果人工智能有一个场景，在这个场景中，他们每场比赛的可能选择数量较少，不需要实时决策，在这种情况下，游戏树对他们来说将非常有用。通常，游戏树用于找出棋盘游戏中可能的最佳棋步。为了解释游戏树，我们将以**井字游戏**为例，描述如下:

![Applications of Tree in Discrete Mathematics](../Images/ba51c850c12ce3b390c026df97b1cf46.png)

所以我们将从目前的董事会位置开始。现在我们必须检查计算机做出的所有可能的动作。使用这些所有可能的移动，我们将检查其他玩家可能做出的移动。之后，我们会看电脑。现在电脑会向后翻转，为另一个玩家和它自己移动。电脑不断移动，直到游戏结束。对于每一个可能的结果，电脑都会这样做，它会玩成千上万的游戏。最后，它通过观察这些游戏的输家和赢家的结果来找出成功的最佳机会。如果我们正在玩的游戏没有尽头，游戏树将走向无限。

在游戏树中，我们检查每一个可能的动作，也检查对手的每一个动作。之后，我们会试着看看他们赢了多少步。在这个世界上，我们有大量可能的游戏。在我们的例子中，我们使用了一个**井字游戏**。在这个游戏中，第一步包含 9 个可能的步骤。在第二回合，它会减少到 8，然后是 7，6 等。所以在这个游戏中，总共有 255，168 个可能的移动。在游戏树中，主要目标是看到所有这些移动，并选择一个有所有机会赢得这场游戏的移动。

### 计算机在游戏树上的工作

电脑会检查所有可能的走法，并开始评估一个很有可能赢得比赛的走法。井字游戏有一个格子，里面有很多空方块。电脑可以填满任何一个空方块。所以我们可以说空方块的数量和可能移动的数量是一样的。当他们发现所有这些移动时，他们会在每个可能的移动上创建一个循环，然后尝试确定该移动是否会导致胜利。

我们将游戏树扩展成分支，以确定移动是好是坏。我们将扩展树，直到游戏完成或终端节点。树的最后一个节点称为终端节点。根据游戏结果，分配终端节点的值。如果终端具有更高的值，那么结果对计算机来说将是非常好的，因为它们只有两种可能的结果，即赢或输。游戏的结果可以用-1 和 1 来表示。终端节点使用游戏规则并显示最大计算的支付值。终端节点、计算机移动和对手移动的图形表示描述如下:

![Applications of Tree in Discrete Mathematics](../Images/3006a9304a8b818a5d7753bc9dd14c92.png)

在下图中，我们可以看到终端节点的值已经由节点 D、E、F 和 g 决定。为了找到另一个节点的支付值，将使用极小极大算法。如果节点显示计算机选择的移动，该节点将显示最大值。如果节点显示玩家选择的移动，该节点将显示“最小”。最大节点的值成为其下的最高节点，与最小节点的值相同。

![Applications of Tree in Discrete Mathematics](../Images/db16f68ad89f4d9d6217f365cd8de67f.png)

在这个例子中，D 的值是 4，E 的值是 1。B 的值变成 1，这是 4 和 1 中的最低值。如果我们在这张图片中向上移动，我们会看到每个节点都有一个值。我们将假设顶部节点 A 具有其下节点的最高或最大值。最高值节点显示应该由计算机执行的移动。如果游戏由对手获胜，该位置将被称为对手的获胜位置。在这种情况下，计算机的移动将被称为坏移动。如果游戏通过计算机获胜，该位置将被称为计算机的获胜位置。在这种情况下，对手的举动会被称为坏举动。

* * *