# 二叉查找树 vs AVL 树

> 原文:[https://www.javatpoint.com/binary-search-tree-vs-avl-tree](https://www.javatpoint.com/binary-search-tree-vs-avl-tree)

在了解二叉查找树树和 AVL 树的区别之前，我们应该分别了解二叉查找树树和 AVL 树。

### 什么是二叉查找树？

[二叉查找树](https://www.javatpoint.com/binary-search-tree)是一个[树](https://www.javatpoint.com/tree) [数据结构](https://www.javatpoint.com/data-structure-tutorial)，它遵循[二叉树](https://www.javatpoint.com/binary-tree)的条件。我们知道，那棵树可以有 n 个孩子，然而；二叉树最多可以包含两个子树。所以，二叉树的约束后面跟着二叉查找树。二叉查找树的每个节点最多应该有两个孩子；换句话说，我们可以说二叉查找树是二叉树的变种。

二叉查找树也遵循二分搜索法的属性。在二分搜索法，数组中的所有元素都必须按顺序排列。我们计算二分搜索法中的中间元素，其中中间元素的左边部分包含小于中间值的值，中间元素的右边部分包含大于中间值的值。

在二叉查找树，中间的元素成为根节点，右边的部分成为右子树，左边的部分成为左子树。因此，我们可以说二叉查找树是一个 ***二叉树*** 和 ***二分搜索法*** 的组合。

#### 注意:二叉查找树可以定义为左子树的所有元素都小于根节点，右子树的所有元素都大于根节点的二叉树。

**二叉查找树的时间复杂性**

如果二叉查找树几乎是一个平衡树，那么所有操作的时间复杂度将为 **O(logn)** ，因为搜索被划分到左或右子树。

如果二叉查找树向左或向右倾斜，那么所有操作的时间复杂度都是 **O(n)** ，因为我们需要遍历到 n 个元素。

### 什么是 AVL 树？

一个 [AVL 树](https://www.javatpoint.com/avl-tree)是一个自平衡的二叉查找树，其中左右子树的高度差不能超过一。这种差异被称为平衡因素。在 AVL 树中，平衡因子的值可以是-1、0 或 1。

**二叉查找树的自平衡是如何发生的？**

我们知道 AVL 树是一个自平衡的二叉查找树。如果二叉查找树不平衡，它可以通过一些重新安排实现自我平衡。这些重新排列可以通过一些旋转来完成。

**我们通过一个例子来理解自我平衡。**

假设我们想在一个 AVL 树中插入 **10，20，30** 。

**以下是在 AVL 树中插入 10、20、30 的方式:**

*   **如果插入顺序是 30、20、10。**

**第一步:**首先，我们创建一个二叉查找树，如下图所示:

![Binary Search tree vs AVL tree](../Images/7d0ef8a8e2236a68f08f054310a44cb8.png)

**第二步:**在上图中，我们可以观察到树是不平衡的，因为节点 30 的平衡因子是 2。为了使它成为一个 AVL 树，我们需要执行一些旋转。如果我们在节点 20 上执行右旋转，那么节点 30 将向下移动，而节点 20 将向上移动，如下所示:

![Binary Search tree vs AVL tree](../Images/712bd63f881f033e98e482eca4c4cfac.png)

我们可以观察到，最终的树遵循二叉查找树和平衡树的属性；因此，它是一个 AVL 树。

在这种情况下，树是 ***左不平衡树，*** 所以我们在节点上执行右旋转。

*   **如果插入的顺序是 10、20、30。**

**步骤 1:** 首先我们创建一个二叉查找树，如下所示:

![Binary Search tree vs AVL tree](../Images/fa4e11ea05525cefa2e6880a123c9b2c.png)

**第二步:**在上图中，我们可以观察到树是不平衡的，因为节点 10 的平衡因子是-2。为了使它成为一个 AVL 树，我们需要执行一些旋转。这是一个右不平衡的树，所以我们将执行左旋转。如果我们在节点 20 上执行向左旋转，那么节点 20 将向上移动，节点 10 将向下移动，如下所示:

![Binary Search tree vs AVL tree](../Images/58b36a81dc929f520a44bdcba3e82b05.png)

我们可以观察到，最终的树遵循 ***【二叉查找树】*** 和 ***平衡树*** 的属性；因此，它是一个 AVL 树。

*   **如果插入顺序是 30、10、20**

**步骤 1:** 首先我们创建如下所示的二叉查找树:

![Binary Search tree vs AVL tree](../Images/706cb376db7833305e24d6ee71f905c2.png)

**第二步:**在上图中，我们可以观察到树是不平衡的，因为根节点的平衡因子是 2。为了使它成为一个 AVL 树，我们需要执行一些旋转。上面的场景是左右不平衡的，因为一个节点在其父节点的左边，另一个节点在其父节点的右边。首先，我们将执行左旋转，旋转发生在节点 10 和 20 之间。向左旋转后，20 将向上移动，10 将向下移动，如下图所示:

![Binary Search tree vs AVL tree](../Images/f8beb60d89550c1b145ea30935374371.png)

尽管如此，树是不平衡的，所以我们在树上执行正确的旋转。一旦对树执行了正确的旋转，那么树将如下所示:

![Binary Search tree vs AVL tree](../Images/728c8da6d8590dad80b260249542f1f7.png)

正如我们在上面的树中可以观察到的，这棵树遵循二叉查找树和平衡树的属性；因此，它是一个 AVL 树。

*   **如果插入的顺序是 10、30、20**

**第一步:**首先，我们创建二叉查找树，如下图所示:

![Binary Search tree vs AVL tree](../Images/6fe688e1c62afec810bf45c0c7d91c3e.png)

**第二步:**在上图中，我们可以观察到树是不平衡的，因为根节点的平衡因子是 2。为了使它成为一个 AVL 树，我们需要执行一些旋转。上面的场景是左右不平衡的，因为一个节点在其父节点的右边，另一个节点在其父节点的左边。首先，我们将执行发生在节点 30 和 20 之间的正确旋转。向右旋转后，20 将向上移动，30 将向下移动，如下图所示:

![Binary Search tree vs AVL tree](../Images/008921675ce7c664fd4c33f8378842db.png)

尽管如此，上面的树是不平衡的，所以我们需要在节点上执行向左旋转。一旦执行向左旋转，节点 20 将向上移动，节点 10 将向下移动，如下所示:

![Binary Search tree vs AVL tree](../Images/11f6d3098601b0ed0da80083410d4d14.png)

正如我们在上面的树中可以观察到的，这棵树遵循二叉查找树和平衡树的属性；因此，它是一个 AVL 树。

### 二叉查找树树和 AVL 树的区别

![Binary Search tree vs AVL tree](../Images/fdd3e4c725b2cc20c5b403630b94e22b.png)

| 二叉查找树 | AVL 树 |
| 每个二叉查找树都是一棵二叉树，因为这两棵树都包含最多两个孩子。 | 每个 AVL 树也是二叉树，因为 AVL 树也有最大的两个子树。 |
| 在 BST 中，不存在平衡因子等术语。 | 在 AVL 树中，每个节点都包含一个平衡因子，平衡因子的值必须是-1、0 或 1。 |
| 每个二叉查找树都不是一棵 AVL 树，因为 BST 可能是一棵平衡树，也可能是一棵不平衡树。 | 每个 AVL 树都是二叉查找树树，因为 AVL 树遵循 BST 的属性。 |
| 二叉查找树中的每个节点由三个字段组成，即左子树、节点值和右子树。 | AVL 树中的每个节点由四个字段组成，即左子树、节点值、右子树和平衡因子。 |
| 在二叉查找树的例子中，如果我们想在树中插入任何节点，那么我们将节点值与根值进行比较；如果节点的值大于根节点的值，则该节点被插入到右子树，否则该节点被插入到左子树。插入节点后，无需检查高度平衡系数即可完成插入。 | 在 AVL 树的情况下，首先我们会找到合适的地方插入节点。一旦节点被插入，我们将计算每个节点的平衡因子。如果满足每个节点的平衡因子，则插入完成。如果平衡因子大于 1，那么我们需要执行一些旋转来平衡树。 |
| 在二叉查找树，树的高度或深度是 O(n)，其中 n 是二叉查找树的节点数。 | 在 AVL 树中，树的高度或深度为 O(logn)。 |
| 实现起来很简单，因为我们必须遵循二分搜索法属性来插入节点。 | 实现起来比较复杂，因为在 AVL 树中，首先要构造 AVL 树，然后需要检查高度平衡。如果高度不平衡，那么我们需要进行一些旋转来平衡树。 |
| BST 不是平衡树，因为它没有遵循平衡因子的概念。 | AVL 树是高度平衡树，因为它遵循平衡因子的概念。 |
| 当树中有大量节点可用时，由于高度不平衡，在 BST 中搜索效率很低。 | 由于树的高度是平衡的，所以即使树中有大量节点，在 AVL 树中搜索也是有效的。 |

* * *