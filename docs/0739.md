# 全对最短路径

> 原文:[https://www.javatpoint.com/all-pairs-shortest-paths](https://www.javatpoint.com/all-pairs-shortest-paths)

## 介绍

它旨在找出从每个顶点 v 到每隔一个 u 的最短路径。显式存储所有路径确实会非常耗费内存，因为我们需要为每个顶点创建一个生成树。考虑到内存消耗，这通常是不切实际的，因此这些通常被认为是所有对-最短距离问题，其目的是找到从每个节点到另一个节点的距离。我们通常希望以表格形式输出:u 行和 v 列中的条目应该是从 u 到 v 的最短路径的权重。

三种改进方法:

| 算法 | 费用 |
| 矩阵乘法 | O (V <sup>3</sup> logV) |
| 弗洛伊德·沃歇尔 | O (V <sup>3</sup> ) |
| 约翰逊 | (v)<sup>2</sup>日志吗 v+和) |

不同于单源算法，它假设图的邻接表表示，大多数算法使用邻接矩阵表示。(约翰逊的稀疏图算法使用邻接表。)输入是 n×n 矩阵 W，表示 n 顶点有向图 G = (V，E)的边权。即 W = (w <sub>ij</sub> )，其中

![All-Pairs Shortest Paths](../Images/e1d5ed0823e9b8a81d25fb5045b0f0b3.png)