# 死锁和饥饿的区别

> 原文:[https://www.javatpoint.com/deadlock-vs-starvation](https://www.javatpoint.com/deadlock-vs-starvation)

死锁和饥饿是请求资源的进程被延迟很长时间的情况。然而，死锁和饥饿在很多方面都不是一回事。当每个进程都持有一个资源并等待另一个进程持有另一个资源时，就会发生死锁。相比之下，在饥饿状态下，高优先级的进程会持续消耗资源，从而阻止低优先级的进程获取资源。

在本文中，您将了解**死锁**和**饥饿**之间的区别。但是在讨论**死锁**和**饥饿**的区别之前，你必须了解死锁和饥饿。

## 什么是死锁？

当每个进程都持有一个资源并等待另一个进程持有另一个资源时，就会发生死锁。换句话说，当中央处理器中的多个进程争夺中央处理器中有限的可用资源时，就会发生死锁。在这种情况下，每个进程都保留一个资源，并等待另一个进程获取资源。

![Deadlock vs Starvation](../Images/7d8fd15e0e1041bd35a239dc9853b1cc.png)

举个例子，**进程(P1)** 持有**资源(R1)** 等待**进程(P2)** 获取**资源(R2)** ，**进程(P2)** 等待**资源(R1)** 。因此，**进程(P1)** 和 **(P2)** 都处于死锁状态。

这是多道程序操作系统、并行计算系统和分布式系统中的一个常见问题。当一个进程需要另一个进程请求的进程时，就会出现死锁问题。

四种情况可能出现死锁的情况。这些措施如下:

1.  **互斥**
2.  **保持等待**
3.  **不可抢占**
4.  **循环等待**

### 互斥现象

一次只有一个进程可以利用一个资源；如果另一个进程请求相同的资源，它必须等到使用它的进程释放它。

### 等待

一个进程在等待另一个进程的资源获取者时，应该持有一个资源。

### 没有优先权

拥有资源的进程可能不会被抢占，拥有资源的进程应该在完成任务后自由释放资源。

### 循环等待

在循环形式中，进程必须等待资源。假设有三个过程: **P0** 、 **P1** 、 **P2** 。 **P0** 必须等待 **P1** 持有的资源； **P1** 必须等待流程 **P2** 获取 **P2** 持有的资源， **P2** 必须等待 **P0** 获取流程。

尽管几个应用程序可能会检测到有可能陷入死锁的程序，但操作系统从不负责防止死锁。程序员的责任是创建没有死锁的程序，通过避免上面列出的条件可以避免死锁。

## 什么是饥饿？

当低优先级程序请求系统资源，但由于高优先级程序已经使用该资源很长时间而无法运行时，就会发生饥饿。当一个进程准备好开始执行时，它会等待中央处理器分配必要的资源。但是，由于其他进程继续阻塞所需的资源，该进程必须无限期等待。

在大多数优先级调度算法中，都会出现饥饿问题。在优先级调度方法中，资源经常被分配给优先级较高的进程，这有助于防止优先级较低的进程获得所请求的资源。

饥饿是一个可以通过衰老解决的问题。老化提高了长时间等待资源的过程的优先级。它还有助于防止低优先级过程无限期等待资源。

饥饿的一些常见**原因**如下:

1.  如果没有足够的资源根据需要提供给每个进程，就会出现饥饿。
2.  如果由于错误的资源分配决策，进程从未获得执行所需的资源，就会出现饥饿。
3.  如果较高优先级的操作不断独占处理器，较低优先级的进程可能不得不无限期等待。

可以在有助于处理饥饿的系统中实现的一些**解决方案**如下:

1.  资源分配优先级方案应该包含老化等概念，其中进程的优先级随着等待时间的延长而增加。它可以防止饥饿。
2.  一个独立的管理者可以用来分配资源。这个资源管理器适当地分配资源，并试图防止饥饿。
3.  应该避免资源分配或处理器分配的随机进程选择，因为这会导致饥饿。

## 死锁和饥饿的主要区别

在这里，您将了解死锁和饥饿之间的主要区别。死锁和饥饿之间的不同之处如下:

1.  当每个进程都持有一个资源并等待另一个进程持有另一个资源时，就会发生死锁。相比之下，当低优先级程序请求系统资源，但由于高优先级程序已经使用该资源很长时间而无法运行时，就会发生饥饿。
2.  在死锁中，没有进程可以继续执行；相反，在等待另一个进程获取资源时，每个进程都会被阻塞。另一方面，饥饿是一种情况，在这种情况下，较高优先级的进程拥有获取资源的无限能力。此外，低优先级进程被阻止获取资源，导致它们无限期阻塞。
3.  当四个条件同时存在时，死锁就会发生:互斥、保持和等待、不抢占和循环等待。相比之下，当分配资源时强制执行进程优先级，或者当资源管理不受管理时，就会出现资源匮乏。
4.  在死锁情况下，进程阻塞资源。相比之下，高优先级进程继续在饥饿状态下使用所请求的资源。
5.  死锁也称为循环等待，而饥饿称为活锁。

## 死锁和饥饿之间的直接比较

![Deadlock vs Starvation](../Images/45f7552c62914899c411f3051242966c.png)

在这里，您将学习死锁和饥饿之间的面对面比较。死锁和饥饿之间的各种头对头比较如下:

| 特征 | 僵局 | 饿死 |
| **定义** | 当每个进程都持有一个资源并等待另一个进程持有另一个资源时，就会发生死锁。 | 当低优先级程序请求系统资源，但由于高优先级程序已经使用该资源很长时间而无法运行时，就会发生饥饿。 |
| **基础** | 当任何进程都无法继续并被阻塞时，就会发生死锁。 | 当低优先级过程被阻塞，而高优先级操作继续进行时，就会出现饥饿。 |
| **其他名称** | 死锁也称为循环等待。 | 饥饿被称为活锁。 |
| **资源** | 当一个进程死锁时，其他进程会阻塞请求的资源。 | 高优先级进程继续使用请求的资源。 |
| **上升条件** | 互斥的发生、保持和等待、不抢占和循环等待都是同时发生的。 | 不受控制的资源管理，执行优先权。 |
| **预防** | 可以通过避免导致僵局的情况来防止。 | 衰老可能会阻止它。 |

## 结论

操作系统中正在执行多个进程。饥饿和死锁是有进程时可能发生的两种方法。当每个进程都持有一个资源并等待获取另一个进程持有的资源时，就会发生死锁。相比之下，当一个进程无限期地等待所需的资源时，就会出现饥饿。死锁可能导致进程饥饿，另一方面，饥饿可以打破死锁。

* * *