# 冒泡排序与选择排序

> 原文:[https://www.javatpoint.com/bubble-sort-vs-selection-sort](https://www.javatpoint.com/bubble-sort-vs-selection-sort)

这里我们将看看选择排序和冒泡排序之间的区别。在了解差异之前，我们应该分别了解选择排序和冒泡排序。

### 什么是选择排序？

排序意味着按升序排列数组的元素。选择排序是一种用于对数组进行排序的排序技术。在选择排序中，一个数组被分成两个子数组，即一个是非排序子数组，另一个是排序子数组。最初，我们假设排序后的子数组是空的。首先，我们将从未排序的子阵列中找到最小元素，并将最小元素替换为位于数组起始位置的元素。该算法被称为选择排序，因为它选择最小元素，然后执行交换。

**我们通过一个例子来了解选择排序。**

![Bubble sort vs. Selection sort](../Images/670a6be127de650c6dc87f358d510ed1.png)

正如我们在上面的数组中观察到的，它包含 6 个元素。上面的数组是一个未排序的数组，其索引从 0 开始，到 5 结束。以下是用于对数组进行排序的步骤:

**步骤 1:** 在上述数组中，最小元素为 1；用元素 7 替换元素 1。

现在，排序后的数组只包含一个元素，即 1，而未排序的数组包含 5

元素，即 4、10、8、3、7。

![Bubble sort vs. Selection sort](../Images/bb544e4db0e414aaae7638471cded724.png)

**步骤 2:** 在未排序的子数组中，最小的元素是 3，所以用元素 4 交换元素 3，元素 4 在未排序的子数组的开头。

现在排序后的数组包含两个元素，即 1 和 3，而未排序的数组有四个元素，即 10、8、4、7，如上图所示。

![Bubble sort vs. Selection sort](../Images/8d5fa13f54237acc3068bdb180c3eefa.png)

**第三步:**在未排序的子数组中搜索最小元素，最小元素为 4。用元素 10 替换元素 4，元素 10 位于未排序子数组的开头。

现在，排序后的数组包含三个元素，即 1、3、4，而未排序的数组包含三个元素，即 10、8、7

![Bubble sort vs. Selection sort](../Images/8bcf0bd9ec4aa5c89c862a4b1a093117.png)

**第四步:**在未排序的数组中搜索最小元素，最小元素为 7。用元素 10 替换元素 7，元素 10 位于未排序子数组的开头。

![Bubble sort vs. Selection sort](../Images/f58165aeba839971b51761da9175f65b.png)

现在，排序后的数组包含四个元素，即 1、3、4、7，而未排序的数组有两个元素，即 10、8。

**第五步:**在未排序的数组中搜索最小元素，最小元素为 8。用位于未排序子数组开头的元素 10 替换元素 8。

![Bubble sort vs. Selection sort](../Images/10a092c9ecd0c58e477d54a1aeb8b9ed.png)

现在，排序后的数组包含元素，即 1、3、4、7、8。

**步骤 6:** 最后一个元素留在未排序的子数组中。将最后一个元素移动到排序的子数组，如下所示:

![Bubble sort vs. Selection sort](../Images/668c12f7be00e91715d8354692566f24.png)

### 什么是泡泡排序？

冒泡排序也是用于排序数组元素的排序技术之一。冒泡排序背后的基本原则是两个相邻的元素要进行比较；如果这些元素的顺序正确，那么我们就进入下一个迭代。否则，我们交换这两个元素。让我们通过一个例子来理解泡泡排序。

**考虑下面的数组:**

![Bubble sort vs. Selection sort](../Images/7664ccd17f3774b03bec72d54346290a.png)

上面的数组是一个未排序的数组。数组由 5 个整数组成，即 15、16、6、8、5。

**以下是对数组进行排序所需的步骤:**

**通过 1**

**步骤 1:** 将 a[0]元素与 a[1]元素进行比较。a[0]小于 a[1]，即 15 < 16，因此不会进行交换，如下图所示:

![Bubble sort vs. Selection sort](../Images/419d075a6f958f0985e4c8b36fc00d1d.png)

**步骤 2:** 现在，a[1]将与 a[2]元素进行比较。由于 a[1]大于 a[0]元素，即 16 > 6，所以交换 16 和 6 如下图所示:

![Bubble sort vs. Selection sort](../Images/74d78623504ee08ea75089bda47ce30c.png)

**步骤 3:** 将 a[2]与 a[3]元素进行比较。由于 a[2]大于 a[3]元素，即 16 > 8，所以交换 16 和 8 元素如下图所示:

![Bubble sort vs. Selection sort](../Images/88f202ddab8eb02216f28b6191f8ee4a.png)

**步骤 4:** 将 a[3]与 a[4]元素进行比较。由于 a[3]大于 a[4]，即 16 > 5，所以交换 16 和 5 的元素如下图所示:

![Bubble sort vs. Selection sort](../Images/830be298f14c5cc8b75a3c563cce619d.png)

正如我们在上面的数组中观察到的，最大的元素已经冒泡到了它的正确位置。换句话说，我们可以说最大的元素被放在了数组的最后一个位置。上述步骤包含在 PASS 1 中，其中最大的元素位于正确的位置。

我们将再次开始比较 PASS 2 中第一个位置的元素。

**PASS 2:**

**步骤 1:** 首先，我们比较一个[0]和一个[1]元素。由于[0]元素大于[1]元素，即 15 > 6，如下图所示，用[1]替换[0]元素:

![Bubble sort vs. Selection sort](../Images/892e69d59bca01c6d2d799782e256b32.png)

**步骤 2:** 将[1]元素与[2]元素进行比较。a[1]大于 a[2]，即 15 > 8，因此用元素 a[2]交换 a[1]，如下图所示:

![Bubble sort vs. Selection sort](../Images/aee1a659362af3d243fd2e42e72530b9.png)

**步骤 3:** 将 a[2]元素与 a[3]元素进行比较。由于 a[2]大于 a[3]元素，即 15 > 5，如下图所示，用元素 5 替换元素 15:

![Bubble sort vs. Selection sort](../Images/9771889be5c142151d57e4e3ed501105.png)

**步骤 4:** 现在，将[3]与[4]进行比较。由于[3]小于[4]，因此不会进行交换，如下图所示:

![Bubble sort vs. Selection sort](../Images/400cccc3b75bff0057a3d92471e8b1ca.png)

正如我们在上面看到的，这两个元素在正确的位置，最大的(16)和第二大的元素(15)。在一个数组中，三个元素没有排序，所以我们将再次遵循 PASS 3 中的相同步骤。

**传球 3:**

**第一步:**首先，我们比较 a[0]和 a[1]。由于 a[0]小于 a[1]，即 6 < 8，因此不会进行交换，如下图所示:

![Bubble sort vs. Selection sort](../Images/b28cfec7644bb1d8f121cc35549cfb3f.png)

**步骤 2:** 现在，将[1]与[2]进行比较。由于 a[1]大于 a[2]，因此用元素 5 替换元素 8，如下图所示:

![Bubble sort vs. Selection sort](../Images/bcd7c370592394f1d82712c330e63a58.png)

**步骤 3:** 将 a[2]与 a[3]进行比较。由于 a[2]小于 a[3]，即 8 < 15，因此不会进行交换，如下图所示:

![Bubble sort vs. Selection sort](../Images/c7295c10d6325570cc4e9ffe48e106b8.png)

**步骤 4:** 将 a[3]元素与 a[4]进行比较。由于 a[3]小于 a[4]，即 15 < 16，因此不会进行交换，如下图所示:

![Bubble sort vs. Selection sort](../Images/6d9145450e0f6a6cf3d5d34a9b89a1de.png)

在 PASS 3 中，三个元素位于正确的位置，最大、第二大和第三大。在一个数组中，两个元素没有排序，所以我们将再次遵循 PASS 4 中的相同步骤。

**PASS 4:**

**第一步:**首先，我们将比较 a[0]和 a[1]。将[0]与[1]交换，因为[0]大于[1]。

![Bubble sort vs. Selection sort](../Images/cdfe5d785b5367a55999f2b6529e34d5.png)

上面的数组是一个排序的数组，因为所有的元素都在正确的位置。

### 冒泡排序和选择排序的区别

![Bubble sort vs. Selection sort](../Images/f4160f1c742f0797942df6c4c71e0ba6.png)

| 冒泡排序 | 选择排序 |
| 在冒泡排序中，比较两个相邻的元素。如果相邻元素不在正确的位置，将执行交换。 | 在选择排序中，从数组中选择最小元素，并与未排序子数组开头的元素交换。 |
| 最佳情况和最坏情况下的时间复杂度分别为 O(n)和 O(n2)。 | 最佳和最差情况下的时间复杂度都是 O(n 2)。 |
| 这不是一种有效的排序技术。 | 与冒泡排序相比，这是一种有效的排序技术。 |
| 它使用交换方法。 | 它使用选择方法。 |
| 它比选择排序慢，因为需要更多的比较。 | 它比冒泡排序更快，因为需要的比较次数更少。 |

* * *