# 1 补码表示和 2 补码表示的区别

> 原文：<https://www.javatpoint.com/1s-complement-representation-vs-2s-complement-representation>

要理解 1 的补语和 2 的补语，我们应该了解补语。

### 赞扬；恭维；致意

为了执行逻辑操作和简化减法运算，数字系统通常使用补码。二进制数系统包含两种补码，即 1 的补码和 2 的补码。现在我们将分别描述每个补语。之后，我们将描述它们之间的区别。

### 1 的补码

借助一个简单的算法，二进制数可以很容易地转换成 1 的补码。根据这个算法，如果我们切换或反转一个二进制数的所有位，生成的二进制数将成为该二进制数的 1 的补码。这意味着我们必须将 1 位转换为 0 位，将 0 位转换为 1 补码中的 1 位。“n”用来表示一个数的 1 的补码。

**示例:**这里，我们将假设借助 4 位来存储数字。

```

1's complement of binary number 5 (0101) is binary number 10 (1010)
1's complement of binary number 13 (1101) is binary number 2 (0010)    

```

还有另一种方法可以找到一个数的 1 的补码。我们可以用一个公式来找到它，描述如下:

N' = (2<sup>n</sup> - 1) - N

**其中**

“N”用于表示 1 的补码符号中的-N

n 用于表示正整数

n 用于表示每个字的位数

**例如:**

假设我们有 8 位字，N = 6。现在 N 的 1 补码描述如下:

```
N' = (28 - 1) - 6
    = 249
    = (11111001)2

```

借助于这个公式，我们可以把给定的数转换成 1 的补码。

### 2 的补码

借助一个非常简单的算法，二进制数也可以很容易地转换成二进制补码。根据这个算法，我们可以通过首先反转给定的数来得到二进制数的 2 的补码。之后，我们必须在最低有效位上加 1。这意味着我们必须首先对一个数执行 1 的补码，然后我们必须将 1 加到那个数中以得到 2 的补码。N*用来表示一个数的二进制补码。

**示例:**这里，我们将假设借助 4 位来存储数字。

```

2's complement of binary number 5 (0101) is binary number 11 (1011)
1's complement of binary number 13 (1101) is binary number 3 (0011)    

```

还有另一种方法可以求一个数的 2 的补码。我们可以用一个公式来找到它，描述如下:

N* = 2<sup>n</sup> - N

**其中**

N*用于表示 1 的补码符号中的-N

n 用于表示正整数

n 用于表示每个字的位数

**例如:**

假设我们有 8 位字，N = 6。现在 N 的 1 补码描述如下:

```
N* = 28 - 6
     = 250
     = (11111010)2

```

借助于这个公式，我们可以把给定的数转换成 2 的补数。

## 1 补码和 2 补码的区别

1 的补码和 2 的补码有各种不同。我们将借助不同的参数来描述它们，这些参数描述如下:

| 因素 | 1 的补码表示 | 2 的补码表示 |
| 生成过程 | 我们可以通过切换或反转给定二进制数的所有位来获得该数的 1 的补码。 | 我们可以先对一个给定的二进制数做 1 的补码，然后在这个数上加 1，得到这个数的 2 的补码。 |
| 例子 | 二进制数 9 (1001)的 1 的补码是 6 (0110)。 | 二进制数 9(1001)的 2 的补码将通过对 6 (0110)做 1 的补码，然后加上 1，这意味着 7 (0111)而得到。所以 9 (1001)的 2 的补码是 7 (0111)。 |
| 使用的逻辑门 | 1 补码的实现非常简单。对于每一位输入，它基本上都使用非门。 | 对于每一位输入，2 的补码基本上使用 BOT 门和全加器。 |
| 数制 | 如果我们想表示符号二进制数，我们可以使用 1。如果我们有一个数字 0，那么就不可能以模糊表示的形式使用它。 | 如果我们想表示符号二进制数，我们也可以使用 2。如果我们有一个数字 0，那么它将有可能作为所有给定数字的明确表示。 |
| k 位寄存器 | 如果有 k 位寄存器，1 的补码将使用-(2 <sup>(k-1)</sup> -1)存储最低的负数，使用(2 <sup>(k-1)</sup> -1)存储最大的正数。 | 如果有 k 位寄存器，2 的补码将使用-(2 <sup>(k-1)</sup> )存储最低的负数，使用(2 <sup>(k-1)</sup> -1)存储最大的正数。 |
| 0 的表示 | 1 的补码中有两种表示 0 的方式，即+0 和-0。正 0 将表示为 00000000，在 8 位寄存器中为正零(+0)，对于负零(-0)，在 8 位寄存器中表示为 11111111。 | 对于+0 和-0，在 2 的补码中只有一种表示数字 0 的方法。在 8 位寄存器中，负 0 或正 0 都可以表示为 0000000 (+0)，因为如果我们将 1 加到 111111111(-1)上，我们将得到 00000000 (+0)，这与正 0 相同。这就是为什么数字 0 在 2 的补码中总是被认为是正数。这也是我们一般用 2 的补码的原因。 |
| 符号扩展 | 在 1 的补码中，符号扩展用于将给定的符号转换为任何有符号整数的另一个符号。 | 二进制补码和一进制补码中符号扩展的作用是一样的。这里，它还将给定的符号转换为任何有符号整数的另一个符号。 |
| 循环进位位 | 如果我们在 1 的补码的帮助下执行算术运算(加法)，在这种情况下，我们将首先执行二进制加法。之后，我们将添加末端进位位。 | 如果我们在二进制补码的帮助下执行算术运算(加法)，在这种情况下，由于二进制补码包含单个零值，所以不会发生进位结束位的加法。2 的补码忽略了这种加法。 |
| 易于操作 | 1 的补码总是需要添加进位结束位。这就是为什么 1 的补码算术运算比 2 的补码算术运算困难的原因。 | 二进制补码不需要增加末端进位。这就是为什么 2 的补码算术运算比 1 的补码算术运算更容易。 |

* * *