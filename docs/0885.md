# 操作系统中的线程

> 原文:[https://www.javatpoint.com/threads-in-operating-system](https://www.javatpoint.com/threads-in-operating-system)

线程是进程任务执行的单个顺序流程，因此也称为执行线程或控制线程。任何操作系统的进程内部都有一种线程执行方式。除此之外，一个进程中可以有多个线程。同一进程的每个线程都使用一个单独的程序计数器和一堆激活记录和控制块。线程通常被称为轻量级进程。

![Threads in os](../Images/c8e5475e880836f24257f21c5947a7a3.png)

这个过程可以分成很多线程。**比如**，在一个浏览器中，很多标签页都可以看成是线程。微软 Word 使用许多线程——格式化一个线程的文本，处理另一个线程的输入，等等。

## 螺纹需求:

*   在现有进程中创建新线程比创建新进程花费的时间少得多。
*   线程可以共享公共数据，它们不需要使用进程间通信。
*   使用线程时，上下文切换更快。
*   终止一个线程比终止一个进程花费的时间少。

## 线程的类型

在[操作系统](https://www.javatpoint.com/os-tutorial)中，有两种类型的线程。

1.  内核级线程。
2.  用户级线程。

### 用户级线程

[操作系统](https://www.javatpoint.com/operating-system)无法识别用户级线程。用户线程可以很容易地实现，并且由用户来实现。如果用户执行用户级线程阻塞操作，整个进程都会被阻塞。内核级线程对用户级线程一无所知。内核级线程管理用户级线程，好像它们是单线程进程？例如: [Java](https://www.javatpoint.com/java-tutorial) 线程、POSIX 线程等。

**用户级线程的优势**

1.  用户线程比内核线程更容易实现。
2.  用户级线程可以应用于不支持内核级线程的操作系统。
3.  它更快更高效。
4.  上下文切换时间比内核级线程短。
5.  它不需要修改操作系统。
6.  用户级线程表示非常简单。寄存器、PC、堆栈和迷你线程控制块存储在用户级进程的地址空间中。
7.  在没有进程干预的情况下，创建、切换和同步线程很简单。

**用户级线程的缺点**

1.  用户级线程在线程和内核之间缺乏协调。
2.  如果一个线程导致页面错误，整个进程就会被阻塞。

![Threads in os](../Images/aaa60d32a682ae5ff35ff63b03a7214b.png)

### 内核级线程

内核线程识别操作系统。对于内核级线程中的每个线程和进程，系统中都有一个线程控制块和进程控制块。内核级线程由操作系统实现。内核知道所有线程并管理它们。内核级线程提供系统调用来从用户空间创建和管理线程。内核线程的实现比用户线程更难。内核线程中的上下文切换时间较长。如果内核线程执行阻塞操作，Banky 线程执行可以继续。例如:视窗 Solaris。

![Threads in os](../Images/ef7b008c9c5d214644ecca9f3b9386d4.png)

**内核级线程的优势**

1.  内核级线程完全知道所有线程。
2.  调度器可能会决定在线程数量较大的过程中花费更多的 CPU 时间。
3.  内核级线程对于那些阻塞频率的应用程序是很好的。

**内核级线程的缺点**

1.  内核线程管理和调度所有线程。
2.  内核线程的实现比用户线程更难。
3.  内核级线程比用户级线程慢。

## 螺纹的成分

任何线程都有以下组件。

1.  程序计数器
2.  寄存器组
3.  栈空间

## 线程的优势

*   **系统吞吐量增强:**当进程被拆分为多个线程，每个线程都被当作一个作业来处理时，单位时间内完成的作业数量增加。这就是为什么系统的吞吐量也增加了。
*   **多处理器系统的有效利用率:**当一个进程中有多个线程时，可以在多个处理器中调度多个线程。
*   **更快的上下文切换:**线程间的上下文切换周期小于进程上下文切换。进程上下文切换意味着 CPU 的开销更大。
*   **响应性:**当进程被拆分成多个线程时，当一个线程完成其执行时，可以尽快响应该进程。
*   **通信:**多线程通信很简单，因为线程共享同一个地址空间，而在进程中，我们对两个进程之间的通信只采用了少数独占的通信策略。
*   **资源共享:**资源可以在一个进程内的所有线程之间共享，例如代码、数据和文件。注意:堆栈和寄存器不能在线程间共享。每个线程都有一个堆栈和寄存器。

* * *