# b 树

> 原文:[https://www.javatpoint.com/b-tree](https://www.javatpoint.com/b-tree)

b 树是一种专用的 m 路树，可广泛用于磁盘访问。m 阶的 B-树最多只能有 m-1 个键和 m 个子树。使用 B 树的主要原因之一是它能够通过保持树的高度相对较小来在单个节点中存储大量的键和大的键值。

M 阶的 B 树包含 M 路树的所有性质。此外，它还包含以下属性。

1.  B 树中的每个节点最多包含 m 个子节点。
2.  B 树中除根节点和叶节点之外的每个节点至少包含 m/2 个子节点。
3.  根节点必须至少有 2 个节点。
4.  所有叶节点必须处于同一级别。

不是所有节点都必须包含相同数量的子节点，而是每个节点必须有 m/2 个节点。

下图显示了 4 阶的 B 树。

![B Tree](../Images/415417c9b8b88014446cc3d3f6fe139f.png)

在对 B 树执行某些操作时，B 树的任何属性都可能违反，例如一个节点可以拥有的最小子节点数。为了维护 B 树的属性，该树可以拆分或连接。

## 操作

### 搜索:

在 B 树中搜索类似于在二叉查找树。例如，如果我们在下面的 B 树中搜索项目 49。该过程将如下所示:

1.  将项目 49 与根节点 78 进行比较。因为 49 < 78，所以移动到它左边的子树。
2.  因为，40<49<56，遍历 40 的右子树。
3.  49>45，向右移动。对比一下 49。
4.  找到匹配，返回。

在 B 树中搜索取决于树的高度。搜索算法需要 O(log n)时间来搜索 B 树中的任何元素。

![B Tree](../Images/f26ab0cb32400455e90037342dfb8eea.png)

### 插入

插入是在叶节点级别完成的。需要遵循以下算法才能将项目插入 B 树。

1.  遍历 B 树，以便找到可以插入节点的适当叶节点。
2.  如果叶节点包含少于 m-1 个键，则以递增的顺序插入元素。
3.  否则，如果叶节点包含 m-1 个键，则遵循以下步骤。

*   按照元素的递增顺序插入新元素。
*   将节点分成中间的两个节点。
*   将中间元素推到其父节点。
*   如果父节点也包含 m-1 个键，那么按照相同的步骤将其拆分。

**示例:**

将节点 8 插入如下图所示的 5 阶 B 树。

![B Tree](../Images/5c663faeb91cea6aa24bfa4b7859b953.png)

8 将插入到 5 的右侧，因此插入 8。

![B Tree](../Images/2e72ad419fd623e6c2fb5cca2ec5671b.png)

该节点现在包含 5 个键，大于(5 -1 = 4)个键。因此，将节点从中间值(即 8)拆分，并将其向上推至其父节点，如下所示。

![B Tree](../Images/3c6d7821b267a0f3b98f1c4a8c92aead.png)

### 删除

删除也在叶节点上执行。要删除的节点可以是叶节点，也可以是内部节点。为了从 B 树中删除一个节点，需要遵循以下算法。

1.  找到叶节点。
2.  如果叶节点中有超过 m/2 个键，则从该节点中删除所需的键。
3.  如果叶节点不包含 m/2 键，那么通过从八个或左兄弟中取元素来完成键。

*   如果左边的兄弟包含 m/2 个以上的元素，则将其最大的元素向上推到其父元素，并将中间的元素向下移动到删除键的节点。
*   如果右边的兄弟包含 m/2 个以上的元素，则将其最小的元素向上推到父元素，并将中间的元素向下移动到删除键的节点。

*   如果两个同级都不包含超过 m/2 个元素，则通过连接两个叶节点和父节点的中间元素来创建一个新的叶节点。*   如果父节点少于 m/2 个节点，那么也对父节点应用上述过程。

如果要删除的节点是内部节点，则用其有序后继节点或前置节点替换该节点。由于后继节点或前置节点总是在叶节点上，因此该过程与从叶节点删除节点的过程相似。

**例 1**

从下图所示的顺序 5 的 B 树中删除节点 53。

![B Tree](../Images/27b2a5f9e0af42c1cae8e3a2b87245c4.png)

53 出现在元素 49 的右子元素中。删除它。

![B Tree](../Images/e2b3a4de26a6dde2a63d57aa308592eb.png)

现在，57 是节点中剩下的唯一元素，在 5 阶的 B 树中必须存在的元素的最小数量是 2。如果小于这个值，它的左右子树中的元素也是不够的。因此，将它与父元素(即 49)的左兄弟和中间元素合并。

最终的 B 树如下所示。

![B Tree](../Images/b73aeada1a151410eaa4ee27287a0d33.png)

## B 树的应用

b 树用于索引数据，并提供对存储在磁盘上的实际数据的快速访问，因为访问存储在磁盘上的大型数据库中的值是一个非常耗时的过程。

在最坏的情况下，搜索包含 n 个键值的未索引和未排序的数据库需要 O(n)个运行时间。然而，如果我们使用 B 树来索引这个数据库，在最坏的情况下，它将在 O(log n)时间内被搜索。