# 分区算法

> 原文：<https://www.javatpoint.com/os-partitioning-algorithms>

为了找出链表中的漏洞并将其分配给进程，操作系统实现了各种算法。

下面给出了每个算法的解释。

**1。首次拟合算法**

First Fit 算法扫描链表，每当它找到第一个足够大的洞来存储一个进程时，它就停止扫描，并将进程加载到那个洞里。这个过程产生两个分区。其中，一个分区将是一个洞，而另一个分区将存储进程。

First Fit 算法根据起始索引的递增顺序维护链表。这是所有算法中实现最简单的，与其他算法相比会产生更大的漏洞。

**2。下一个拟合算法**

“下一次拟合”算法与“第一次拟合”算法相似，只是“下一次拟合”从先前分配孔的节点开始扫描链表。

Next fit 不会扫描整个列表，而是从下一个节点开始扫描列表。下一次匹配背后的想法是，列表已经被扫描了一次，因此在列表的剩余部分找到漏洞的概率更大。

对该算法的实验表明，下一次拟合并不比第一次拟合好。因此，在大多数情况下，现在并没有使用它。

**3。最佳拟合算法**

最佳拟合算法试图找出列表中能够满足工艺尺寸要求的最小孔。

使用最佳拟合有一些缺点。

1.  1.它速度较慢，因为它每次都扫描整个列表，并试图找出满足该过程要求的最小孔。
2.  由于整个尺寸和工艺尺寸之间的差异非常小，产生的孔将小到不能用于装载任何工艺，因此仍然没有用。
    尽管算法的名字最适合，但它并不是所有算法中最好的。

**4。最差拟合算法**

最差拟合算法每次扫描整个列表，并试图找出列表中最大的洞，以满足过程的要求。

尽管该算法会产生较大的漏洞来加载其他进程，但这并不是更好的方法，因为它会一次又一次地搜索整个列表，因此速度较慢。

**5。快速拟合算法**

快速拟合算法建议保持常用尺寸的不同列表。虽然，这实际上是不受影响的，因为这个过程需要花费大量的时间来创建不同的列表，然后花费大量的时间来加载一个过程。

第一种拟合算法**是所有算法中最好的算法**，因为

1.  与其他算法相比，它花费的时间更少。
2.  它会产生更大的孔，可用于以后加载其他进程。
3.  最容易实现。