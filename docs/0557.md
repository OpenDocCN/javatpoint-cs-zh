# 张开树

> 原文:[https://www.javatpoint.com/splay-tree](https://www.javatpoint.com/splay-tree)

八字形树是自我平衡或自我调整的二分搜索法树。换句话说，我们可以说八字树是二分搜索法树的变种。八字树的前提是我们应该了解二分搜索法树。

正如我们已经知道的，二叉查找树在每种情况下的时间复杂性。平均情况下二叉查找树的时间复杂度为 **O(logn)** ，最坏情况下的时间复杂度为 O(n)。在二叉查找树中，左子树的值小于根节点，右子树的值大于根节点；在这种情况下，时间复杂度将是**0(logn)**。如果二叉树是左偏的或右偏的，那么时间复杂度将是 O(n)。为了限制偏斜度，图中出现了 [AVL 和红黑树](red-black-tree-vs-avl-tree)，所有情况下所有操作的时间复杂度为 **O(logn** )。我们还可以通过做更多的实际实现来提高这个时间复杂度，因此设计了新的 Tree [数据结构](https://www.javatpoint.com/data-structure-tutorial)，称为 Splay tree。

### 什么是八字树？

八字树是自平衡树，但是 [AVL](https://www.javatpoint.com/avl-tree) 和[红黑树](https://www.javatpoint.com/red-black-tree)也是自平衡树。是什么让八字树成为独一无二的两棵树。它还有一个独特的特性，那就是八字形。

展开树包含与[二叉查找树](https://www.javatpoint.com/binary-search-tree)相同的操作，即插入、删除和搜索，但它还包含一个操作，即展开。所以。展开树中的所有操作之后都是展开。

八字树不是严格意义上的平衡树，但它们是大致平衡的树。让我们了解一下展开树中的搜索操作。

假设我们想在树中搜索 7 个元素，如下所示:

![Splay Tree](../Images/753ab6626703321ae5292602b10a3735.png)

要搜索显示树中的任何元素，首先，我们将执行标准的二叉查找树操作。因为 7 小于 10，所以我们将来到根节点的左边。执行搜索操作后，我们需要执行显示。在这里，展开意味着我们在任何元素上执行的操作在执行一些重新排列后应该成为根节点。树的重新排列将通过旋转来完成。

#### 注意:显示树可以定义为自调整树，其中对元素执行的任何操作都将重新排列树，以便对其执行操作的元素成为树的根节点。

### 旋转

**八字有六种旋转方式:**

1.  锯齿形旋转(右旋转)
2.  锯齿形旋转(左旋转)
3.  之字形(之字形后跟之字形)
4.  之字形
5.  Zig(两次右旋转)
6.  Zag zag(两次向左旋转)

**选择旋转类型所需的因素**

**以下是用于选择旋转类型的因素:**

*   我们试图旋转的节点有祖父母吗？
*   节点是父节点的左子节点还是右子节点？
*   节点是祖父母的左子节点还是右子节点？

### 轮换案例

**情况 1:** 如果节点没有父系，如果是父系的右子系，那么我们进行左旋转；否则，执行右旋转。

**情况 2:** 如果节点有祖父母，那么基于以下场景；将执行旋转:

**场景 1:** 如果节点在父节点的右边，并且父节点也在其父节点的右边，则执行 ***之字形右旋转*** 。

**场景 2:** 如果节点在父节点的左侧，但父节点在其父节点的右侧，则执行 ***之字形左右旋转*** 。

**场景 3:** 如果节点在父节点的右侧，父节点在其父节点的右侧，则执行 ***之字形向左旋转*** 。

**场景 4:** 如果节点在父节点的右侧，但父节点在其父节点的左侧，则执行 ***之字形左右旋转*** 。

**现在，让我们用例子来理解上面的旋转。**

为了重新排列树，我们需要进行一些旋转。以下是展开树中的旋转类型:

*   **曲折旋转**

当要搜索的项目是根节点或根节点的子节点(即左或右子节点)时，使用 zig 循环。

**以下是搜索时可以存在于展开树中的情况:**

**情况 1:** 如果搜索项是树的根节点。

**情况 2:** 如果搜索项是根节点的子节点，那么会出现两种情况:

1.  如果子对象是左子对象，将执行右旋转，称为“之”右旋转。
2.  如果子对象是右子对象，将执行左旋转，称为“之”左旋转。

**我们通过一个例子来看看上面两个场景。**

**考虑下面的例子:**

在上面的例子中，我们必须在树中搜索 7 个元素。我们将遵循以下步骤:

**步骤 1:** 首先，我们将 7 与一个根节点进行比较。由于 7 小于 10，所以它是根节点的左子节点。

**第二步:**一旦找到元素，我们将执行张开。执行右旋转，使 7 成为树的根节点，如下所示:

![Splay Tree](../Images/3a022cc9bc5253d0ad614384be2837fe.png)

**我们再来考虑一个例子。**

在上面的例子中，我们必须在树中搜索 20 个元素。我们将遵循以下步骤:

**步骤 1:** 首先，我们将 20 与一个根节点进行比较。由于 20 大于根节点，因此它是根节点的右子节点。

![Splay Tree](../Images/0a1acb716ff9e5cbfab55c7e48a885c1.png)

**第二步:**一旦找到元素，我们将执行张开。执行向左旋转，使 20 元素成为树的根节点。

![Splay Tree](../Images/e45051a269609f63d6d014e50e022fd1.png)

*   **之字形旋转**

有时，当要搜索的项目有父母和祖父母时，就会出现这种情况。在这种情况下，我们必须执行四次旋转来展开。

让我们通过一个例子来理解这个案例。

假设我们必须在树中搜索 1 个元素，如下所示:

**步骤 1:** 首先，我们必须执行标准的 BST 搜索操作，以便搜索 1 元素。由于 1 小于 10 和 7，因此它将位于节点 7 的左侧。因此，元素 1 有一个父母，即 7 个，还有一个祖父母，即 10 个。

**第二步:**这一步，我们要进行八字。我们需要借助一些旋转将节点 1 作为根节点。在这种情况下，我们不能简单地执行之字形或之字形旋转；我们必须实现之字形旋转。

为了使节点 1 成为根节点，我们需要执行两个称为 zig zig 旋转的右旋转。当我们执行右旋转时，10 将向下移动，节点 7 将向上移动，如下图所示:

![Splay Tree](../Images/4f9fa6801dace43eb50732fc13aa0c14.png)

同样，我们将执行 zig 右旋转，节点 7 将向下移动，节点 1 将向上移动，如下所示:

![Splay Tree](../Images/c58506a7fae593bb4ba9ee15ce0d4a53.png)

如上图所示，节点 1 已经成为树的根节点；因此，搜索完成。

**假设我们要在下面的树中搜索 20。**

为了搜索 20，我们需要执行两次向左旋转。以下是搜索 20 个节点所需的步骤:

![Splay Tree](../Images/d6a86ba68a82e1ddd5791c45e51ff632.png)

**第一步:**首先，我们执行标准的 BST 搜索操作。由于 20 大于 10 和 15，因此它将位于节点 15 的右侧。

**第二步:**第二步进行八字。在这种情况下，将执行两次左旋转。在第一次旋转中，节点 10 将向下移动，节点 15 将向上移动，如下所示:

![Splay Tree](../Images/173532b0cc2d070394035acfa859a780.png)

在第二次向左旋转中，节点 15 将向下移动，节点 20 成为树的根节点，如下所示:

![Splay Tree](../Images/d220f12b90286c6152667e68f4ad5b72.png)

正如我们观察到的，执行了两次左旋转；所以它被称为“之”字形左旋转。

*   **曲折曲折旋转**

到目前为止，我们已经了解到父母和祖父母要么是 RR 关系，要么是 ll 关系。现在，我们将看到父母和祖父母之间的关系。

**我们通过一个例子来理解这个案例。**

假设我们想在如下所示的树中搜索 13 个元素:

![Splay Tree](../Images/bd6c210c1ba07eadc98edc12912c9244.png)

**第一步:**首先，我们进行标准的 BST 搜索操作。由于 13 大于 10 但小于 15，因此节点 13 将是节点 15 的左子节点。

**第二步:**由于节点 13 在 15 的左边，节点 15 在节点 10 的右边，所以 RL 关系存在。首先，我们在节点 15 上执行右旋转，节点 15 将向下移动，节点 13 将向上移动，如下所示:

![Splay Tree](../Images/860e8847613b2ebaca9617f4222318d7.png)

尽管如此，节点 13 不是根节点，13 位于根节点的右侧，因此我们将执行称为 zag 旋转的左侧旋转。节点 10 将向下移动，13 成为根节点，如下所示:

![Splay Tree](../Images/bf29c8cf01ffbc25c611ef4254b5cf87.png)

正如我们在上面的树中可以观察到的，节点 13 已经成为根节点；因此，搜索完成。在这种情况下，我们首先执行了之字形旋转，然后是之字形旋转；所以，它被称为之字形旋转。

*   **锯齿曲折旋转**

**我们通过一个例子来理解这个案例。**

假设我们想在树中搜索 9 个元素，如下所示:

![Splay Tree](../Images/547343b17a55202cf12705c761f3afec.png)

**第一步:**首先，我们执行标准的 BST 搜索操作。由于 9 小于 10 但大于 7，因此它将是节点 7 的右子节点。

**第二步:**由于节点 9 在节点 7 的右边，节点 7 在节点 10 的左边，所以存在 LR 关系。首先，我们在节点 7 上执行向左旋转。节点 7 将向下移动，节点 9 将向上移动，如下所示:

![Splay Tree](../Images/6560a5b1d2827fd0235bb5b1ed575934.png)

节点 9 仍然不是根节点，9 在根节点的左边，所以我们将执行称为 zig 旋转的右旋转。执行右旋转后，节点 9 成为根节点，如下所示:

![Splay Tree](../Images/71ddca6c831109d4bb5bf73fa6a08705.png)

正如我们在上面的树中可以观察到的，节点 13 是根节点；因此，搜索完成。在这种情况下，我们首先执行了锯齿形旋转(左旋转)，然后执行了锯齿形旋转(右旋转)，因此它被称为锯齿形旋转。

### 八字树的优点

*   在展开树中，我们不需要存储额外的信息。相比之下，在 AVL 树中，我们需要存储需要额外空间的每个节点的平衡因子，而红黑树也需要存储一位额外的信息来表示节点的颜色，红色或黑色。
*   它是各种实际应用中最快的二叉查找树类型。用于 **Windows NT 和 GCC 编译器**。
*   它提供了更好的性能，因为频繁访问的节点将移动到更靠近根节点的位置，因此元素可以在展开树中快速访问。它在缓存实现中使用，因为最近访问的数据存储在缓存中，所以我们不需要去内存访问数据，并且花费的时间更少。

### 八字形树的缺点

八字形树的主要缺点是树不是严格平衡的，即它们大致平衡。有时候八字形树是线性的，所以需要 O(n)个时间复杂度。

**张开树中的插入操作**

在 ***插入*** 操作中，我们首先在树中插入元素，然后对插入的元素执行张开操作。

**15、10、17、7**

**第一步:**首先，我们在树中插入节点 15。插入后，我们需要执行张开。由于 15 是根节点，所以我们不需要执行展宽。

![Splay Tree](../Images/2ce29319feeb97125c2fd31416490a05.png)

**第二步:**下一个元素是 10。由于 10 小于 15，因此节点 10 将是节点 15 的左子节点，如下所示:

现在，我们表演*。为了使 10 成为根节点，我们将执行右旋转，如下所示:*

*![Splay Tree](../Images/4ed4b5072218de0a60087444dae46491.png)

**第三步:**下一个元素是 17。由于 17 大于 10 和 15，因此它将成为节点 15 的右子节点。

现在，我们将表演八字。由于 17 岁有父母和祖父母，所以我们将执行 zig zig 循环。

![Splay Tree](../Images/4e2cca5887fdbc3cdb304a8666892fb7.png)
![Splay Tree](../Images/4fabcb9d29683e618222b15c09a263e1.png)

在上图中，我们可以观察到 17 成为树的根节点；因此，插入完成。

**第四步:**下一个元素是 7。由于 7 小于 17、15 和 10，因此节点 7 将是 10 的左子节点。

现在，我们必须张开树。由于 7 有父母和祖父母，因此我们将执行如下所示的两次右旋转:

![Splay Tree](../Images/6cc302d67c0331f1fd27d024230e99e8.png)

节点 7 仍然不是根节点，它是根节点的左子节点，即 17。因此，我们需要再执行一次右旋转，使节点 7 成为根节点，如下所示:

![Splay Tree](../Images/1b189c6cee44f3b8684e61c85c46e416.png)

**插入操作的算法**

```

Insert(T, n)
temp= T_root
y=NULL
while(temp!=NULL)
y=temp
if(n->data data)
temp=temp->left
else
temp=temp->right
n.parent= y
if(y==NULL)
T_root = n
else if (n->data < y->data)
y->left = n
else
y->right = n
Splay(T, n) 
```

在上面的算法中，T 是树，n 是我们要插入的节点。我们已经创建了一个包含根节点地址的临时变量。我们将运行 while 循环，直到 temp 的值变为空。

一旦插入完成，将执行张开

**展开操作的算法**

```

Splay(T, N)
while(n->parent !=Null)
if(n->parent==T->root)
if(n==n->parent->left)
right_rotation(T, n->parent)
else
left_rotation(T, n->parent)
else
p= n->parent
g = p->parent
if(n=n->parent->left && p=p->parent->left)
right.rotation(T, g), right.rotation(T, p)
else if(n=n->parent->right && p=p->parent->right)
left.rotation(T, g), left.rotation(T, p)
else if(n=n->parent->left && p=p->parent->right)
right.rotation(T, p), left.rotation(T, g)
else
left.rotation(T, p), right.rotation(T, g)

Implementation of right.rotation(T, x)
right.rotation(T, x)
y= x->left
x->left=y->right
y->right=x
return y

```

在上面的实现中，x 是执行旋转的节点，而 y 是节点 x 的左子节点。

**执行向左旋转(T，x)**

```

left.rotation(T, x)
y=x->right
x->right = y->left
y->left = x
return y

```

在上面的实现中，x 是执行旋转的节点，y 是节点 x 的右子节点。

### 显示树中的删除

因为我们知道展曲树是二叉查找树的变体，所以展曲树中的删除操作类似于 BST，但是唯一的区别是在展曲树中删除操作之后是展曲操作。

**缺失类型:**

八字形树中有两种类型的缺失:

1.  自下而上张开
2.  自上而下张开

**自下而上张开**

在自下而上的显示中，首先我们从树中删除元素，然后在删除的节点上执行显示。

**我们来了解一下八字树中的删除。**

假设我们想从如下所示的树中删除 12、14:

*   首先，我们简单地执行标准的 BST 删除操作来删除 12 个元素。由于 12 是一个叶节点，所以我们只需从树中删除该节点。

![Splay Tree](../Images/e1595060b2e1547791a95a46d3e5625f.png)

删除仍未完成。我们需要显示被删除节点的父节点，即 10。我们必须在树上表演***(10)****。正如我们在上面的树中观察到的，10 在节点 7 的右边，节点 7 在节点 13 的左边。首先，我们在节点 7 上执行左旋转，然后在节点 13 上执行右旋转，如下所示:*

*![Splay Tree](../Images/b976c9826f7f2e9a32898eecf4b8eb7c.png)

然而，节点 10 不是根节点；节点 10 是根节点的左子节点。因此，我们需要在根节点上执行正确的旋转，即 14，以使节点 10 成为根节点，如下所示:

![Splay Tree](../Images/fda2c20e2fa63e783052749542810177.png)

*   现在，我们必须从树中删除 14 个元素，如下所示:

我们知道，我们不能简单地删除内部节点。我们将使用 ***代替前一个*** 或 ***代替后一个*** 来替换节点的值。假设我们使用有序后继，用右子树中存在的最低值替换该值。节点 14 的右子树中的最低值是 15，所以我们用 15 替换值 14。由于节点 14 成为叶节点，因此我们可以简单地删除它，如下所示:

![Splay Tree](../Images/13b644ed825b0e892c61ecf3c2e4428e.png)

尽管如此，删除仍未完成。我们需要再执行一个操作，即显示，其中我们需要将被删除节点的父节点作为根节点。在删除之前，节点 14 的父节点是根节点，即 10，因此在这种情况下，我们确实需要执行任何显示。

![Splay Tree](../Images/d66fbdf6294e3f88bf219f7157a08f5c.png)

**自上而下张开**

在自顶向下的显示中，我们首先执行要执行删除的显示，然后从树中删除节点。一旦元素被删除，我们将执行连接操作。

**我们通过一个例子来理解自上而下的八字形。**

假设我们想从如下所示的树中删除 16:

![Splay Tree](../Images/ebf94d9d31774d890a46641f6faae3db.png)

**步骤 1:** 在自上而下的展曲中，首先我们在节点 16 上执行展曲。节点 16 既有父母也有祖父母。节点 16 位于其父节点的右侧，并且父节点也位于其父节点的右侧，因此这是一种曲折的情况。在这种情况下，首先，我们将在节点 13 上执行左旋转，然后在节点 14 上执行左旋转，如下所示:

![Splay Tree](../Images/86325cf9749ac0b77877a10dfaca251e.png)
![Splay Tree](../Images/8ab5054f104b82c2f35d0c33558891df.png)

节点 16 仍然不是根节点，它是根节点的右子节点，所以我们需要对节点 12 执行左旋转，使节点 16 成为根节点。

![Splay Tree](../Images/3c30dfe58c91044f8e2eeb3cf718bb5f.png)

一旦节点 16 成为根节点，我们将删除节点 16，我们将获得两个不同的树，即左子树和右子树，如下所示:

![Splay Tree](../Images/95fdf045ba4f168a7688df29bb443108.png)

我们知道，左子树的值总是小于右子树的值。左子树的根是 12，右子树的根是 17。第一步是找到左边子树中的最大元素。在左边的子树中，最大元素是 15，然后我们需要在 15 上执行展开操作。

正如我们在上面的树中可以观察到的，元素 15 有一个父元素和一个祖父元素。一个节点位于其父节点的右侧，父节点也位于其父节点的右侧，因此我们需要执行两次向左旋转，以使节点 15 成为根节点，如下所示:

![Splay Tree](../Images/c5dbb6565e30172eae49945521879c2f.png)

在树上执行两次旋转后，节点 15 成为根节点。我们可以看到，15 的右边子节点为 NULL，所以我们在 15 的右边部分附加了节点 17，如下图所示，这个操作被称为 ***加入*** 操作。

![Splay Tree](../Images/7380fce534403b60665d1964b8598433.png)

#### 注意:如果元素不在要删除的显示树中，则显示将被执行。在到达空值之前，显示将在最后访问的元素上执行。

**删除操作的算法**

```

If(root==NULL) 
return NULL
Splay(root, data)
If data!= root->data
Element is not present
If root->left==NULL
root=root->right
else
temp=root
Splay(root->left, data)
root1->right=root->right
free(temp)
return root

```

在上面的算法中，我们首先检查根是否为 Null 如果根为空，则表示树为空。如果树不是空的，我们将对要删除的元素执行显示操作。一旦显示操作完成，我们将比较根数据和要删除的元素；如果两者不相等，则表示元素不在树中。如果它们相等，则可能发生以下情况:

**情况 1** :根的左边为 NULL，根的右边成为根节点。

**情况 2** :如果左右都存在，那么我们在左子树中显示最大元素。当展开完成时，最大元素成为左子树的根。右子树将成为左子树的根的右子树。

* * ***