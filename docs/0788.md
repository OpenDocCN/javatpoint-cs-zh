# 最短剩余时间优先(SRTF)调度算法

> 原文:[https://www.javatpoint.com/os-srtf-scheduling-algorithm](https://www.javatpoint.com/os-srtf-scheduling-algorithm)

这个算法是 **SJF 调度**的**抢先版**。在 SRTF，过程的执行可以在一定时间后停止。在每个进程到达时，短期调度器在可用进程列表和正在运行的进程中调度剩余突发时间最少的进程。

一旦所有进程在**就绪队列**中可用，将不进行抢占，算法将像 **SJF 调度**一样工作。当流程从执行中移除并计划下一个流程时，流程的上下文保存在**流程控制块**中。在该过程的下一次执行时，该印刷电路板被访问。

### 例子

在本例中，有五个工作岗位 P1、P2、P3、P4、五常和 P6。它们的到达时间和爆发时间在下表中给出。

| 流程标识 | 到达时间 | 突发时间 | 完成时间 | 解题时间 | 等待时间 | 响应时间 |
| one | Zero | eight | Twenty | Twenty | Twelve | Zero |
| Two | one | four | Ten | nine | five | one |
| three | Two | Two | four | Two | Zero | Two |
| four | three | one | five | Two | one | four |
| five | four | three | Thirteen | nine | six | Ten |
| six | five | Two | seven | Two | Zero | five |

![os srtf scheduling algorithm](../Images/524589120479924a7abfade56153c51c.png)

平均等待时间= 24/6

甘特图是根据表中给出的到达时间和突发时间准备的。

1.  因为在时间 0，唯一可用的进程是中央处理器突发时间为 8 的 P1 进程。这是列表中唯一可用的进程，因此已安排好。
2.  下一个进程到达时间单元 1。由于我们使用的算法是 SRTF 算法，这是一个抢占式算法，当前执行被停止，调度程序检查具有最少突发时间的进程。
    到目前为止，就绪队列中有两个进程可用。到目前为止，操作系统已经执行了 P1 一个单位的时间；P1 剩余爆发时间为 7 个单位。“P2 进程”的爆发时间为 4 个单位。因此，进程 P2 是根据算法在中央处理器上调度的。
3.  下一个过程 P3 到达时间单元 2。此时，进程 P3 的执行停止，搜索剩余突发时间最少的进程。由于 P3 进程有 2 个单位的突发时间，因此它将优先于其他进程。
4.  下一个进程 P4 到达时间单元 3。到达时，调度程序将停止执行 P4，并检查可用进程(P1、P2、P3 和 P4)中哪个进程的突发时间最少。P1 和 P2 的剩余爆发时间分别为 7 个单位和 3 个单位。

5.  下一个进程 P5 到达时间单元 4。到目前为止，P3 进程已经完成执行，不再列在清单上。调度程序将比较所有可用进程的剩余突发时间。由于进程 P4 的突发时间为 1，这是所有时间中最少的，因此将对此进行调度。
6.  下一个 P6 进程到达时间单元 5，在此之前，P4 进程已经完成了它的执行。到目前为止，我们有 4 个可用的进程，即 P1 (7)、P2 (3)、五常(3)和 P6 (2)。P6 的爆发时间是最少的，因此 P6 被安排。因为，现在，所有的过程都是可用的，所以算法现在将像 SJF 一样工作。P6 将被执行直到完成，然后剩余时间最少的过程将被安排。

一旦所有进程都到达，就没有先占权，算法将像 SJF 一样工作。